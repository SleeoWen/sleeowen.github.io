<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React18-批量更新2</title>
    <link href="/2024/07/08/React18-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B02/"/>
    <url>/2024/07/08/React18-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B02/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>http方法解析</title>
    <link href="/2022/06/23/http%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/23/http%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h2><p>HTTP，即超文本传输协议，是一种实现客户端和服务器之间通信的响应协议，它是用作客户端和服务器之间的请求。</p><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。<br>客户端（浏览器）会向服务器提交HTTP请求；然后服务器向客户端返回响应；其中响应包含有关请求的状态信息，还可能包含请求的内容。</p><h3 id="http请求包含哪些方法？"><a href="#http请求包含哪些方法？" class="headerlink" title="http请求包含哪些方法？"></a>http请求包含哪些方法？</h3><p>GET,POST,PUT,DELETE等等。</p><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p><img src="/img.png" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React18-批量更新</title>
    <link href="/2022/04/07/React%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/07/React%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="18-版本之前"><a href="#18-版本之前" class="headerlink" title="18 版本之前"></a>18 版本之前</h2><h3 id="经典面试题：setState-是同步还是异步"><a href="#经典面试题：setState-是同步还是异步" class="headerlink" title="经典面试题：setState 是同步还是异步"></a>经典面试题：setState 是同步还是异步</h3><p>在 <code>react 18</code> 版本之前，在面试中经常会出现这个问题，那么答案又是什么样的呢？</p><ul><li><p>在 <code>React</code> 合成事件中是异步的</p></li><li><p>在 <code>hooks</code> 中是异步的</p></li><li><p>其他情况皆是同步的，例如：原生事件、<code>setTimeout</code>、<code>Promise</code> 等</p></li></ul><p>看看下面这段代码的执行结果，就知道所言非虚了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    state = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>    <br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br>        &#125;);<br>        <br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有经验的同学肯定都知道，最终的结果是： <code>0 0 2 3</code>。</p><p>原因就是因为 <code>componentDidMount</code> 中的 <code>setState</code> 是批量更新，在整体逻辑没走完之前，不会进行更新。所以前两次打印结果都是 0，并且将两次更新合并成了一次。</p><p>而在 <code>setTimeout</code> 中，脱离了 <code>React</code> 的掌控，变成了同步更新，因为下方的 <code>log</code> 可以实时打印出即时的状态。</p><p>此时 <code>React</code> 的内部的处理逻辑我们可以写一段代码简单模拟一下：</p><ul><li><p>先声明三个变量，用来记录数据</p><ul><li><p><code>isBatchUpdate</code>: 判断是否批量更新的标志</p></li><li><p><code>count</code>: 状态</p></li><li><p><code>queue</code>: 存储状态的数组</p></li></ul></li><li><p>声明一个 <code>handleClick</code> 方法，来模拟 <code>React</code> 合成事件</p></li><li><p>声明一个 <code>setState</code> 方法，来模拟 <code>React</code> 的 <code>setState</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断是否批量更新的标志</span><br><span class="hljs-keyword">let</span> isBatchUpdate = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 状态</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 存储最新状态的数组</span><br><span class="hljs-keyword">let</span> queue = [];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params">state</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 批量更新，则将状态暂存，否则直接更新</span><br>    <span class="hljs-keyword">if</span> (isBatchUpdate) &#123;<br>        queue.<span class="hljs-title function_">push</span>(state);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        count = state;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 进入事件，先将 isBatchUpdate 设置为 true</span><br>    isBatchUpdate = <span class="hljs-literal">true</span><br><br>    <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>        <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 事件结束，将 isBatchUpdate 置为 false</span><br>    isBatchUpdate = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-title function_">handleClick</span>();<br><br>count = queue.<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-comment">// 更新完成，重置状态数组 queue</span><br>queue = [];<br></code></pre></td></tr></table></figure><p>可以看到，上面这段代码的打印结果也是 <code>0 0 2 3</code>。</p><h3 id="手动批量更新"><a href="#手动批量更新" class="headerlink" title="手动批量更新"></a>手动批量更新</h3><p>上面提到，在原生事件以及 <code>setTimeout</code> 等情况下，<code>setState</code> 是同步的，那<strong>如果我们仍然希望这种情况下可以批量更新</strong>，该怎么办呢？</p><p><strong><code>React</code> 也提供了一种解决方案：从 <code>react-dom</code> 包中暴露了一个 <code>API</code>: <code>unstable_batchedUpdates</code></strong></p><p>那我们简单用一下看看效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    state = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>    <br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">unstable_batchedUpdates</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>            &#125;) <br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到此时的打印结果为 <code>0 0 1 1</code>。</p><blockquote><p>Ok，React 18 之前 <code>setState</code> 的更新方式就说到这里，那 React 18 里做了什么改动呢？</p></blockquote><h2 id="React-18-版本之后"><a href="#React-18-版本之后" class="headerlink" title="React 18 版本之后"></a>React 18 版本之后</h2><p>上面提到了默认批量更新以及手动批量更新，那有些同学不满足了呀，觉得手动的还是不够智能，在很多情况下还得手动去调用 <code>unstable_batchedUpdates</code> 这个函数，用起来不爽。</p><p>别急，React 18 新版本就可以解决这些同学的痛点了！</p><p>Ok，直接上代码，看看 React 18 到底怎么用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br><br>    state = &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>    <br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>&#125;)<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 react 18 新的并发模式写法进行 dom render</span><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;#root&#x27;</span>)!).<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>)<br></code></pre></td></tr></table></figure><p>组件代码保持和第一版的一致，没有使用 <code>unstable_batchedUpdates</code>。</p><p>可以看到，此时的打印结果也是: <code>0 0 1 1</code></p><p>仅仅是使用了新的 <code>API</code>： <code>ReactDOM.createRoot(root).render(jsx)</code>。React 就能实现自动的批量更新了。感觉有点神奇。</p><p>我们依然写一段代码来模拟一下这个过程：</p><ul><li><p>此时不需要 <code>isBatchUpdate</code> 来判断是否批量更新了，而是通过更新的优先级来进行判断</p></li><li><p>每次更新会进行优先级的判定，相同优先级的任务会被合并。</p></li><li><p>事件执行完毕，进行任务的执行和更新</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 状态</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 存储状态的数组</span><br><span class="hljs-keyword">let</span> queue = [];<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params">state</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> newState = &#123;<span class="hljs-attr">payload</span>: state, <span class="hljs-attr">priority</span>: <span class="hljs-number">0</span> &#125;<br>    <span class="hljs-comment">// 判断当前优先级的任务集合是否存在，不存在则初始化，存在则存到对应由县级的任务集合中</span><br>    <span class="hljs-keyword">if</span> (queue[newState.<span class="hljs-property">priority</span>]) &#123;<br>        queue[newState.<span class="hljs-property">priority</span>].<span class="hljs-title function_">push</span>(newState.<span class="hljs-property">payload</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        queue[newState.<span class="hljs-property">priority</span>] = [newState.<span class="hljs-property">payload</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>        <span class="hljs-title function_">setState</span>(count + <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">handleClick</span>();<br><br>count = queue.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    count = queue.<span class="hljs-title function_">pop</span>().<span class="hljs-title function_">pop</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到，上面这段代码的执行结果也是 <code>0 0 1 1</code></p><p><em>上述模拟代码仅为了展示优先级批量更新，不代表任何 React 源码的逻辑和思想</em></p><p>好了，自动批量更新的新特性就说到这里了。这里引入了三个问题：</p><ol><li><p>Q: React 18 之后提供了 <code>ReactDOM.createRoot</code>(root).render(jsx) 的 API，那之前 <code>ReactDOM.render</code> 的 API 还支持吗？</p><p>A: 支持的，并且行为和之前版本是一致的。只有使用了 <code>ReactDOM.createRoot</code> 这种方式，才会启用新的并发模式。</p></li><li><p>Q: React 全自动更新后，那如果我就是想拿到更新之后的数据怎么办呢？ A: 类组件中可以使用 <code>setState(state, callback)</code> 的方式，在 <code>callback</code> 中取到最新的值，函数组件可以使用 <code>useEffect</code>，将 <code>state</code> 作为依赖。即可以拿到最新的值。</p></li><li><p>Q: 文章中说到的优先级的概念是怎么回事呢？ A: 这个涉及到 React 最新的调度以及更新的机制，优先级的概念以及其他优先级的任务如何创建，我们之后会一一展开来说。</p><p>目前的话，可以理解为 React 的更新机制进行了变化，不再依赖于批量更新的标志。而是根据任务优先级来进行更新：高优先级的任务先执行，低优先级的任务后执行。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3学习</title>
    <link href="/2022/02/22/vue3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/22/vue3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 原文地址 <a href="https://juejin.cn/post/7057325585705467918">juejin.cn</a>*   Composition Api (最核心)</p></blockquote><h2 id="Vue3-0-新特性"><a href="#Vue3-0-新特性" class="headerlink" title="Vue3.0 新特性"></a>Vue3.0 新特性</h2><ul><li>v-model 更改</li><li>v-for 的 key 节点上的使用情况更改</li><li>v-if 和 v-for 对同一元素的优先级更高</li><li>ref 内部 v-for 不再注册引用数组</li><li>功能组件只能使用普通函数创建</li><li>异步组件需要使用<code>defineAsyncComponent</code>创建方法</li><li>所有插槽都通过<code>$slots</code></li><li>在<code>destroyed</code>生命周期的选项已更名为<code>unmounted</code></li><li>在<code>beforeDestroy</code>生命周期的选项已更名为<code>beforeUnmount</code></li><li>…</li></ul><h2 id="Vue3-0-优缺点"><a href="#Vue3-0-优缺点" class="headerlink" title="Vue3.0 优缺点"></a>Vue3.0 优缺点</h2><p><strong>优点</strong>：</p><ol><li>将 Vue 内部的绝大部分 api 对外暴露，使 Vue 具备开发大型项目的能力，例如 compile 编译 api 等</li><li>webpack 的 treeshaking(tree shaking 是 DCE 的一种方式，它可以在打包时忽略没有用到的代码。) 支持度友好</li><li>使用 Proxy 进行响应式变量定义，性能提高 1.2~2 倍</li><li>ssr 快了 2~3 倍</li><li>可在 Vue2.0 中单独使用 composition-api 插件，或者直接用它开发插件</li><li>对 typescript 支持更加友好</li><li>面向未来：对于尤雨溪最近创新的 vite 开发服务器（舍弃 webpack、底层为 Koa 框架的高性能开发服务器）, 直接使用的 Vue3.0 语法</li></ol><p><strong>缺点</strong>：</p><ol><li>vue3 将不再支持 IE11，Vue 在 2.X 版本仍然支持 IE11，如果你想使用类似 Vue 3 的新特性，可以等等 Vue 2.7 版本。这次的 RFC 宣布，将会对 2.7 版本做向后兼容，移植 3.x 的部分新功能，以保证两个版本之间相似的开发体验。</li><li>对于习惯了 Vue2.0 开发模式的开发者来说，增加了心智负担，对开发者代码组织能力有体验</li></ol><blockquote><p>同时也是能力提升的机会吧，特别喜欢 Vue 作者的而设计初心：让开发者随着框架一起成长</p></blockquote><h2 id="体验-Vue3-0-的四种姿势"><a href="#体验-Vue3-0-的四种姿势" class="headerlink" title="体验 Vue3.0 的四种姿势"></a>体验 Vue3.0 的四种姿势</h2><p>现在来说，体验 Vue3.0 有四种姿势 <a href="https://link.juejin.cn/?target=https://v3.cn.vuejs.org/guide/installation.html%23%25E5%258F%2591%25E5%25B8%2583%25E7%2589%2588%25E6%259C%25AC%25E8%25AF%25B4%25E6%2598%258E" title="https://v3.cn.vuejs.org/guide/installation.html#%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">传送门</a></p><ul><li><p>通过 CDN:<code>&lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;</code></p></li><li><p>通过 <a href="https://link.juejin.cn/?target=https://codepen.io/yyx990803/pen/OJNoaZL" title="https://codepen.io/yyx990803/pen/OJNoaZL">Codepen</a> 的浏览器 playground</p></li><li><p>脚手架 <a href="https://link.juejin.cn/?target=https://github.com/vitejs/vite" title="https://github.com/vitejs/vite">Vite</a>：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init vite-app hello-vue3 <span class="hljs-comment"># OR yarn create vite-app hello-vue3</span><br>复制代码<br><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>尤大开发的新工具，目的是以后取代 webpack，原来就是利用浏览器现在已经支持 ES6 的 import；遇到 import 会发送一个 http 请求去加载对应的文件，vite 拦截这些请求，做预编译，就省去了 webpack 冗长的打包事件，提升开发体验。</p></blockquote><ul><li><p>脚手架 <a href="https://link.juejin.cn/?target=https://cli.vuejs.org/" title="https://cli.vuejs.org/">vue-cli</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm install <span class="hljs-operator">-</span>g <span class="hljs-variable">@vue</span><span class="hljs-operator">/</span>cli # <span class="hljs-keyword">OR</span> yarn <span class="hljs-keyword">global</span> <span class="hljs-keyword">add</span> <span class="hljs-variable">@vue</span><span class="hljs-operator">/</span>cli<br>vue <span class="hljs-keyword">create</span> hello<span class="hljs-operator">-</span>vue3<br># <span class="hljs-keyword">select</span> vue <span class="hljs-number">3</span> preset<br>复制代码<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="全局-API"><a href="#全局-API" class="headerlink" title="全局 API"></a>全局 API</h2><p>新的全局 api：<code>createApp</code></p><p>调用<code>createApp</code>返回一个应用实例，这是 Vue3.0 的新概念：</p><p>打开<code>src/main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>复制代码<br><br></code></pre></td></tr></table></figure><p>应用程序实例暴露当前全局 API 的子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上 app 上，以下是当前全局 API 及其相应实例 API 的表：</p><table><thead><tr><th>2.x 全局 API</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config</td><td>app.config</td></tr><tr><td>Vue.config.productionTip</td><td><em>removed</em> 已移除</td></tr><tr><td>Vue.config.ignoredElements</td><td>app.config.isCustomElement</td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr></tbody></table><h2 id="composition-API-学习"><a href="#composition-API-学习" class="headerlink" title="composition API 学习"></a>composition API 学习</h2><p><a href="https://link.juejin.cn/?target=https://composition-api.vuejs.org/zh/api.html" title="https://composition-api.vuejs.org/zh/api.html">官方网站</a></p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a><a href="https://link.juejin.cn/?target=https://composition-api.vuejs.org/zh/api.html%23setup" title="https://composition-api.vuejs.org/zh/api.html#setup">setup</a></h3><p>setup 函数是一个新的组件选项。作为组件内使用 Composition API 的入口点</p><p>创建组件实例，然后初始化 props，紧接着调用<code>setup</code>函数。它会在<code>beforeCreate</code>钩子之前调用。</p><p>setup 返回一个对象。则对象的所有属性 (<strong>它是响应式的数据</strong>) 都可以直接在模板中使用。相当于 vue2.0 中 data 函数返回的对象。</p><p><code>App.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><ul><li>ref：可传入任意类型的值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性<code>.value</code>, 改变值的时候必须使用其 value 属性</li><li>reactive: 接受一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的<code>Vue.obserable()</code></li></ul><blockquote><p>简写之：reactive 负责复杂数据结构，ref 可以把基本的数据结构包装成响应式</p></blockquote><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;state.count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>计算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 响应式变量声明 reactive负责复杂数据结构，</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">count</span>: <span class="hljs-number">1</span></span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      state.<span class="hljs-property">count</span>++;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; state, add&#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;state.count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>计算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">count</span>: <span class="hljs-number">1</span></span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      state.<span class="hljs-property">count</span>++;</span><br><span class="language-javascript">      num.<span class="hljs-property">value</span>+=<span class="hljs-number">2</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; state, add, num &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>ref 包装的 num, 模板里可以直接用，但 js 中修改的时候操作<code>.value</code>属性。</p><h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应的 property</p><p>从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解 &#x2F; 扩散:</p><p><code>useFeatureX.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">userFeatureX</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>  &#125;)<br><br>  <span class="hljs-comment">// 逻辑运行状态</span><br><br>  <span class="hljs-comment">// 返回时转换为ref</span><br>  <span class="hljs-keyword">return</span> state;<br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><p><code>App.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;toRefs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useFeatureX</span>();<br>    <span class="hljs-keyword">return</span> &#123;<br>      ...<span class="hljs-title function_">toRefs</span>(state)<br>    &#125;<br>  &#125;<br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive, ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 1.响应式变量声明 reactive负责复杂数据结构，</span><br>    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>    &#125;);<br>    <span class="hljs-comment">// 2.ref可以把基本的数据结构包装成响应式</span><br>    <span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 3.创建只读的计算属性</span><br>    <span class="hljs-keyword">const</span> computedEven1 = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span> % <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 4.创建可读可写的计算属性</span><br>    <span class="hljs-keyword">const</span> computedEven2 = <span class="hljs-title function_">computed</span>(&#123;<br>      <span class="hljs-attr">get</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> % <span class="hljs-number">2</span>;<br>      &#125;,<br>      <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-params">newVal</span>=&gt;</span>&#123;<br>        state.<span class="hljs-property">count</span> = newVal;<br>      &#125;<br>    &#125;)<br><br>    <span class="hljs-comment">// 事件的声明</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>      num.<span class="hljs-property">value</span> += <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>      computedEven2.<span class="hljs-property">value</span> = <span class="hljs-number">10</span>;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> &#123; state, add, num, computedEven1,computedEven2,handleClick &#125;;<br>  &#125;<br>&#125;;<br>复制代码<br><br></code></pre></td></tr></table></figure><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p>立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>))<br><span class="hljs-comment">// -&gt; 打印出 0</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  count.<span class="hljs-property">value</span>++<br>  <span class="hljs-comment">// -&gt; 打印出 1</span><br>&#125;, <span class="hljs-number">100</span>)<br>复制代码<br><br></code></pre></td></tr></table></figure><ol><li><p>停止监听</p><p><strong>隐式停止</strong></p><p>当 <code>watchEffect</code> 在组件的 <code>setup()</code> 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止</p><p><strong>显示停止</strong></p><p>在一些情况下，也可以显示调用返回值来停止侦听</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const <span class="hljs-selector-tag">stop</span> = <span class="hljs-built_in">watchEffect</span>(()=&gt;&#123;<br>  <span class="hljs-comment">/*...*/</span><br>&#125;)<br><span class="hljs-comment">//停止侦听</span><br><span class="hljs-selector-tag">stop</span>()<br>复制代码<br><br></code></pre></td></tr></table></figure></li><li><p>清除副作用</p><p>有时候副作用函数会执行一些异步的副作用，这些响应需要在其失效时来清除 (即完成之前状态已改变了)。可以在侦听副作用传入的函数中接受一个<code>onInvalidate</code>函数作为参数，用来注册清理失效时的回调。当以下情况发生时，这个<strong>失效回调</strong>会被触发：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止 (如果在<code>setup()</code>或生命周期钩子函数中使用了<code>watchEffect</code>, 则在卸载组件时)</li></ul><p>官网的例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">watchEffect</span><span class="hljs-params">((onInvalidate)</span></span> =&gt; &#123;<br>  const token = <span class="hljs-built_in">performAsyncOperation</span>(id.value)<br>  <span class="hljs-built_in">onInvalidate</span>(() =&gt; &#123;<br>    <span class="hljs-comment">// id 改变时 或 停止侦听时</span><br>    <span class="hljs-comment">// 取消之前的异步操作</span><br>    token<span class="hljs-selector-class">.cancel</span>()<br>  &#125;)<br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure></li></ol><p>案例：实现对用户输入 “防抖” 效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, watchEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> keyword = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncPrint</span> = val =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;user input: &#x27;</span>, val)</span><br><span class="language-javascript">        &#125;, <span class="hljs-number">1000</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title function_">watchEffect</span>(</span><br><span class="language-javascript">        <span class="hljs-function"><span class="hljs-params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">//用户输入的时间间隔小于1秒，都会立刻清除掉定时，不输入结果。正因为这个，实现了用户防抖的功能，只在用户输入时间间隔大于1秒，才做打印</span></span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">asyncPrint</span>(keyword.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">          <span class="hljs-title function_">onInvalidate</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer))</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;keyword change: &#x27;</span>, keyword.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-comment">// flush: &#x27;pre&#x27;  watch() 和 watchEffect() 在 DOM 挂载或更新之前运行副作用，所以当侦听器运行时，模板引用还未被更新。</span></span><br><span class="language-javascript">        <span class="hljs-comment">//flush: &#x27;post&#x27; 选项来定义，这将在 DOM 更新后运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。</span></span><br><span class="language-javascript">        &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">flush</span>: <span class="hljs-string">&#x27;post&#x27;</span> <span class="hljs-comment">// 默认&#x27;pre&#x27;，同步&#x27;sync&#x27;，&#x27;pre&#x27;组件更新之前</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      )</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        keyword</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-comment">// 实现对用户输入“防抖”效果</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p><code>watch</code> API 完全等效于 2.x <code>this.$watch</code> （以及 <code>watch</code> 中相应的选项）。<code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行的，也就是说仅在侦听的源变更时才执行回调。</p><p>watch() 接收的第一个参数被称作 “数据源”, 它可以是：</p><ul><li>一个返回任意值的 getter 函数</li><li>一个包装对象 (可以是 ref 也可以是 reactive 包装的对象)</li><li>一个包含上述两种数据源的数组</li></ul><p>第二个参数是回调函数。回调函数只有当数据源发生变动时才会被触发：</p><ol><li><p>侦听单个数据源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>&#125;);<br><br><span class="hljs-comment">//侦听一个reactive定义的数据,修改count值时会触发 watch的回调</span><br><span class="hljs-title function_">watch</span>(<span class="hljs-function">()=&gt;</span>state.<span class="hljs-property">count</span>,<span class="hljs-function">(<span class="hljs-params">newCount,oldCount</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newCount:&#x27;</span>,newCount);  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;oldCount:&#x27;</span>,oldCount);<br>&#125;)<br><span class="hljs-comment">//侦听一个ref</span><br><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_">watch</span>(num,<span class="hljs-function">(<span class="hljs-params">newNum,oldNum</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;newNum:&#x27;</span>,newNum);  <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;oldNum:&#x27;</span>,oldNum);<br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure></li><li><p>侦听多个数据源 (数组)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">count</span>: <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 监听一个数组</span><br><span class="hljs-title function_">watch</span>([<span class="hljs-function">()=&gt;</span>state.<span class="hljs-property">count</span>,num],<span class="hljs-function">(<span class="hljs-params">[newCount,newNum],[oldCount,oldNum]</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;new:&#x27;</span>,newCount,newNum);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;old:&#x27;</span>,oldCount,oldNum);<br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure></li><li><p>侦听复杂的嵌套对象</p><p>我们实际开发中，复杂数据随处可见， 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">person</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">fav</span>: [<span class="hljs-string">&#x27;帅哥&#x27;</span>,<span class="hljs-string">&#x27;美女&#x27;</span>,<span class="hljs-string">&#x27;音乐&#x27;</span>]<br>  &#125;,<br>&#125;);<br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">person</span>,<br>  <span class="hljs-function">(<span class="hljs-params">newType, oldType</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;新值:&quot;</span>, newType, <span class="hljs-string">&quot;老值:&quot;</span>, oldType);<br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;, <span class="hljs-comment">// 立即监听</span><br>);<br>复制代码<br><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>如果不使用第三个参数<code>deep:true</code>， 是无法监听到数据变化的。 前面我们提到，<strong>默认情况下，watch 是惰性的</strong>, 那什么情况下不是惰性的， 可以立即执行回调函数呢？其实使用也很简单， 给第三个参数中设置<code>immediate: true</code>即可</p><p>同时，watch 和 watchEffect 在停止侦听，清除副作用 (相应地 onInvalidate 会作为回调的第三个参数传入) 等方面行为一致。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> keyword = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">asyncPrint</span> = val =&gt; &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;user input: &#x27;</span>, val)</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">watch</span>(</span><br><span class="language-javascript">      keyword,</span><br><span class="language-javascript">      <span class="hljs-function">(<span class="hljs-params">newVal, oldVal, onCleanUp</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">asyncPrint</span>(keyword)</span><br><span class="language-javascript">        <span class="hljs-title function_">onCleanUp</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer))</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 默认false，即初始监听回调函数执行了</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    )</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      keyword</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>与 2.x 版本生命周期相对应的组合式 API</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/957656d7fef647f9ac1fc2d034fd5259~tplv-k3u1fbpfcp-watermark.awebp"></p><p>新建测试组件<code>/components/Test.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>更改<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;</span><br><span class="language-javascript">  ref,</span><br><span class="language-javascript">  onMounted,</span><br><span class="language-javascript">  onBeforeMount,</span><br><span class="language-javascript">  onBeforeUpdate,</span><br><span class="language-javascript">  onUpdated,</span><br><span class="language-javascript">  onBeforeUnmount,</span><br><span class="language-javascript">  onUnmounted,</span><br><span class="language-javascript">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// 初始化数据阶段的生命周期，介于beforeCreate和created之间</span></span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> a = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;👌&quot;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      a.<span class="hljs-property">value</span> += <span class="hljs-number">1</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;组件挂载之前&quot;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM挂载完成&quot;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM更新之前&quot;</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>).<span class="hljs-property">innerHTML</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM更新完成&quot;</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>).<span class="hljs-property">innerHTML</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;实例卸载之前&quot;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;实例卸载之后&quot;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; a, handleClick &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>按照官方上说的那样，你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8302e34e27544c99a04209a0a3ddec12~tplv-k3u1fbpfcp-watermark.awebp"></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><code>provide</code>和<code>inject</code>提供依赖注入，功能类似 2.x 的<code>provide/inject</code>。两者都只能在当前组件的<code>setup()</code>中调用</p><p><code>App.vue</code>provide 数据源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Article</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;</span><br><span class="language-javascript">  ref,</span><br><span class="language-javascript">  provide</span><br><span class="language-javascript">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Article</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Article&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> articleList = <span class="hljs-title function_">ref</span>([</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue3.0学习&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;小马哥&quot;</span> &#125;,</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;componsition api&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;尤大大&quot;</span> &#125;,</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue-router最新&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;vue官方&quot;</span> &#125;</span><br><span class="language-javascript">    ]);</span><br><span class="language-javascript">    <span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="language-javascript">      provide 函数允许你通过两个参数定义 property：</span></span><br><span class="hljs-comment"><span class="language-javascript">      property 的 name (&lt;String&gt; 类型)</span></span><br><span class="hljs-comment"><span class="language-javascript">      property 的 value</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;list&quot;</span>,articleList);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      articleList</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">Article</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p><code>Article.vue</code>注入数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &#123;&#123;articleList[0].title&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> articleList = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;list&#x27;</span>,[]);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;articleList&#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="模板引用-refs"><a href="#模板引用-refs" class="headerlink" title="模板引用 refs"></a>模板引用 refs</h3><p>当使用组合式 API 时，<code>reactive refs</code>和<code>template refs</code>的概念已经是统一了。为了获得对模板内元素或者组件实例的引用，可以直接在<code>setup()</code>中声明一个 ref 并返回它</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;wrap&#x27;</span>&gt;</span>hello vue3.0<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Article</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;articleComp&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Article</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;</span><br><span class="language-javascript">  ref,</span><br><span class="language-javascript">  onMounted,</span><br><span class="language-javascript">  provide</span><br><span class="language-javascript">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Article</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Article&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> isShow = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> wrap = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> articleComp = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> articleList = <span class="hljs-title function_">ref</span>([</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue3.0学习&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;小马哥&quot;</span> &#125;,</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;componsition api&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;尤大大&quot;</span> &#125;,</span><br><span class="language-javascript">      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Vue-router最新&quot;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&quot;vue官方&quot;</span> &#125;</span><br><span class="language-javascript">    ]);</span><br><span class="language-javascript">    <span class="hljs-comment">/* </span></span><br><span class="hljs-comment"><span class="language-javascript">      provide 函数允许你通过两个参数定义 property：</span></span><br><span class="hljs-comment"><span class="language-javascript">      property 的 name (&lt;String&gt; 类型)</span></span><br><span class="hljs-comment"><span class="language-javascript">      property 的 value</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;list&quot;</span>, articleList);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wrap.<span class="hljs-property">value</span>); <span class="hljs-comment">//获取div元素</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(articleComp.<span class="hljs-property">value</span>); <span class="hljs-comment">//获取的article组件实例对象</span></span><br><span class="language-javascript">      </span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      articleList,</span><br><span class="language-javascript">      wrap,</span><br><span class="language-javascript">      articleComp</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Article</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cf8bd35760842a9b4662cb67e8cceec~tplv-k3u1fbpfcp-watermark.awebp"></p><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ul><li>props</li><li>$emit</li><li>expose &#x2F;ref</li><li>attrs</li><li>v-model</li><li>provide&#x2F;inject</li><li>vuex</li><li>mitt</li></ul><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml">// Parent.vue 传送<br><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:msg1</span>=<span class="hljs-string">&quot;msg1&quot;</span> <span class="hljs-attr">:msg2</span>=<span class="hljs-string">&quot;msg2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 创建一个响应式数据</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> msg1 = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;这是传级子组件的信息1&quot;</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> msg2 = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&quot;这是传级子组件的信息2&quot;</span>])</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            msg1</span><br><span class="language-javascript">            msg2</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// Child.vue 接收<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg1&quot;</span>, <span class="hljs-string">&quot;msg2&quot;</span>],<span class="hljs-comment">// 如果这行不写，下面就接收不到</span></span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(props) <span class="hljs-comment">// &#123; msg1:&quot;这是传给子组件的信息1&quot;, msg2:&quot;这是传给子组件的信息2&quot; &#125;</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html">// Child.vue 派发<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  // 写法一<br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;myClick&#x27;,123)&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">buttom</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript"> <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript"><span class="hljs-attr">emits</span>:[<span class="hljs-string">&#x27;myClick&#x27;</span>]</span><br><span class="language-javascript"><span class="hljs-comment">//emits:&#123;</span></span><br><span class="language-javascript">  <span class="hljs-comment">//myClick:null</span></span><br><span class="language-javascript">  <span class="hljs-comment">//&#125;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// Parent.vue 响应<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">myClick</span>=<span class="hljs-string">&quot;onMyClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">onMyClick</span> = (<span class="hljs-params">msg</span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg) <span class="hljs-comment">// 这是父组件收到的信息 123</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h2 id="重大改变"><a href="#重大改变" class="headerlink" title="重大改变"></a>重大改变</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Teleport 就像是哆啦 A 梦中的「任意门」，任意门的作用就是可以将人瞬间传送到另一个地方。有了这个认识，我们再来看一下为什么需要用到 Teleport 的特性呢，看一个小例子： 在子组件<code>Header</code>中使用到<code>Dialog</code>组件，我们实际开发中经常会在类似的情形下使用到 <code>Dialog</code> ，此时<code>Dialog</code>就被渲染到一层层子组件内部，处理嵌套组件的定位、<code>z-index</code>和样式都变得困难。 <code>Dialog</code>从用户感知的层面，应该是一个独立的组件，从 dom 结构应该完全剥离 Vue 顶层组件挂载的 DOM；同时还可以使用到 Vue 组件内的状态（<code>data</code>或者<code>props</code>）的值。简单来说就是, <strong>即希望继续在组件内部使用<code>Dialog</code>, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中</strong>。 此时就需要 Teleport 上场，我们可以用<code>&lt;Teleport&gt;</code>包裹<code>Dialog</code>, 此时就建立了一个传送门，可以将<code>Dialog</code>渲染的内容传送到任何指定的地方。 接下来就举个小例子，看看 Teleport 的使用方式。</p><p>我们希望 Dialog 渲染的 dom 和顶层组件是兄弟节点关系, 在<code>index.html</code>文件中定义一个供挂载的元素:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>定义一个<code>Dialog</code>组件<code>Dialog.vue</code>, 留意 <code>to</code> 属性， 与上面的<code>id</code>选择器一致：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#dialog&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 即希望继续在组件内部使用Dialog, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中。 此时就需要 Teleport 上场，</span><br><span class="hljs-comment">      我们可以用&lt;Teleport&gt;包裹Dialog, 此时就建立了一个传送门，可以将Dialog渲染的内容传送到任何指定的地方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog_wrapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog_header&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是弹框 &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reactive, toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      ...<span class="hljs-title function_">toRefs</span>(state),</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><blockquote><p>试验性</p><p>Suspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。</p><p>生产环境请勿使用</p></blockquote><p>该 <code>&lt;suspense&gt;</code> 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。</p><p>自带两个 <code>slot</code> 分别为 <code>default、fallback</code>。顾名思义，当要加载的组件不满足状态时,<code>Suspense</code> 将回退到 <code>fallback</code>状态一直到加载的组件满足条件，才会进行渲染。</p><p>Suspense.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;loadAsyncComponent&quot;</span>&gt;</span>点击加载异步组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loadAsync&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 加载对应的组件 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">MAsynComp</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MAsynComp</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">MAsynComp</span>: <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AsynComp.vue&#x27;</span>)),</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> loadAsync = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadAsyncComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      loadAsync.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      loadAsync,</span><br><span class="language-javascript">      loadAsyncComponent,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">button</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span> <span class="hljs-number">12px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1890ff</span>;</span><br><span class="language-css">  <span class="hljs-attribute">outline</span>: none;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: none;</span><br><span class="language-css">  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">  <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.loading</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">36px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">36px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">18px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">18px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;../assets/loading.png&#x27;</span>);</span><br><span class="language-css">  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">1.4s</span> linear infinite;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-keyword">@keyframes</span> rotate &#123;</span><br><span class="language-css">  <span class="hljs-selector-tag">from</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-tag">to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>复制代码<br><br></code></pre></td></tr></table></figure><p>AsynComp.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>this is async component<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; setup &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AsyncComponent&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = (<span class="hljs-params">time</span>) =&gt; &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-title function_">reslove</span>()</span><br><span class="language-javascript">        &#125;, time)</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>) <span class="hljs-comment">//模拟数据请求</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>复制代码<br><br></code></pre></td></tr></table></figure><p>Fragments</p><p>Vue3.0 组件中可以允许有多个根组件，避免了多个没必要的 div 渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>这样做的好处：</p><ul><li>少了很多没有意义的 div</li><li>可以实现平级递归，对实现 tree 组件有很大帮助</li></ul><h3 id="emits"><a href="#emits" class="headerlink" title="emits"></a>emits</h3><ul><li>emits 可以是数组或对象</li><li>触发自定义事件</li><li>如果 emits 是对象，则允许我们配置和事件验证。验证函数应返回布尔值，以表示事件参数是否有效。</li></ul><p><code>Emits.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;submit&#x27;,&#123;username:&#x27;xiaomage&#x27;,password:&#x27;123&#x27;&#125;)&quot;</span>&gt;</span>自定义事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// emits:[&#x27;submit&#x27;],//可以是数组</span></span><br><span class="language-javascript">    <span class="hljs-attr">emits</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">submit</span>: <span class="hljs-function"><span class="hljs-params">payload</span> =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(payload.<span class="hljs-property">username</span> &amp;&amp; payload.<span class="hljs-property">password</span>)&#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;无效的payload，请检查submit事件&#x27;</span>);</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p><code>App.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Emits</span> @<span class="hljs-attr">submit</span>=<span class="hljs-string">&quot;submitHandle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Emits</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Emits</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Emits&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>:&#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">Emits</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">submitHandle</span>(<span class="hljs-params">payload</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;自定义事件触发&quot;</span>,payload);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>效果展示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfe623b08b244da7bf5f37b0864e2490~tplv-k3u1fbpfcp-watermark.awebp"></p><h3 id="全局-Vue-API-更改为应用程序实例"><a href="#全局-Vue-API-更改为应用程序实例" class="headerlink" title="全局 Vue API 更改为应用程序实例"></a>全局 Vue API 更改为应用程序实例</h3><p>上面已经讲过了，不做一一赘述了。</p><h3 id="API-可做-Tree-shakable-优化"><a href="#API-可做-Tree-shakable-优化" class="headerlink" title="API 可做 Tree shakable 优化"></a>API 可做 Tree shakable 优化</h3><p>在 vue2.0 有不少的全局 api 是作为静态函数直接挂在在 Vue 构造函数上的，你应该手动操作过 DOM, 会遇到如下模式。如果我们未是在代码中用过它们，就会形成我们所谓的 “死代码”, 这类全局 api 造成的 “死代码” 无法使用 webapck 的<code>tree-shaking</code>进行’死代码消除’。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">//一些和DOM相关的东西</span><br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure><p>因此，vue3.0 做了相应的改变，将它们抽离成为独立的函数，这样打包工具的摇树优化可以将这些 “死代码” 排除掉。全局 API 现在只能作为 ES 模块构建的命名导出进行访问。例如，我们之前的片段现在应该如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;nextTick&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-title function_">nextTick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">//一些和DOM相关的东西</span><br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure><p>受影响的 API</p><p>Vue2.x 中这些全局 API 受此更改的影响：</p><ul><li>Vue.nextTick</li><li>Vue.observable(用 Vue.reactive 替换)</li><li>Vue.version</li><li>Vue.compile(仅完全构建时)</li><li>Vue.set(仅兼容版本)</li><li>Vue.delete(仅兼容版本)</li></ul><p><code>TreeShaking.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>摇树优化，把没引入的不必要的代码进行优化<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;name&#x27;</span>&gt;</span>小马哥<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;myMsg&#x27;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMsg(&#x27;hai!&#x27;)&quot;</span>&gt;</span>改变<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref, nextTick &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;hello!&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> myMsg = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeMsg</span>(<span class="hljs-params">newV</span>) &#123;</span><br><span class="language-javascript">        msg.<span class="hljs-property">value</span> = newV;</span><br><span class="language-javascript">        <span class="hljs-comment">// console.log(myMsg.value.innerText); //直接获取DOM还是以前的</span></span><br><span class="language-javascript">        <span class="hljs-comment">// nextTick返回了promise对象</span></span><br><span class="language-javascript">        <span class="hljs-keyword">await</span> <span class="hljs-title function_">nextTick</span>();</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMsg.<span class="hljs-property">value</span>.<span class="hljs-property">innerText</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        msg,</span><br><span class="language-javascript">        myMsg,</span><br><span class="language-javascript">        changeMsg</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="Slot-具名插槽语法"><a href="#Slot-具名插槽语法" class="headerlink" title="Slot 具名插槽语法"></a>Slot 具名插槽语法</h3><p>在 Vue2.x 中， 具名插槽的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  子组件中：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>在父组件中使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>歌曲：《孤勇者》<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>如果我们要<strong>在 slot 上面绑定数据，可以使用作用域插槽</strong>，实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件</span><br>&lt;slot &gt;&lt;/slot&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">data</span>:[<span class="hljs-string">&quot;走过来人来人往&quot;</span>,<span class="hljs-string">&quot;不喜欢也得欣赏&quot;</span>,<span class="hljs-string">&quot;陪伴是最长情的告白&quot;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件中使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scoped&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in scoped.data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>在 Vue2.x 中具名插槽和作用域插槽分别使用<code>slot</code>和<code>slot-scope</code>来实现， 在 Vue3.0 中将<code>slot</code>和<code>slot-scope</code>进行了合并同意使用。 Vue3.0 中<code>v-slot</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件中使用 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:content</span>=<span class="hljs-string">&quot;scoped&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in scoped.data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 也可以简写成： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&#123;data&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in data&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="组件上-v-model-用法"><a href="#组件上-v-model-用法" class="headerlink" title="组件上 v-model 用法"></a>组件上 v-model 用法</h3><p>在 Vue 2.0 发布后，开发者使用 <code>v-model</code> 指令必须使用为 <code>value</code> 的 prop。如果开发者出于不同的目的需要使用其他的 prop，他们就不得不使用 <code>v-bind.sync</code>。此外，由于<code>v-model</code> 和 <code>value</code> 之间的这种硬编码关系的原因，产生了如何处理原生元素和自定义元素的问题。</p><p>在 Vue 2.2 中，我们引入了 <code>model</code> 组件选项，允许组件自定义用于 <code>v-model</code> 的 prop 和事件。但是，这仍然只允许在组件上使用一个 <code>model</code>。</p><p>在 Vue 3 中，双向数据绑定的 API 已经标准化，减少了开发者在使用 <code>v-model</code> 指令时的混淆并且在使用 <code>v-model</code> 指令时可以更加灵活。</p><p><strong>2.x 语法</strong></p><p>在 2.x 中，在组件上使用 <code>v-model</code> 相当于绑定 <code>value</code> prop 和 <code>input</code> 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 简写: --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>如果要将属性或事件名称更改为其他名称，则需要在 <code>ChildComponent</code> 组件中添加 <code>model</code> 选项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- ParentComponent.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ChildComponent.vue</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;title&#x27;</span>,<br>    <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;change&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-comment">// 这将允许 `value` 属性用于其他用途</span><br>    <span class="hljs-attr">value</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-comment">// 使用 `title` 代替 `value` 作为 model 的 prop</span><br>    <span class="hljs-attr">title</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;Default title&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><p>所以，在这个例子中 <code>v-model</code> 的简写如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p><strong>使用 <code>v-bind.sync</code></strong></p><p>在某些情况下，我们可能需要对某一个 prop 进行 “双向绑定”(除了前面用 <code>v-model</code> 绑定 prop 的情况)。为此，我们建议使用 <code>update:myPropName</code> 抛出事件。例如，对于在上一个示例中带有 <code>title</code> prop 的 <code>ChildComponent</code>，我们可以通过下面的方式将分配新 value 的意图传达给父级：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;update:title&#x27;</span>, newValue)<br>复制代码<br><br></code></pre></td></tr></table></figure><p>如果需要的话，父级可以监听该事件并更新本地 data property。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>为了方便起见，我们可以使用 <code>.sync</code> 修饰符来缩写，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">:title.sync</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p><strong>3.x 语法</strong></p><p>在 3.x 中，自定义组件上的 <code>v-model</code> 相当于传递了 <code>modelValue</code> prop 并接收抛出的 <code>update:modelValue</code> 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 简写: --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:modelValue</span>=<span class="hljs-string">&quot;pageTitle&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">update:modelValue</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="渲染函数-API-改变"><a href="#渲染函数-API-改变" class="headerlink" title="渲染函数 API 改变"></a>渲染函数 API 改变</h3><ul><li><code>h</code>现在全局导入，而不是作为参数传递给渲染函数</li><li>渲染函数参数更为在有状态组件和函数组件之间更加一致</li><li>vnode 现在是一个有扁平的 prop 结构</li></ul><p><code>render</code>函数将自动接收<code>h</code>函数 (它是 createElement 的别名) 作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vue2.x</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-comment">//vue3 渲染</span><br><span class="hljs-keyword">import</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>  &#125;<br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RenderComp</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;title&#x27;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 默认插槽 --&gt;</span><br>        头部<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:content</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 具名插槽 --&gt;</span><br>        内容<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">RenderComp</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123;</span><br><span class="language-javascript">    ref,</span><br><span class="language-javascript">    h</span><br><span class="language-javascript">  &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">RenderComp</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">modelValue</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">setup</span>(<span class="hljs-params">props,&#123;attrs,slots,emit&#125;</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 以前得通过$scopedSlots获取对应的插槽</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slots.<span class="hljs-title function_">default</span>()); <span class="hljs-comment">//获取默认插槽</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slots.<span class="hljs-title function_">content</span>()); <span class="hljs-comment">//获取名字为content的插槽</span></span><br><span class="language-javascript">          <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeTitle</span>(<span class="hljs-params">newV</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>,<span class="hljs-string">&#x27;哈哈哈&#x27;</span>);</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;&#125;, [<span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">onClick</span>:changeTitle,</span><br><span class="language-javascript">          &#125;,[</span><br><span class="language-javascript">            <span class="hljs-string">`渲染函数api:<span class="hljs-subst">$&#123;props.modelValue&#125;</span>`</span>,</span><br><span class="language-javascript">            slots.<span class="hljs-title function_">default</span>(),</span><br><span class="language-javascript">            slots.<span class="hljs-title function_">content</span>()</span><br><span class="language-javascript">          ])]);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;双向数据绑定&quot;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        title</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>复制代码<br><br></code></pre></td></tr></table></figure><p>同时，演示了<code>$scopedSlots</code>property 已删除，所有插槽都通过<code>$slots</code>作为函数暴露</p><h3 id="使用普通函数创建功能组件"><a href="#使用普通函数创建功能组件" class="headerlink" title="使用普通函数创建功能组件"></a>使用普通函数创建功能组件</h3><ul><li>在 3.x 中，功能性组件 2.x 的性能提升可以忽略不计，因此我们建议只使用有状态的组件</li><li>功能组件只能使用接收 <code>props</code> 和 <code>context</code> 的普通函数创建 (即：<code>slots</code>，<code>attrs</code>，<code>emit</code>)。</li><li><strong>重大变更：</strong><code>functional</code> attribute 在单文件组件 (SFC) <code>&lt;template&gt;</code> <strong>已被移除</strong></li><li><strong>重大变更：</strong><code>&#123; functional: true &#125;</code> 选项在通过函数创建组件已<strong>被移除</strong></li></ul><p>在 vue2.0 中，功能组件有两个主要用途：</p><ul><li>性能优化提高，因为它们的初始化速度比有状态组件快</li><li>可以返回多个根节点</li></ul><p>然而，在 Vue 3 中，有状态组件的性能已经提高到可以忽略不计的程度。此外，有状态组件现在还包括返回多个根节点的能力。</p><p>因此，功能组件剩下的唯一用例就是简单组件，比如创建动态标题的组件。否则，建议你像平常一样使用有状态组件。</p><blockquote><p>总结：非特殊情况下，官网还是建议我们使用有状态的组件</p></blockquote><p><code>Functional.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">DynamicHeading</span> = (<span class="hljs-params">props, context</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">`h<span class="hljs-subst">$&#123;props.level&#125;</span>`</span>, context.<span class="hljs-property">attrs</span>, context.<span class="hljs-property">slots</span>)<br>&#125;<br><br><span class="hljs-title class_">DynamicHeading</span>.<span class="hljs-property">props</span> = [<span class="hljs-string">&#x27;level&#x27;</span>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DynamicHeading</span><br>复制代码<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Functional</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&#x27;3&#x27;</span>&gt;</span>动态标题<span class="hljs-tag">&lt;/<span class="hljs-name">Functional</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>可以传入不同的 level 定制不同的 h 系列标题。</p><h3 id="异步组件的更改"><a href="#异步组件的更改" class="headerlink" title="异步组件的更改"></a>异步组件的更改</h3><ul><li>新<code>defineAsyncComponent</code>助手方法，它显示定义异步组件</li><li><code>componnet</code>选项命名为<code>loader</code></li><li>加载程序函数被本身不接受<code>resolve</code>和<code>reject</code>参数，必须返回一个 Promise</li></ul><p><strong>2.x</strong></p><p>以前，异步组件是通过将组件定义为返回 promise 的函数来创建的，例如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const asyncPage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./NextPage.vue&#x27;</span>)<br>复制代码<br><br></code></pre></td></tr></table></figure><p>对于带有选项的更高阶组件语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> asyncPage = &#123;<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./NextPage.vue&#x27;</span>),<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,<br>  <span class="hljs-attr">error</span>: <span class="hljs-title class_">ErrorComponent</span>,<br>  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">LoadingComponent</span><br>&#125;<br>复制代码<br><br></code></pre></td></tr></table></figure><p><strong>3.x</strong></p><p>在 vue3 中，由于功能组件被定义为纯函数，因为需要通过将异步组件定义包装在新的<code>defineAsyncComponent</code>助手来显式定义组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/ErrorComponent.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LoadingComponent.vue&#x27;</span><br><br><span class="hljs-comment">// 不带选项的异步组件</span><br><span class="hljs-keyword">const</span> asyncPage = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./NextPage.vue&#x27;</span>))<br><br><span class="hljs-comment">// 带选项的异步组件</span><br><span class="hljs-keyword">const</span> asyncPageWithOptions = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./NextPage.vue&#x27;</span>),<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,<br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,<br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span><br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>API 已重命名，以便更好地与组件生命周期保持一致</p><ul><li>bind → <strong>beforeMount</strong></li><li>inserted → <strong>mounted</strong></li><li><strong>beforeUpdate</strong>: 新的！这是在元素本身更新之前调用的，很像组件生命周期钩子</li><li>update → 移除！有太多的相似之处要更新，所以这是多余的，请改用 <code>updated</code></li><li>componentUpdated → <strong>updated</strong></li><li>**beforeUnmount ** <code>新的</code>与组件生命周期钩子类似，它将在卸载元素之前调用。</li><li>unbind -&gt; <strong>unmounted</strong></li></ul><p>举个例子：</p><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br><span class="hljs-comment">// 创建自定义指令</span><br>app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 指令 也拥有一组生命周期钩子</span><br>  <span class="hljs-comment">// 1.在绑定元素的父组件挂载之前调用</span><br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el,binding,vnode</span>)&#123;<br>    el.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = binding.<span class="hljs-property">value</span>;<br>  &#125;,<br>&#125;)<br>复制代码<br><br></code></pre></td></tr></table></figure><p><code>App.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-highlight</span>=<span class="hljs-string">&quot;&#x27;red&#x27;&quot;</span>&gt;</span>自定义指令<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><h3 id="动画-transion-改变"><a href="#动画-transion-改变" class="headerlink" title="动画 transion 改变"></a>动画 transion 改变</h3><ul><li>v-enter-&gt;v-enter-from</li><li>v-leave-&gt;v-leave-from</li></ul><p>vue2.x 版本中</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cd72aee50d14c1c90f163e8271f4afe~tplv-k3u1fbpfcp-watermark.awebp"></p><h3 id="移除-API"><a href="#移除-API" class="headerlink" title="移除 API"></a>移除 API</h3><ul><li><a href="https://link.juejin.cn/?target=https://www.vue3js.cn/docs/zh/guide/migration/keycode-modifiers.html" title="https://www.vue3js.cn/docs/zh/guide/migration/keycode-modifiers.html"><code>keyCode</code> 支持作为 <code>v-on</code> 的修饰符</a></li><li><a href="https://link.juejin.cn/?target=https://www.vue3js.cn/docs/zh/guide/migration/events-api.html" title="https://www.vue3js.cn/docs/zh/guide/migration/events-api.html">on，off 和 $once 实例方法</a></li><li><a href="https://link.juejin.cn/?target=https://www.vue3js.cn/docs/zh/guide/migration/filters.html" title="https://www.vue3js.cn/docs/zh/guide/migration/filters.html">过滤</a></li></ul><p>2.x, 支持<code>keyCodes</code>作为修改<code>v-on</code>方法的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 键码版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.13</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 别名版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>vue3.x</p><p>在建议对任何要用作修饰符的键使用 kebab-cased (短横线) 大小写名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Vue 3 在 v-on 上使用 按键修饰符 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.delete</span>=<span class="hljs-string">&quot;confirmDelete&quot;</span> /&gt;</span><br>复制代码<br><br></code></pre></td></tr></table></figure><p>因此，这意味着 <code>config.keyCodes</code> 现在也已弃用，不再受支持。</p><p><code>$on</code>，<code>$off</code> 和 <code>$once</code> 实例方法已被移除，应用实例不再实现事件触发接口。</p><p>Filters 已从 Vue 3.0 中删除，不再受支持。相反，我们建议用方法调用或计算属性替换它们。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>性能优化总结</title>
    <link href="/2021/07/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所有的性能优化都围绕着两大层面两小层面实现，核心层面是网络层面和渲染层面，辅助层面是时间层面和体积层面，而辅助层面则充满在核心层面里，笔者通过本文整理出关于前端性能优化的九大策略和六大指标</p></blockquote><p>「本文已参与好文召集令活动，点击查看：<a href="https://juejin.cn/post/6978685539985653767" title="https://juejin.cn/post/6978685539985653767">后端、大前端双赛道投稿，2 万元奖池等你挑战！</a>」</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>可能有些<code>性能优化建议</code>已被大家熟知，不过也不影响这次分享，当然笔者也将一些平时可能不会注意的细节罗列出来。</p><p>平时大家认为<code>性能优化</code>是一种无序的应用场景，但在笔者看来它是一种有序的应用场景且很多<code>性能优化</code>都是互相铺垫甚至一带一路。从过程趋势来看，<code>性能优化</code>可分为<strong>网络层面</strong>和<strong>渲染层面</strong>；从结果趋势来看，<code>性能优化</code>可分为<strong>时间层面</strong>和<strong>体积层面</strong>。简单来说就是<code>要在访问网站时使其快准狠地立马呈现在用户眼前</code>。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd56e49c40441f699ed659ca5a26917~tplv-k3u1fbpfcp-watermark.image"></p><p>所有的<code>性能优化</code>都围绕着<code>两大层面两小层面</code>实现，核心层面是<code>网络层面</code>和<code>渲染层面</code>，辅助层面是<code>时间层面</code>和<code>体积层面</code>，而辅助层面则充满在核心层面里。于是笔者通过本文整理出关于前端<code>性能优化</code>的<strong>九大策略</strong>和<strong>六大指标</strong>。当然这些<code>策略</code>和<code>指标</code>都是笔者自己定义，方便通过某种方式为性能优化做一些规范。</p><p>因此在工作或面试时结合这些特征就能完美地诠释<code>性能优化</code>所延伸出来的知识了。<strong>前方高能，不看也得收藏，走起！！！</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">所有代码示例为了凸显主题，只展示核心配置代码，其他配置并未补上，请自行脑补<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="九大策略"><a href="#九大策略" class="headerlink" title="九大策略"></a>九大策略</h3><h4 id="网络层面"><a href="#网络层面" class="headerlink" title="网络层面"></a>网络层面</h4><p><strong>网络层面</strong>的性能优化，无疑是如何让资源<code>体积更小加载更快</code>，因此笔者从以下四方面做出建议。</p><ul><li><strong>构建策略</strong>：基于构建工具 (<code>Webpack/Rollup/Parcel/Esbuild/Vite/Gulp</code>)</li><li><strong>图像策略</strong>：基于图像类型 (<code>JPG/PNG/SVG/WebP/Base64</code>)</li><li><strong>分发策略</strong>：基于内容分发网络 (<code>CDN</code>)</li><li><strong>缓存策略</strong>：基于浏览器缓存 (<code>强缓存/协商缓存</code>)</li></ul><p>上述四方面都是一步接着一步完成，充满在整个项目流程里。<strong>构建策略</strong>和<strong>图像策略</strong>处于开发阶段，<strong>分发策略</strong>和<strong>缓存策略</strong>处于生产阶段，因此在每个阶段都可检查是否按顺序接入上述策略。通过这种方式就能最大限度增加<code>性能优化</code>应用场景。</p><h5 id="构建策略"><a href="#构建策略" class="headerlink" title="构建策略"></a>构建策略</h5><p>该策略主要围绕<code>webpack</code>做相关处理，同时也是接入最普遍的<code>性能优化策略</code>。其他构建工具的处理也是大同小异，可能只是配置上不一致。说到<code>webpack</code>的<code>性能优化</code>，无疑是从<code>时间层面</code>和<code>体积层面</code>入手。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">笔者发现目前webpack <span class="hljs-built_in">v5</span>整体兼容性还不是特别好，某些功能配合第三方工具可能出现问题，故暂未升级到<span class="hljs-built_in">v5</span>，继续使用<span class="hljs-built_in">v4</span>作为生产工具，故以下配置均基于<span class="hljs-built_in">v4</span>，但总体与<span class="hljs-built_in">v5</span>的配置出入不大<br>复制代码<br></code></pre></td></tr></table></figure><p>笔者对两层面分别做出 6 个<code>性能优化建议</code>总共 12 个<code>性能优化建议</code>，为了方便记忆均使用四字词语概括，方便大家消化。⏱表示<code>减少打包时间</code>，📦表示<code>减少打包体积</code>。</p><ul><li><strong>减少打包时间</strong>：<code>缩减范围</code>、<code>缓存副本</code>、<code>定向搜索</code>、<code>提前构建</code>、<code>并行构建</code>、<code>可视结构</code></li><li><strong>减少打包体积</strong>：<code>分割代码</code>、<code>摇树优化</code>、<code>动态垫片</code>、<code>按需加载</code>、<code>作用提升</code>、<code>压缩资源</code></li></ul><blockquote><p>⏱缩减范围</p></blockquote><p><strong>配置 include&#x2F;exclude 缩小 Loader 对文件的搜索范围</strong>，好处是<code>避免不必要的转译</code>。<code>node_modules目录</code>的体积这么大，那得增加多少时间成本去检索所有文件啊？</p><p><code>include/exclude</code>通常在各大<code>Loader</code>里配置，<code>src目录</code>通常作为源码目录，可做如下处理。当然<code>include/exclude</code>可根据实际情况修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [&#123;<br>            <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>            <span class="hljs-attr">include</span>: <span class="hljs-regexp">/src/</span>,<br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">use</span>: <span class="hljs-string">&quot;babel-loader&quot;</span><br>        &#125;]<br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>⏱缓存副本</p></blockquote><p><strong>配置 cache 缓存 Loader 对文件的编译副本</strong>，好处是<code>再次编译时只编译修改过的文件</code>。未修改过的文件干嘛要随着修改过的文件重新编译呢？</p><p>大部分<code>Loader/Plugin</code>都会提供一个可使用编译缓存的选项，通常包含<code>cache</code>字眼。以<code>babel-loader</code>和<code>eslint-webpack-plugin</code>为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">EslintPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;eslint-webpack-plugin&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [&#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">use</span>: [&#123;<br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>                <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span> &#125;<br>            &#125;]<br>        &#125;]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EslintPlugin</span>(&#123; <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span> &#125;)<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>⏱定向搜索</p></blockquote><p><strong>配置 resolve 提高文件的搜索速度</strong>，好处是<code>定向指定必须文件路径</code>。若某些第三方库以常规形式引入可能报错或希望程序自动索引特定类型文件都可通过该方式解决。</p><p><code>alias</code>映射模块路径，<code>extensions</code>表明文件后缀，<code>noParse</code>过滤无依赖文件。通常配置<code>alias</code>和<code>extensions</code>就足够。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&quot;#&quot;</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-comment">// 根目录快捷方式</span><br>            <span class="hljs-string">&quot;@&quot;</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;src&quot;</span>), <span class="hljs-comment">// src目录快捷方式</span><br>            <span class="hljs-attr">swiper</span>: <span class="hljs-string">&quot;swiper/js/swiper.min.js&quot;</span><br>        &#125;, <span class="hljs-comment">// 模块导入快捷方式</span><br>        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.ts&quot;</span>, <span class="hljs-string">&quot;.jsx&quot;</span>, <span class="hljs-string">&quot;.tsx&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>, <span class="hljs-string">&quot;.vue&quot;</span>] <span class="hljs-comment">// import路径时文件可省略后缀名</span><br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>⏱提前构建</p></blockquote><p><strong>配置 DllPlugin 将第三方依赖提前打包</strong>，好处是<code>将DLL与业务代码完全分离且每次只构建业务代码</code>。这是一个古老配置，在<code>webpack v2</code>时已存在，不过现在<code>webpack v4+</code>已不推荐使用该配置，因为其版本迭代带来的性能提升足以忽略<code>DllPlugin</code>所带来的效益。</p><p><strong>DLL</strong> 意为<code>动态链接库</code>，指一个包含可由多个程序同时使用的代码库。在前端领域里可认为是另类缓存的存在，它把公共代码打包为 DLL 文件并存到硬盘里，再次打包时动态链接<code>DLL文件</code>就无需再次打包那些公共代码，从而提升构建速度，减少打包时间。</p><p>配置<code>DLL</code>总体来说相比其他配置复杂，配置流程可大致分为三步。</p><p>首先告知构建脚本哪些依赖做成<code>DLL</code>并生成<code>DLL文件</code>和<code>DLL映射表文件</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DefinePlugin</span>, <span class="hljs-title class_">DllPlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;webpack&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">vendor</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;react-dom&quot;</span>, <span class="hljs-string">&quot;react-router-dom&quot;</span>]<br>    &#125;,<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span>,<br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">splitChunks</span>: &#123;<br>            <span class="hljs-attr">cacheGroups</span>: &#123;<br>                <span class="hljs-attr">vendor</span>: &#123;<br>                    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;all&quot;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vendor&quot;</span>,<br>                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;[name].dll.js&quot;</span>, <span class="hljs-comment">// 输出路径和文件名称</span><br>        <span class="hljs-attr">library</span>: <span class="hljs-string">&quot;[name]&quot;</span>, <span class="hljs-comment">// 全局变量名称：其他模块会从此变量上获取里面模块</span><br>        <span class="hljs-attr">path</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;dist/static&quot;</span>) <span class="hljs-comment">// 输出目录路径</span><br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefinePlugin</span>(&#123;<br>            <span class="hljs-string">&quot;process.env.NODE_ENV&quot;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&quot;development&quot;</span>) <span class="hljs-comment">// DLL模式下覆盖生产环境成开发环境(启动第三方依赖调试模式)</span><br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DllPlugin</span>(&#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;[name]&quot;</span>, <span class="hljs-comment">// 全局变量名称：减小搜索范围，与output.library结合使用</span><br>            <span class="hljs-attr">path</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;dist/static/[name]-manifest.json&quot;</span>) <span class="hljs-comment">// 输出目录路径</span><br>        &#125;)<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>然后在<code>package.json</code>里配置执行脚本且每次构建前首先执行该脚本打包出<code>DLL文件</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;dll&quot;</span>: <span class="hljs-string">&quot;webpack --config webpack.dll.js&quot;</span><br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>最后链接<code>DLL文件</code>并告知<code>webpack</code>可命中的<code>DLL文件</code>让其自行读取。使用 <a href="https://link.juejin.cn/?target=https://github.com/jharris4/html-webpack-tags-plugin" title="https://github.com/jharris4/html-webpack-tags-plugin">html-webpack-tags-plugin</a> 在打包时自动插入<code>DLL文件</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DllReferencePlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;webpack&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HtmlTagsPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;html-webpack-tags-plugin&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DllReferencePlugin</span>(&#123;<br>            <span class="hljs-attr">manifest</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;dist/static/vendor-manifest.json&quot;</span>) <span class="hljs-comment">// manifest文件路径</span><br>        &#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlTagsPlugin</span>(&#123;<br>            <span class="hljs-attr">append</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 在生成资源后插入</span><br>            <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// 使用公共路径</span><br>            <span class="hljs-attr">tags</span>: [<span class="hljs-string">&quot;static/vendor.dll.js&quot;</span>] <span class="hljs-comment">// 资源路径</span><br>        &#125;)<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>为了那几秒钟的时间成本，笔者建议配置上较好。当然也可使用 <a href="https://link.juejin.cn/?target=https://github.com/asfktz/autodll-webpack-plugin" title="https://github.com/asfktz/autodll-webpack-plugin">autodll-webpack-plugin</a> 代替手动配置。</p><blockquote><p>⏱并行构建</p></blockquote><p><strong>配置 Thread 将 Loader 单进程转换为多进程</strong>，好处是<code>释放CPU多核并发的优势</code>。在使用<code>webpack</code>构建项目时会有大量文件需解析和处理，构建过程是计算密集型的操作，随着文件增多会使构建过程变得越慢。</p><p>运行在<code>Node</code>里的<code>webpack</code>是单线程模型，简单来说就是<code>webpack</code>待处理的任务需一件件处理，不能同一时刻处理多件任务。</p><p><code>文件读写</code>与<code>计算操作</code>无法避免，能不能让<code>webpack</code>同一时刻处理多个任务，发挥多核<code>CPU</code>电脑的威力以提升构建速度呢？<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/thread-loader" title="https://github.com/webpack-contrib/thread-loader">thread-loader</a> 来帮你，根据<code>CPU</code>个数开启线程。</p><p>在此需注意一个问题，若项目文件不算多就不要使用该<code>性能优化建议</code>，毕竟开启多个线程也会存在性能开销。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Os</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;os&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [&#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>            <span class="hljs-attr">use</span>: [&#123;<br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;thread-loader&quot;</span>,<br>                <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">workers</span>: <span class="hljs-title class_">Os</span>.<span class="hljs-title function_">cpus</span>().<span class="hljs-property">length</span> &#125;<br>            &#125;, &#123;<br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>                <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">cacheDirectory</span>: <span class="hljs-literal">true</span> &#125;<br>            &#125;]<br>        &#125;]<br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>⏱可视结构</p></blockquote><p><strong>配置 BundleAnalyzer 分析打包文件结构</strong>，好处是<code>找出导致体积过大的原因</code>。从而通过分析原因得出优化方案减少构建时间。<code>BundleAnalyzer</code>是<code>webpack</code>官方插件，可直观分析<code>打包文件</code>的模块组成部分、模块体积占比、模块包含关系、模块依赖关系、文件是否重复、压缩体积对比等可视化数据。</p><p>可使用 <a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/webpack-bundle-analyzer" title="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a> 配置，有了它，我们就能快速找到相关问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BundleAnalyzerPlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;webpack-bundle-analyzer&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-title class_">BundleAnalyzerPlugin</span>()<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦分割代码</p></blockquote><p><strong>分割各个模块代码，提取相同部分代码</strong>，好处是<code>减少重复代码的出现频率</code>。<code>webpack v4</code>使用<code>splitChunks</code>替代<code>CommonsChunksPlugin</code>实现代码分割。</p><p><code>splitChunks</code>配置较多，详情可参考<a href="https://link.juejin.cn/?target=https://webpack.docschina.org/configuration/optimization/%23optimizationsplitchunks" title="https://webpack.docschina.org/configuration/optimization/#optimizationsplitchunks">官网</a>，在此笔者贴上常用配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-attr">runtimeChunk</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;manifest&quot;</span> &#125;, <span class="hljs-comment">// 抽离WebpackRuntime函数</span><br>        <span class="hljs-attr">splitChunks</span>: &#123;<br>            <span class="hljs-attr">cacheGroups</span>: &#123;<br>                <span class="hljs-attr">common</span>: &#123;<br>                    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;common&quot;</span>,<br>                    <span class="hljs-attr">priority</span>: <span class="hljs-number">5</span>,<br>                    <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 重用已存在代码块</span><br>                    <span class="hljs-attr">test</span>: <span class="hljs-title class_">AbsPath</span>(<span class="hljs-string">&quot;src&quot;</span>)<br>                &#125;,<br>                <span class="hljs-attr">vendor</span>: &#123;<br>                    <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;initial&quot;</span>, <span class="hljs-comment">// 代码分割类型</span><br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vendor&quot;</span>, <span class="hljs-comment">// 代码块名称</span><br>                    <span class="hljs-attr">priority</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 优先级</span><br>                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span> <span class="hljs-comment">// 校验文件正则表达式</span><br>                &#125;<br>            &#125;, <span class="hljs-comment">// 缓存组</span><br>            <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;all&quot;</span> <span class="hljs-comment">// 代码分割类型：all全部模块，async异步模块，initial入口模块</span><br>        &#125; <span class="hljs-comment">// 代码块分割</span><br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦摇树优化</p></blockquote><p><strong>删除项目中未被引用代码</strong>，好处是<code>移除重复代码和未使用代码</code>。<code>摇树优化</code>首次出现于<code>rollup</code>，是<code>rollup</code>的核心概念，后来在<code>webpack v2</code>里借鉴过来使用。</p><p><code>摇树优化</code>只对<code>ESM规范</code>生效，对其他模块规范失效。<code>摇树优化</code>针对静态结构分析，只有<code>import/export</code>才能提供静态的<code>导入/导出</code>功能。因此在编写业务代码时必须使用<code>ESM规范</code>才能让<code>摇树优化</code>移除重复代码和未使用代码。</p><p>在<code>webpack</code>里只需将打包环境设置成<code>生产环境</code>就能让<code>摇树优化</code>生效，同时业务代码使用<code>ESM规范</code>编写，使用<code>import</code>导入模块，使用<code>export</code>导出模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span><br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦动态垫片</p></blockquote><p><strong>通过垫片服务根据 UA 返回当前浏览器代码垫片</strong>，好处是<code>无需将繁重的代码垫片打包进去</code>。每次构建都配置<code>@babel/preset-env</code>和<code>core-js</code>根据某些需求将<code>Polyfill</code>打包进来，这无疑又为代码体积增加了贡献。</p><p><code>@babel/preset-env</code>提供的<code>useBuiltIns</code>可按需导入<code>Polyfill</code>。</p><ul><li><strong>false</strong>：无视<code>target.browsers</code>将所有<code>Polyfill</code>加载进来</li><li><strong>entry</strong>：根据<code>target.browsers</code>将部分<code>Polyfill</code>加载进来 (仅引入有浏览器不支持的<code>Polyfill</code>，需在入口文件<code>import &quot;core-js/stable&quot;</code>)</li><li><strong>usage</strong>：根据<code>target.browsers</code>和检测代码里 ES6 的使用情况将部分<code>Polyfill</code>加载进来 (无需在入口文件<code>import &quot;core-js/stable&quot;</code>)</li></ul><p>在此推荐大家使用<code>动态垫片</code>。<code>动态垫片</code>可根据浏览器<code>UserAgent</code>返回当前浏览器<code>Polyfill</code>，其思路是根据浏览器的<code>UserAgent</code>从<code>browserlist</code>查找出当前浏览器哪些特性缺乏支持从而返回这些特性的<code>Polyfill</code>。对这方面感兴趣的同学可参考 <a href="https://link.juejin.cn/?target=https://github.com/Financial-Times/polyfill-library" title="https://github.com/Financial-Times/polyfill-library">polyfill-library</a> 和 <a href="https://link.juejin.cn/?target=https://github.com/Financial-Times/polyfill-service" title="https://github.com/Financial-Times/polyfill-service">polyfill-service</a> 的源码。</p><p>在此提供两个<code>动态垫片</code>服务，可在不同浏览器里点击以下链接看看输出不同的<code>Polyfill</code>。相信<code>IExplore</code>还是最多<code>Polyfill</code>的，它自豪地说：<code>我就是我，不一样的烟火</code>。</p><ul><li><strong>官方 CDN 服务</strong>：<a href="https://link.juejin.cn/?target=https://polyfill.io/v3/polyfill.min.js" title="https://polyfill.io/v3/polyfill.min.js">polyfill.io&#x2F;v3&#x2F;polyfill…</a></li><li><strong>阿里 CDN 服务</strong>：<a href="https://link.juejin.cn/?target=https://polyfill.alicdn.com/polyfill.min.js" title="https://polyfill.alicdn.com/polyfill.min.js">polyfill.alicdn.com&#x2F;polyfill.mi…</a></li></ul><p>使用 <a href="https://link.juejin.cn/?target=https://github.com/jharris4/html-webpack-tags-plugin" title="https://github.com/jharris4/html-webpack-tags-plugin">html-webpack-tags-plugin</a> 在打包时自动插入<code>动态垫片</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HtmlTagsPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;html-webpack-tags-plugin&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlTagsPlugin</span>(&#123;<br>            <span class="hljs-attr">append</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 在生成资源后插入</span><br>            <span class="hljs-attr">publicPath</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 使用公共路径</span><br>            <span class="hljs-attr">tags</span>: [<span class="hljs-string">&quot;https://polyfill.alicdn.com/polyfill.min.js&quot;</span>] <span class="hljs-comment">// 资源路径</span><br>        &#125;)<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦按需加载</p></blockquote><p><strong>将路由页面 &#x2F; 触发性功能单独打包为一个文件，使用时才加载</strong>，好处是<code>减轻首屏渲染的负担</code>。因为项目功能越多其打包体积越大，导致首屏渲染速度越慢。</p><p>首屏渲染时只需对应<code>JS代码</code>而无需其他<code>JS代码</code>，所以可使用<code>按需加载</code>。<code>webpack v4</code>提供模块按需切割加载功能，配合<code>import()</code>可做到首屏渲染减包的效果，从而加快首屏渲染速度。只有当触发某些功能时才会加载当前功能的<code>JS代码</code>。</p><p><code>webpack v4</code>提供魔术注解命名<code>切割模块</code>，若无注解则切割出来的模块无法分辨出属于哪个业务模块，所以一般都是一个业务模块共用一个<code>切割模块</code>的注解名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Login</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackChunkName: &quot;login&quot; */</span> <span class="hljs-string">&quot;../../views/login&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Logon</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">import</span>( <span class="hljs-comment">/* webpackChunkName: &quot;logon&quot; */</span> <span class="hljs-string">&quot;../../views/logon&quot;</span>);<br>复制代码<br></code></pre></td></tr></table></figure><p>运行起来控制台可能会报错，在<code>package.json</code>的<code>babel</code>相关配置里接入 <a href="https://link.juejin.cn/?target=https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import.html" title="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import.html">@babel&#x2F;plugin-syntax-dynamic-import</a> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-string">&quot;babel&quot;</span>: &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-string">&quot;plugins&quot;</span>: [<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-string">&quot;@babel/plugin-syntax-dynamic-import&quot;</span><br>        ]<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦作用提升</p></blockquote><p><strong>分析模块间依赖关系，把打包好的模块合并到一个函数中</strong>，好处是<code>减少函数声明和内存花销</code>。<code>作用提升</code>首次出现于<code>rollup</code>，是<code>rollup</code>的核心概念，后来在<code>webpack v3</code>里借鉴过来使用。</p><p>在未开启<code>作用提升</code>前，构建后的代码会存在大量函数闭包。由于模块依赖，通过<code>webpack</code>打包后会转换成<code>IIFE</code>，大量函数闭包包裹代码会导致打包体积增大 (<code>模块越多越明显</code>)。在运行代码时创建的函数作用域变多，从而导致更大的内存开销。</p><p>在开启<code>作用提升</code>后，构建后的代码会按照引入顺序放到一个函数作用域里，通过适当重命名某些变量以防止变量名冲突，从而减少函数声明和内存花销。</p><p>在<code>webpack</code>里只需将打包环境设置成<code>生产环境</code>就能让<code>作用提升</code>生效，或显式设置<code>concatenateModules</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;production&quot;</span><br>&#125;;<br><span class="hljs-comment">// 显式设置</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-attr">concatenateModules</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>📦压缩资源</p></blockquote><p><strong>压缩 HTML&#x2F;CSS&#x2F;JS 代码，压缩字体 &#x2F; 图像 &#x2F; 音频 &#x2F; 视频</strong>，好处是<code>更有效减少打包体积</code>。极致地优化代码都有可能不及优化一个资源文件的体积更有效。</p><p>针对<code>HTML</code>代码，使用 <a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin" title="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin</a> 开启压缩功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HtmlPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;html-webpack-plugin&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-title class_">HtmlPlugin</span>(&#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-attr">minify</span>: &#123;<br>                <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span><br>            &#125; <span class="hljs-comment">// 压缩HTML</span><br>        &#125;)<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>针对<code>CSS/JS</code>代码，分别使用以下插件开启压缩功能。其中<code>OptimizeCss</code>基于<code>cssnano</code>封装，<code>Uglifyjs</code>和<code>Terser</code>都是<code>webpack</code>官方插件，同时需注意压缩<code>JS代码</code>需区分<code>ES5</code>和<code>ES6</code>。</p><ul><li><a href="https://link.juejin.cn/?target=https://github.com/NMFR/optimize-css-assets-webpack-plugin" title="https://github.com/NMFR/optimize-css-assets-webpack-plugin">optimize-css-assets-webpack-plugin</a>：压缩<code>CSS代码</code></li><li><a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/uglifyjs-webpack-plugin" title="https://github.com/webpack-contrib/uglifyjs-webpack-plugin">uglifyjs-webpack-plugin</a>：压缩<code>ES5</code>版本的<code>JS代码</code></li><li><a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/terser-webpack-plugin" title="https://github.com/webpack-contrib/terser-webpack-plugin">terser-webpack-plugin</a>：压缩<code>ES6</code>版本的<code>JS代码</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">OptimizeCssAssetsPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;optimize-css-assets-webpack-plugin&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">TerserPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;terser-webpack-plugin&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">UglifyjsPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uglifyjs-webpack-plugin&quot;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">compressOpts</span> = type =&gt; (&#123;<br>    <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 缓存文件</span><br>    <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 并行处理</span><br>    [<span class="hljs-string">`<span class="hljs-subst">$&#123;type&#125;</span>Options`</span>]: &#123;<br>        <span class="hljs-attr">beautify</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">compress</span>: &#123; <span class="hljs-attr">drop_console</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125; <span class="hljs-comment">// 压缩配置</span><br>&#125;);<br><span class="hljs-keyword">const</span> compressCss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCssAssetsPlugin</span>(&#123;<br>    <span class="hljs-attr">cssProcessorOptions</span>: &#123;<br>        <span class="hljs-attr">autoprefixer</span>: &#123; <span class="hljs-attr">remove</span>: <span class="hljs-literal">false</span> &#125;, <span class="hljs-comment">// 设置autoprefixer保留过时样式</span><br>        <span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 避免cssnano重新计算z-index</span><br>    &#125;<br>&#125;);<br><span class="hljs-keyword">const</span> compressJs = <span class="hljs-variable constant_">USE_ES6</span><br>    ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(<span class="hljs-title function_">compressOpts</span>(<span class="hljs-string">&quot;terser&quot;</span>))<br>    : <span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyjsPlugin</span>(<span class="hljs-title function_">compressOpts</span>(<span class="hljs-string">&quot;uglify&quot;</span>));<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-attr">minimizer</span>: [compressCss, compressJs] <span class="hljs-comment">// 代码压缩</span><br>    &#125;<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p>针对<code>字体/音频/视频</code>文件，还真没相关<code>Plugin</code>供我们使用，就只能拜托大家在发布项目到生产服前使用对应的压缩工具处理了。针对<code>图像</code>文件，大部分<code>Loader/Plugin</code>封装时均使用了某些图像处理工具，而这些工具的某些功能又托管在国外服务器里，所以导致经常安装失败。具体解决方式可回看笔者曾经发布的<a href="https://juejin.cn/post/6844904192247595022" title="https://juejin.cn/post/6844904192247595022">《聊聊 NPM 镜像那些险象环生的坑》</a>一文寻求答案。</p><p>鉴于此，笔者花了一点小技巧开发了一个<code>Plugin</code>用于配合<code>webpack</code>压缩图像，详情请参考 <a href="https://link.juejin.cn/?target=https://github.com/JowayYoung/tinyimg-webpack-plugin" title="https://github.com/JowayYoung/tinyimg-webpack-plugin">tinyimg-webpack-plugin</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">TinyimgPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;tinyimg-webpack-plugin&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-title class_">TinyimgPlugin</span>()<br>    ]<br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><hr><p>上述<code>构建策略</code>都集成到笔者开源的 <a href="https://link.juejin.cn/?target=https://github.com/JowayYoung/bruce-cli" title="https://github.com/JowayYoung/bruce-cli">bruce-cli</a> 里，它是一个 <strong>React&#x2F;Vue</strong> 应用自动化构建脚手架，其零配置开箱即用的优点非常适合入门级、初中级、快速开发项目的前端同学使用，还可通过创建<code>brucerc.js</code>文件覆盖其默认配置，只需专注业务代码的编写无需关注构建代码的编写，让项目结构更简洁。详情请戳<a href="https://link.juejin.cn/?target=https://github.com/JowayYoung/bruce-cli" title="https://github.com/JowayYoung/bruce-cli">这里</a>，使用时记得查看文档，支持一个 <a href="https://link.juejin.cn/?target=https://github.com/JowayYoung/bruce-cli" title="https://github.com/JowayYoung/bruce-cli">Star</a> 哈！</p><h5 id="图像策略"><a href="#图像策略" class="headerlink" title="图像策略"></a>图像策略</h5><p>该策略主要围绕<code>图像类型</code>做相关处理，同时也是接入成本较低的<code>性能优化策略</code>。只需做到以下两点即可。</p><ul><li><strong>图像选型</strong>：了解所有图像类型的特点及其何种应用场景最合适</li><li><strong>图像压缩</strong>：在部署到生产环境前使用工具或脚本对其压缩处理</li></ul><p><code>图像选型</code>一定要知道每种图像类型的<code>体积/质量/兼容/请求/压缩/透明/场景</code>等参数相对值，这样才能迅速做出判断在何种场景使用何种类型的图像。</p><table><thead><tr><th>类型</th><th>体积</th><th>质量</th><th>兼容</th><th>请求</th><th>压缩</th><th>透明</th><th>场景</th></tr></thead><tbody><tr><td>JPG</td><td>小</td><td>中</td><td>高</td><td>是</td><td>有损</td><td>不支持</td><td>背景图、轮播图、色彩丰富图</td></tr><tr><td>PNG</td><td>大</td><td>高</td><td>高</td><td>是</td><td>无损</td><td>支持</td><td>图标、透明图</td></tr><tr><td>SVG</td><td>小</td><td>高</td><td>高</td><td>是</td><td>无损</td><td>支持</td><td>图标、矢量图</td></tr><tr><td>WebP</td><td>小</td><td>中</td><td>低</td><td>是</td><td>兼备</td><td>支持</td><td>看兼容情况</td></tr><tr><td>Base64</td><td>看情况</td><td>中</td><td>高</td><td>否</td><td>无损</td><td>支持</td><td>图标</td></tr></tbody></table><p><code>图像压缩</code>可在上述<code>构建策略-压缩资源</code>里完成，也可自行使用工具完成。由于现在大部分<code>webpack</code>图像压缩工具不是安装失败就是各种环境问题 (<code>你懂的</code>)，所以笔者还是推荐在发布项目到生产服前使用图像压缩工具处理，这样运行稳定也不会增加打包时间。</p><p>好用的图像压缩工具无非就是以下几个，若有更好用的工具麻烦在评论里补充喔！</p><table><thead><tr><th>工具</th><th>开源</th><th>收费</th><th>API</th><th>免费体验</th></tr></thead><tbody><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.tuhaokuai.com" target="_blank" rel="nofollow noopener noreferrer" title="https://www.tuhaokuai.com" ref="nofollow noopener noreferrer">QuickPicture</a></td><td>✖️</td><td>✔️</td><td>✖️</td><td>可压缩类型较多，压缩质感较好，有体积限制，有数量限制</td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fshrinkme.app" target="_blank" rel="nofollow noopener noreferrer" title="https://shrinkme.app" ref="nofollow noopener noreferrer">ShrinkMe</a></td><td>✖️</td><td>✖️</td><td>✖️</td><td>可压缩类型较多，压缩质感一般，无数量限制，有体积限制</td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fsquoosh.app" target="_blank" rel="nofollow noopener noreferrer" title="https://squoosh.app" ref="nofollow noopener noreferrer">Squoosh</a></td><td>✔️</td><td>✖️</td><td>✔️</td><td>可压缩类型较少，压缩质感一般，无数量限制，有体积限制</td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftinyjpg.com" target="_blank" rel="nofollow noopener noreferrer" title="https://tinyjpg.com" ref="nofollow noopener noreferrer">TinyJpg</a></td><td>✖️</td><td>✔️</td><td>✔️</td><td>可压缩类型较少，压缩质感很好，有数量限制，有体积限制</td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Ftinypng.com" target="_blank" rel="nofollow noopener noreferrer" title="https://tinypng.com" ref="nofollow noopener noreferrer">TinyPng</a></td><td>✖️</td><td>✔️</td><td>✔️</td><td>可压缩类型较少，压缩质感很好，有数量限制，有体积限制</td></tr><tr><td><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhitu.isux.us" target="_blank" rel="nofollow noopener noreferrer" title="https://zhitu.isux.us" ref="nofollow noopener noreferrer">Zhitu</a></td><td>✖️</td><td>✖️</td><td>✖️</td><td>可压缩类型一般，压缩质感一般，有数量限制，有体积限制</td></tr></tbody></table><p>若不想在网站里来回拖动图像文件，可使用笔者开源的图像批处理工具 <a href="https://link.juejin.cn/?target=https://github.com/JowayYoung/img-master" title="https://github.com/JowayYoung/img-master">img-master</a> 代替，不仅有压缩功能，还有分组功能、标记功能和变换功能。目前笔者负责的全部项目都使用该工具处理，一直用一直爽！</p><p><code>图像策略</code>也许处理一张图像就能完爆所有<code>构建策略</code>，因此是一种很廉价但极有效的<code>性能优化策略</code>。</p><h5 id="分发策略"><a href="#分发策略" class="headerlink" title="分发策略"></a>分发策略</h5><p>该策略主要围绕<code>内容分发网络</code>做相关处理，同时也是接入成本较高的<code>性能优化策略</code>，需足够资金支持。</p><p>虽然接入成本较高，但大部分企业都会购买一些<code>CDN服务器</code>，所以在部署的事情上就不用过分担忧，尽管使用就好。该策略尽量遵循以下两点就能发挥<code>CDN</code>最大作用。</p><ul><li><strong>所有静态资源走 CDN</strong>：开发阶段确定哪些文件属于静态资源</li><li><strong>把静态资源与主页面置于不同域名下</strong>：避免请求带上<code>Cookie</code></li></ul><p><strong>内容分发网络</strong>简称 <strong>CDN</strong>，指一组分布在各地存储数据副本并可根据就近原则满足数据请求的服务器。其核心特征是<code>缓存</code>和<code>回源</code>，缓存是把资源复制到<code>CDN服务器</code>里，回源是<code>资源过期/不存在</code>就向上层服务器请求并复制到<code>CDN服务器</code>里。</p><p>使用<code>CDN</code>可降低网络拥塞，提高用户访问响应速度和命中率。构建在现有网络基础上的智能虚拟网络，依靠部署在各地服务器，通过中心平台的调度、负载均衡、内容分发等功能模块，使用户就近获取所需资源，这就是<code>CDN</code>的终极使命。</p><p>基于<code>CDN</code>的<strong>就近原则</strong>所带来的优点，可将网站所有静态资源全部部署到<code>CDN服务器</code>里。那静态资源包括哪些文件？通常来说就是无需服务器产生计算就能得到的资源，例如不常变化的<code>样式文件</code>、<code>脚本文件</code>和<code>多媒体文件(字体/图像/音频/视频)</code>等。</p><p>若需单独配置<code>CDN服务器</code>，可考虑<a href="https://link.juejin.cn/?target=https://www.aliyun.com/product/oss" title="https://www.aliyun.com/product/oss">阿里云 OSS</a>、<a href="https://link.juejin.cn/?target=https://www.163yun.com/product/nos" title="https://www.163yun.com/product/nos">网易树帆 NOS</a> 和<a href="https://link.juejin.cn/?target=https://www.qiniu.com/products/kodo" title="https://www.qiniu.com/products/kodo">七牛云 Kodo</a>，当然配置起来还需购买该产品对应的<code>CDN服务</code>。由于篇幅问题，这些配置在购买后会有相关教程，可自行体会，在此就不再叙述了。</p><p>笔者推荐大家首选<a href="https://link.juejin.cn/?target=https://www.163yun.com/product/nos" title="https://www.163yun.com/product/nos">网易树帆 NOS</a>，毕竟对自家产品还是挺有信心的，不小心给自家产品打了个小广告了，哈哈！</p><h5 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h5><p>该策略主要围绕<code>浏览器缓存</code>做相关处理，同时也使接入成本最低的<code>性能优化策略</code>。其显著减少网络传输所带来的损耗，提升网页访问速度，是一种很值得使用的<code>性能优化策略</code>。</p><p>通过下图可知，为了让<code>浏览器缓存</code>发挥最大作用，该策略尽量遵循以下五点就能发挥<code>浏览器缓存</code>最大作用。</p><ul><li><strong>考虑拒绝一切缓存策略</strong>：<code>Cache-Control:no-store</code></li><li><strong>考虑资源是否每次向服务器请求</strong>：<code>Cache-Control:no-cache</code></li><li><strong>考虑资源是否被代理服务器缓存</strong>：<code>Cache-Control:public/private</code></li><li><strong>考虑资源过期时间</strong>：<code>Expires:t/Cache-Control:max-age=t,s-maxage=t</code></li><li><strong>考虑协商缓存</strong>：<code>Last-Modified/Etag</code></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f245496e62f4d1f96f48363512267cc~tplv-k3u1fbpfcp-watermark.image"></p><p>同时<code>浏览器缓存</code>也是高频面试题之一，笔者觉得上述涉及到的名词在不同语序串联下也能完全理解才能真正弄懂<code>浏览器缓存</code>在<code>性能优化</code>里起到的作用。</p><p><code>缓存策略</code>通过设置<code>HTTP</code>报文实现，在形式上分为<strong>强缓存 &#x2F; 强制缓存</strong>和<strong>协商缓存 &#x2F; 对比缓存</strong>。为了方便对比，笔者将某些细节使用图例展示，相信你有更好的理解。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2572dfb1ee4923a0d3e183c63380b2~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc66368a78e947058b8d816f92b00607~tplv-k3u1fbpfcp-watermark.image"></p><p>整个<code>缓存策略</code>机制很明了，<code>先走强缓存，若命中失败才走协商缓存</code>。若命中<code>强缓存</code>，直接使用<code>强缓存</code>；若未命中<code>强缓存</code>，发送请求到服务器检查是否命中<code>协商缓存</code>；若命中<code>协商缓存</code>，服务器返回 304 通知浏览器使用<code>本地缓存</code>，否则返回<code>最新资源</code>。</p><p>有两种较常用的应用场景值得使用<code>缓存策略</code>一试，当然更多应用场景都可根据项目需求制定。</p><ul><li><strong>频繁变动资源</strong>：设置<code>Cache-Control:no-cache</code>，使浏览器每次都发送请求到服务器，配合<code>Last-Modified/ETag</code>验证资源是否有效</li><li><strong>不常变化资源</strong>：设置<code>Cache-Control:max-age=31536000</code>，对文件名哈希处理，当代码修改后生成新的文件名，当 HTML 文件引入文件名发生改变才会下载最新文件</li></ul><h4 id="渲染层面"><a href="#渲染层面" class="headerlink" title="渲染层面"></a>渲染层面</h4><p><strong>渲染层面</strong>的性能优化，无疑是如何让代码<code>解析更好执行更快</code>。因此笔者从以下五方面做出建议。</p><ul><li><strong>CSS 策略</strong>：基于 CSS 规则</li><li><strong>DOM 策略</strong>：基于 DOM 操作</li><li><strong>阻塞策略</strong>：基于脚本加载</li><li><strong>回流重绘策略</strong>：基于回流重绘</li><li><strong>异步更新策略</strong>：基于异步更新</li></ul><p>上述五方面都是编写代码时完成，充满在整个项目流程的开发阶段里。因此在开发阶段需时刻注意以下涉及到的每一点，养成良好的开发习惯，<code>性能优化</code>也自然而然被使用上了。</p><p><code>渲染层面</code>的<code>性能优化</code>更多表现在编码细节上，而并非实体代码。简单来说就是遵循某些编码规则，才能将<code>渲染层面</code>的<code>性能优化</code>发挥到最大作用。</p><p><strong>回流重绘策略</strong>在<code>渲染层面</code>的<code>性能优化</code>里占比较重，也是最常规的<code>性能优化</code>之一。上年笔者发布的掘金小册<a href="https://juejin.cn/book/6850413616484040711" title="https://juejin.cn/book/6850413616484040711">《玩转 CSS 的艺术之美》</a>使用一整章讲解<code>回流重绘</code>，本章已开通试读，更多细节请戳<a href="https://juejin.cn/book/6850413616484040711/section/6850413616559194119" title="https://juejin.cn/book/6850413616484040711/section/6850413616559194119">这里</a>。</p><h5 id="CSS-策略"><a href="#CSS-策略" class="headerlink" title="CSS 策略"></a>CSS 策略</h5><ul><li>避免出现超过三层的<code>嵌套规则</code></li><li>避免为<code>ID选择器</code>添加多余选择器</li><li>避免使用<code>标签选择器</code>代替<code>类选择器</code></li><li>避免使用<code>通配选择器</code>，只对目标节点声明规则</li><li>避免重复匹配重复定义，关注<code>可继承属性</code></li></ul><h5 id="DOM-策略"><a href="#DOM-策略" class="headerlink" title="DOM 策略"></a>DOM 策略</h5><ul><li>缓存<code>DOM计算属性</code></li><li>避免过多<code>DOM操作</code></li><li>使用<code>DOMFragment</code>缓存批量化<code>DOM操作</code></li></ul><h5 id="阻塞策略"><a href="#阻塞策略" class="headerlink" title="阻塞策略"></a>阻塞策略</h5><ul><li>脚本与<code>DOM/其它脚本</code>的依赖关系很强：对<code>&lt;script&gt;</code>设置<code>defer</code></li><li>脚本与<code>DOM/其它脚本</code>的依赖关系不强：对<code>&lt;script&gt;</code>设置<code>async</code></li></ul><h5 id="回流重绘策略"><a href="#回流重绘策略" class="headerlink" title="回流重绘策略"></a>回流重绘策略</h5><ul><li>缓存<code>DOM计算属性</code></li><li>使用类合并样式，避免逐条改变样式</li><li>使用<code>display</code>控制<code>DOM显隐</code>，将<code>DOM离线化</code></li></ul><h5 id="异步更新策略"><a href="#异步更新策略" class="headerlink" title="异步更新策略"></a>异步更新策略</h5><ul><li>在<code>异步任务</code>中修改<code>DOM</code>时把其包装成<code>微任务</code></li></ul><h3 id="六大指标"><a href="#六大指标" class="headerlink" title="六大指标"></a>六大指标</h3><p>笔者根据<code>性能优化</code>的重要性和实际性划分出<code>九大策略</code>和<code>六大指标</code>，其实它们都是一条条活生生的<code>性能优化建议</code>。有些<code>性能优化建议</code>接不接入影响都不大，因此笔者将<code>九大策略</code>定位高于<code>六大指标</code>。针对<code>九大策略</code>还是建议在开发阶段和生产阶段接入，在项目复盘时可将<code>六大指标</code>的条条框框根据实际应用场景接入。</p><p><code>六大指标</code>基本囊括大部分<code>性能优化</code>细节，可作为<code>九大策略</code>的补充。笔者根据每条<code>性能优化建议</code>的特征将<code>指标</code>划分为以下六方面。</p><ul><li><strong>加载优化</strong>：资源在加载时可做的性能优化</li><li><strong>执行优化</strong>：资源在执行时可做的性能优化</li><li><strong>渲染优化</strong>：资源在渲染时可做的性能优化</li><li><strong>样式优化</strong>：样式在编码时可做的性能优化</li><li><strong>脚本优化</strong>：脚本在编码时可做的性能优化</li><li><strong>V8 引擎优化</strong>：针对<code>V8引擎</code>特征可做的性能优化</li></ul><h5 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a890d76ed4a748b1b745e85dde126989~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="执行优化"><a href="#执行优化" class="headerlink" title="执行优化"></a>执行优化</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5898aa8a121b40e896c457d9e95ac6f6~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57664767785349ca8d00c712de02989d~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="样式优化"><a href="#样式优化" class="headerlink" title="样式优化"></a>样式优化</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589007e1d9c144629803dc242b69861e~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="脚本优化"><a href="#脚本优化" class="headerlink" title="脚本优化"></a>脚本优化</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a2c1427695424e8a274ee747950bee~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="V8-引擎优化"><a href="#V8-引擎优化" class="headerlink" title="V8 引擎优化"></a>V8 引擎优化</h5><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae8786a5bac5483f9589b0494604705b~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>性能优化</strong>作为老生常谈的知识，必然会在工作或面试时遇上。很多时候不是想到某条<code>性能优化建议</code>就去做或答，而是要对这方面有一个整体认知，知道为何这样设计，这样设计的目的能达到什么效果。</p><p><code>性能优化</code>不是通过一篇文章就能全部讲完，若详细去讲可能要写两本书的篇幅才能讲完。本文能到给大家的就是一个方向一种态度，学以致用呗，希望阅读完本文会对你有所帮助。</p><p>最后，笔者将本文所有内容整理成一张高清脑图，由于体积太大无法上传，可关注笔者个人公众号 <strong>IQ 前端</strong>并回复<code>性能优化</code>获取口袋知识图谱吧！</p><blockquote><p>往期超过 5 万阅读量的掘金爆文</p></blockquote><ul><li><a href="https://juejin.cn/post/6844903926110617613" title="https://juejin.cn/post/6844903926110617613">灵活运用 CSS 开发技巧</a>：<code>4500+</code>点赞量，<code>13.8w</code>阅读量</li><li><a href="https://juejin.cn/post/6844903838449664013" title="https://juejin.cn/post/6844903838449664013">灵活运用 JS 开发技巧</a>：<code>1700+</code>点赞量，<code>5.4w</code>阅读量</li><li><a href="https://juejin.cn/post/6844903959283367950" title="https://juejin.cn/post/6844903959283367950">1.5 万字概括 ES6 全部特性</a>：<code>4500+</code>点赞量，<code>16.5w</code>阅读量</li><li><a href="https://juejin.cn/post/6921886428158754829" title="https://juejin.cn/post/6921886428158754829">中高级前端必须注意的 40 条移动端 H5 坑位指南 | 网易三年实践</a>：<code>3800+</code>点赞量，<code>5.7w</code>阅读量</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>原文地址 <a href="https://juejin.cn/post/6981673766178783262">juejin.cn</a></p>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让函数只被执行一次</title>
    <link href="/2021/07/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%87%BD%E6%95%B0%E5%8F%AA%E8%A2%AB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1/"/>
    <url>/2021/07/07/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%87%BD%E6%95%B0%E5%8F%AA%E8%A2%AB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实现函数只执行一次的核心思想非常的简单：「通过记录是否被执行的状态，来决定函数是否需要被调用」。接下来讨论一些常用的实现方式。</p></blockquote><span id="more"></span><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>实现函数只执行一次的核心思想非常的简单：<strong>「通过记录是否被执行的状态，来决定函数是否需要被调用」</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoke start function&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 记录状态</span><br><span class="hljs-keyword">let</span> invoked = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (!invoked) &#123;<br>    invoked = ture;<br>    <span class="hljs-title function_">start</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是直接使用上述实现方式会存在一个巨大的缺点：<strong>「产生大量的模板代码」</strong>。</p><p>接下来，一起探寻如何将其一步一步地优化处理。</p><h3 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h3><p>利用闭包<strong>「延长变量生命周期」</strong>的特性将状态与目标函数绑定在一起：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">once</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">_once</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (called) &#123;<br>            <span class="hljs-keyword">return</span> _once.<span class="hljs-property">value</span>;<br>        &#125;<br>        called = <span class="hljs-literal">true</span>;<br>        _once.<span class="hljs-property">value</span> = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码利用闭包中声明的 called 变量保存当前函数是否执行的状态，并且记录函数第一次执行的返回值，供后续使用。</p><p>使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; index++;<br><span class="hljs-keyword">const</span> onceIncrement = <span class="hljs-title function_">once</span>(increment);<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="三、元编程"><a href="#三、元编程" class="headerlink" title="三、元编程"></a>三、元编程</h3><p>利用 ES6 的元编程 Reflect API 将其定义为函数的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;once&#x27;</span>, &#123;<br>    <span class="hljs-title function_">value</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">once</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>然后就可以这样使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; index++;<br><span class="hljs-keyword">const</span> onceIncrement = increment.<span class="hljs-title function_">once</span>();<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-title function_">onceIncrement</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="四、自身属性丢失"><a href="#四、自身属性丢失" class="headerlink" title="四、自身属性丢失"></a>四、自身属性丢失</h3><p>虽然把函数只执行一次的功能封装成了通用的工具函数，但是还存在一些问题。<strong>「由于闭包是返回一个新的函数，所以会导致原函数本身携带的一些属性会丢失」</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; index++;<br>increment.<span class="hljs-property">_flag_</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">const</span> onceIncrement = increment.<span class="hljs-title function_">once</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(onceIncrement.<span class="hljs-property">_flag_</span>); <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure><p>那么就需要在返回 _once 函数时，将原函数的属性复制过来。</p><p>而 JavaScript 获取一个对象的属性集合时，有如下几种方法：</p><ul><li>Object.keys：获取自身可枚举的属性集合</li><li>Object.getOwnPropertyNames：获取自身包含不可枚举的属性集合，但是不包含 Symbol 属性</li><li>Object.getOwnPropertySymbols：获取自身所有的 Symbol 属性</li><li>Reflect.ownKeys：获取自身所有的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">once</span> = fn =&gt; &#123;<br>    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> _once = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (called) &#123;<br>            <span class="hljs-keyword">return</span> _once.<span class="hljs-property">value</span>;<br>        &#125;<br>        called = <span class="hljs-literal">true</span>;<br>        _once.<span class="hljs-property">value</span> = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(fn)) &#123;<br>        <span class="hljs-title function_">copyProperty</span>(to, <span class="hljs-keyword">from</span>, property);<br>    &#125;<br>    <span class="hljs-keyword">return</span> _once;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>拿到对象自身所有的属性集合时，不能简单地通过等号去赋值，这里主要考虑到：</p><ul><li>函数本身一些特有的属性，不应该被覆盖</li><li>保持原有属性的属性描述符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copyProperty</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, property</span>) &#123;  <span class="hljs-comment">// 一些特殊的属性不应复制 </span><br>    <span class="hljs-keyword">if</span> (property === <span class="hljs-string">&#x27;length&#x27;</span> || property === <span class="hljs-string">&#x27;prototype&#x27;</span> || property === <span class="hljs-string">&#x27;arguments&#x27;</span> || property === <span class="hljs-string">&#x27;caller&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> toDescriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(to, property);<br>    <span class="hljs-keyword">const</span> fromDescriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-keyword">from</span>, property);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">canCopyProperty</span>(toDescriptor, fromDescriptor)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(to, property, fromDescriptor);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">canCopyProperty</span>(<span class="hljs-params">toDescriptor, fromDescriptor</span>) &#123;<br>    <span class="hljs-keyword">if</span> (toDescriptor === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (toDescriptor.<span class="hljs-property">configurable</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (toDescriptor.<span class="hljs-property">writable</span> === fromDescriptor.<span class="hljs-property">writable</span> &amp;&amp; toDescriptor.<span class="hljs-property">enumerable</span> === fromDescriptor.<span class="hljs-property">enumerable</span> &amp;&amp; toDescriptor.<span class="hljs-property">configurable</span> === fromDescriptor.<span class="hljs-property">configurable</span> &amp;&amp; (toDescriptor.<span class="hljs-property">writable</span> || toDescriptor.<span class="hljs-property">value</span> === fromDescriptor.<span class="hljs-property">value</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="五、原型链上的属性"><a href="#五、原型链上的属性" class="headerlink" title="五、原型链上的属性"></a>五、原型链上的属性</h3><p>当对象上不存在某个属性时，JavaScript 的查找机制会顺着其原型链一步一步向上找，所以还需要考虑原型链的正确设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">changePrototype</span> = (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> fromPrototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-keyword">from</span>);<br>    <span class="hljs-keyword">if</span> (fromPrototype === <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(to)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(to, fromPrototype);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="六、写在最后"><a href="#六、写在最后" class="headerlink" title="六、写在最后"></a>六、写在最后</h3><p>以上就是本文的全部内容，希望能够给你带来帮助，欢迎<strong>「关注」</strong>、<strong>「点赞」</strong>、<strong>「转发」</strong>。</p><p>参考资料：</p><ul><li><a href="https://github.com/isaacs/once">https://github.com/isaacs/once</a></li><li><a href="https://github.com/sindresorhus/onetime">https://github.com/sindresorhus/onetime</a></li></ul><blockquote><p>原文地址 <a href="https://juejin.cn/post/6981664519244218382">juejin.cn</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css的GPU动画优化</title>
    <link href="/2021/06/23/css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96-0/"/>
    <url>/2021/06/23/css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96-0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么场景下使用Render函数，如何配置JSX</title>
    <link href="/2021/06/08/%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8Render%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEJSX/"/>
    <url>/2021/06/08/%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8Render%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEJSX/</url>
    
    <content type="html"><![CDATA[<h2 id="Render-函数"><a href="#Render-函数" class="headerlink" title="Render 函数"></a>Render 函数</h2><p><code>render</code>函数是组件渲染的重要核心，它跟<code>template</code>模板开发一样，只不过这种形式开发，它 (<code>render</code>) 更接近底层，这样能让<code>Vue</code>编译时少转换一次。</p><p>让我们来看一下哪里能用到<code>render</code>函数。<br> <span id="more"></span><br>我们都知道<code>Vue</code>项目入口文件<code>main.js</code>里面有个<code>render</code>函数长下面这样，将项目的<code>App</code>根组件，挂载到根实例上通过<code>render</code>渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br>复制代码<br></code></pre></td></tr></table></figure><p>我们来解刨一下<code>render</code>函数身体。</p><ul><li><p>render 函数返回值是一个<code>VNode</code> -&gt; “virtual node” 虚拟节点</p></li><li><p>render 函数的参数是一个<code>createElement</code>函数</p><ul><li><code>createElement</code>返回值也是一个<code>VNode</code>节点</li><li><code>createElement</code>函数的参数有三个<ul><li>第一个 标签名称</li><li>第二个 属性值</li><li>第三个 标签子级元素</li></ul></li></ul></li></ul><p><strong>代码演示：</strong></p><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;蛙人&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br>            <span class="hljs-string">&quot;div&quot;</span>, <br>            &#123; <span class="hljs-attr">attrs</span>: &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;蛙人&quot;</span>&#125; &#125;, <br>            [<br>                <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;蛙人&quot;</span>)<br>            ]<br>        )<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.js&quot;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;test&quot;</span>, config)<br>复制代码<br></code></pre></td></tr></table></figure><p>上面会调用标签会创建出一个<code>div</code>带有<code>span</code>子级的内容，注意<code>createElement</code>第二个参数属性这里，这里不能乱写，必须遵守官网风格<a href="https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">点击这里</a>。</p><p>当然这里肯定有人会问，这样写有什么用，跟<code>template</code>写不一样嘛，<code>render</code>函数这样写还麻烦可读性不强。</p><p>分情况，有时候用<code>render</code>更加灵活，咱就拿官网最典型的案例来<strong>举个例子</strong>。</p><p>封装一个组件，进行传入数字参数，就显示数字参数的标签，你肯定会先想到这样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h6</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;num == 6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>上面这样实现是没问题的，但是代码会冗余，一堆判断。我们再来看一下<code>render函数</code>的实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>,</span><br><span class="language-javascript">    )</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">num</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>上面两种都实现了同样的功能，是不是<code>render函数</code>这种方式看起来要简洁的多。所以一般用<code>render函数</code>封装东西是比较灵活的，尤其是配置和模板分离。深入理解配置<a href="https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1">这里</a>。</p><h2 id="什么是-JSX"><a href="#什么是-JSX" class="headerlink" title="什么是 JSX"></a>什么是 JSX</h2><p><code>JSX</code>是<code>JavScript</code>和<code>XML</code>结合一种的格式，是<code>JavaScript</code>的扩展语法。说白了就是可以在<code>JavaScript</code>代码中使用<code>JSX</code>。<code>JavaScript</code>在解析<code>JSX</code>时会先创建虚拟<code>DOM</code>，<code>JSX</code>最后会被编译为<code>JavaScript</code>代码执行。</p><h2 id="为什么要用-JSX"><a href="#为什么要用-JSX" class="headerlink" title="为什么要用 JSX"></a>为什么要用 JSX</h2><p>有的人肯定觉得用<code>render</code>函数写如果嵌套子级太多层看着太别扭了，可读性太差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">createElement</span>) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br>            <span class="hljs-string">&quot;div&quot;</span>, <br>            &#123; <span class="hljs-attr">attrs</span>: &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;蛙人&quot;</span>&#125; &#125;, <br>            [<br>                <span class="hljs-title function_">createElement</span>(<br>                    <span class="hljs-string">&quot;span&quot;</span>, <br>                    <span class="hljs-literal">null</span>, <br>                    <span class="hljs-string">&quot;蛙人&quot;</span><br>                ),<br>                <span class="hljs-title function_">createElement</span>(<br>                    <span class="hljs-string">&quot;span&quot;</span>, <br>                    <span class="hljs-literal">null</span>, <br>                    <span class="hljs-title function_">createElement</span>(<br>                        <span class="hljs-string">&quot;b&quot;</span>, <br>                        <span class="hljs-literal">null</span>, <br>                        <span class="hljs-string">&quot;前端娱乐圈&quot;</span><br>                    )<br>                ),<br>                <span class="hljs-title function_">createElement</span>(<br>                    <span class="hljs-string">&quot;span&quot;</span>, <br>                    <span class="hljs-literal">null</span>, <br>                    <span class="hljs-title function_">createElement</span>(<br>                        <span class="hljs-string">&quot;b&quot;</span>, <br>                        <span class="hljs-literal">null</span>, <br>                        <span class="hljs-title function_">createElement</span>(<br>                            <span class="hljs-string">&quot;i&quot;</span>, <br>                            <span class="hljs-literal">null</span>, <br>                            <span class="hljs-string">&quot;关注前端娱乐圈&quot;</span><br>                        )<br>                    )<br>                )<br>            ]<br>        )<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>比如上面这种，嵌套多层，可读性太差，时间一长自己还得捋半天。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f6fac23ec51446dbc81d8450f2adbe2~tplv-k3u1fbpfcp-zoom-1.image"></p><p>所以为了解决这问题，<code>JSX</code>就登场了，<code>JSX</code>相当于就是<code>createElement</code>的语法糖，这种形式可以直接使用<code>template</code>模板那种格式在<code>render</code>函数里写。</p><p>我们用这种形式来还原一下上面的<code>createElement</code>写的，是不是这种很简洁易读。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>蛙人<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>前端娱乐圈<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>关注前端娱乐圈<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="JSX-和-Render-函数有什么不同"><a href="#JSX-和-Render-函数有什么不同" class="headerlink" title="JSX 和 Render 函数有什么不同"></a>JSX 和 Render 函数有什么不同</h2><p>除了写法不一样外，没什么不同，属性都是遵循 Vue 文档上的。</p><p>我们来使用 JSX 语法，看看怎么使用，这里玩过 React 的同学估计都会使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;前端娱乐圈&quot;</span>,<br><span class="hljs-attr">dataList</span>: &#123;<br><span class="hljs-attr">title</span>: <span class="hljs-string">&quot;前端娱乐圈&quot;</span>,<br><span class="hljs-attr">href</span>: <span class="hljs-string">&quot;www.baidu.com&quot;</span><br>&#125;<br>&#125;<br>&#125;,<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.xxx&#125;</span> &#123;<span class="hljs-attr">...</span>&#123;<span class="hljs-attr">attrs:</span> <span class="hljs-attr">this.dataList</span>&#125;&#125;&gt;</span>&#123; this.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>如果你的项目是<code>Webpack</code>搭建，babel@6 的情况</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @babel/core @vue/babel-preset-jsx babel-loader<br>复制代码<br></code></pre></td></tr></table></figure><p>根目录<code>.babelrc</code>文件</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br><span class="hljs-string">&quot;plugins&quot;</span>: [<span class="hljs-string">&quot;transform-vue-jsx&quot;</span>]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>webpack.config.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    test:</span> /\.js/,<br><span class="hljs-symbol">    use:</span> <span class="hljs-string">&quot;babel-loader&quot;</span><br><span class="hljs-punctuation">&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>如果你的项目是<code>Webpack</code>搭建，babel@7 的情况</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @babel/core @vue/babel-preset-jsx babel-loader @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props<br>复制代码<br></code></pre></td></tr></table></figure><p>根目录<code>.babelrc</code>文件</p><p><a href="https://github.com/vuejs/jsx">文档说明 babel7 兼容 JSX 问题</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-string">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;<span class="hljs-variable">@vue</span>/babel-preset-jsx&quot;</span>]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>webpack.config.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    test:</span> /\.js/,<br><span class="hljs-symbol">    use:</span> <span class="hljs-string">&quot;babel-loader&quot;</span><br><span class="hljs-punctuation">&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>如果你的项目是<code>Vue-cli</code></strong></p><p>最新版本的 cli 是会默认支持 JSX 语法的，如果你的版本较老请跟上面一样的配置。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @vue/babel-preset-jsx @vue/babel-helper-vue-jsx-merge-props<br>复制代码<br></code></pre></td></tr></table></figure><p>babel.config.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  presets: [<br>    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span><br>  ]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>–</p><hr><h2 id="原文地址-juejin-cn参考"><a href="#原文地址-juejin-cn参考" class="headerlink" title="原文地址 juejin.cn参考"></a>原文地址 <a href="https://juejin.cn/post/6977237451660066853?utm_source=gold_browser_extension">juejin.cn</a><br>参考</h2><p><a href="https://blog.csdn.net/sansan_7957/article/details/83014838">blog.csdn.net&#x2F;sansan_7957…</a></p><p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%9F%BA%E7%A1%80">cn.vuejs.org&#x2F;v2&#x2F;guide&#x2F;re…</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用css的GPU动画优化</title>
    <link href="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/"/>
    <url>/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>相信不少人在做移动端动画的时候遇到了卡顿的问题，这篇文章尝试从浏览器渲染的角度；一点一点告诉你动画优化的原理及其技巧，作为你工作中优化动画的参考。文末有优化技巧的总结。</p></blockquote><p>相信不少人在做移动端动画的时候遇到了卡顿的问题，这篇文章尝试从浏览器渲染的角度；一点一点告诉你动画优化的原理及其技巧，作为你工作中优化动画的参考。文末有优化技巧的总结。</p><h2 id="因为-GPU-合成没有官方规范，每个浏览器的问题和解决方式也不同；所以文章内容仅供参考。浏览器渲染"><a href="#因为-GPU-合成没有官方规范，每个浏览器的问题和解决方式也不同；所以文章内容仅供参考。浏览器渲染" class="headerlink" title="因为 GPU 合成没有官方规范，每个浏览器的问题和解决方式也不同；所以文章内容仅供参考。浏览器渲染"></a>因为 GPU 合成没有官方规范，每个浏览器的问题和解决方式也不同；所以文章内容仅供参考。<br><span id="more"></span><br>浏览器渲染</h2><p>提高动画的优化不得不提及浏览器是如何渲染一个页面。在从服务器中拿到数据后，浏览器会先做解析三类东西：</p><ul><li><p>解析 html,xhtml,svg 这三类文档，形成 dom 树。</p></li><li><p>解析 css，产生 css rule tree。</p></li><li><p>解析 js，js 会通过 api 来操作 dom tree 和 css rule tree。</p></li></ul><p>解析完成之后，浏览器引擎会通过 dom tree 和 css rule tree 来构建 rendering tree：</p><ul><li><p>rendering tree 和 dom tree 并不完全相同，例如：<head></head > 或 display:none 的东西就不会放在渲染树中。</p></li><li><p>css rule tree 主要是完成匹配，并把 css rule 附加给 rendering tree 的每个 element。</p></li></ul><p>在渲染树构建完成后，</p><ul><li><p>浏览器会对这些元素进行定位和布局，这一步也叫做 reflow 或者 layout。</p></li><li><p>浏览器绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 repaint。</p></li><li><p>然后浏览器会将各层的信息发送给 GPU，GPU 会将各层合成；显示在屏幕上。</p></li></ul><h2 id="渲染优化原理"><a href="#渲染优化原理" class="headerlink" title="渲染优化原理"></a>渲染优化原理</h2><p>如上所说，渲染树构建完成后；浏览器要做的步骤：</p><p>reflow——》repaint——》composite</p><h3 id="reflow-和-repaint"><a href="#reflow-和-repaint" class="headerlink" title="reflow 和 repaint"></a>reflow 和 repaint</h3><p>reflow 和 repaint 都是耗费浏览器性能的操作，这两者尤以 reflow 为甚；因为每次 reflow，浏览器都要重新计算每个元素的形状和位置。</p><p>由于 reflow 和 repaint 都是非常消耗性能的，我们的浏览器为此做了一些优化。浏览器会将 reflow 和 repaint 的操作积攒一批，然后做一次 reflow。但是有些时候，你的代码会强制浏览器做多次 reflow。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;content&#x27;</span>);<br>content.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-number">700</span><br>px;<br><span class="hljs-keyword">var</span> contentWidth = content.<span class="hljs-property">offsetWidth</span>;<br>content.<span class="hljs-property">style</span>.<span class="hljs-property">backgound</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br></code></pre></td></tr></table></figure><p>以上第三行代码，需要浏览器 reflow 后；再获取值，所以会导致浏览器多做一次 reflow。</p><p>下面是一些针对 reflow 和 repaint 的最佳实践：</p><ul><li><p>不要一条一条地修改 dom 的样式，尽量使用 className 一次修改。</p></li><li><p>将 dom 离线后修改</p><ul><li><p>使用 documentFragment 对象在内存里操作 dom。</p></li><li><p>先把 dom 节点 display:none;（会触发一次 reflow）。然后做大量的修改后，再把它显示出来。</p></li><li><p>clone 一个 dom 节点在内存里，修改之后；与在线的节点相替换。</p></li></ul></li><li><p>不要使用 table 布局，一个小改动会造成整个 table 的重新布局。</p></li><li><p>transform 和 opacity 只会引起合成，不会引起布局和重绘。</p></li></ul><p>从上述的最佳实践中你可能发现，动画优化一般都是<strong>尽可能地减少 reflow、repaint 的发生</strong>。关于哪些属性会引起 reflow、repaint 及<br>composite，你可以在这个网站找到 <a href="https://csstriggers.com/">https://csstriggers.com/</a>。</p><h3 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h3><p>在 reflow 和 repaint 之后，浏览器会将多个复合层传入 GPU；进行合成工作，那么合成是如何工作的呢？</p><p>假设我们的页面中有 A 和 B 两个元素，它们有 absolute 和 z-index 属性；浏览器会重绘它们，然后将图像发送给 GPU；然后 GPU 将会把多个图像合成展示在屏幕上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span>, <span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">top</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/pic1.png" alt="image"></p><p>我们将 A 元素使用 left 属性，做一个移动动画：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span>, <span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2</span>;</span><br><span class="language-css"> <span class="hljs-attribute">animation</span>: move <span class="hljs-number">1s</span> linear;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">left</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-keyword">@keyframes</span> move &#123;</span><br><span class="language-css"> <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>; &#125;</span><br><span class="language-css"> <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>; &#125;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，对于动画的每一帧；浏览器会计算元素的几何形状，渲染新状态的图像；并把它们发送给 GPU。（你没看错，position 也会引起浏览器重排的）尽管浏览器做了优化，在 repaint 时，只会 repaint<br>部分区域；但是我们的动画仍然不够流畅。</p><p>因为重排和重绘发生在动画的每一帧，一个有效避免 reflow 和 repaint 的方式是我们仅仅画两个图像；一个是 a 元素，一个是 b 元素及整个页面；我们将这两张图片发送给<br>GPU，然后动画发生的时候；只做两张图片相对对方的平移。也就是说，仅仅合成缓存的图片将会很快；这也是 GPU 的优势——它能非常快地以亚像素精度地合成图片，并给动画带来平滑的曲线。</p><p>为了仅发生 composite，我们做动画的 css property 必须满足以下三个条件：</p><ul><li><p>不影响文档流。</p></li><li><p>不依赖文档流。</p></li><li><p>不会造成重绘。</p></li></ul><p>满足以上以上条件的 css property 只有 transform 和 opacity。你可能以为 position 也满足以上条件，但事实不是这样，举个例子 left 属性可以使用百分比的值，依赖于它的 offset<br>parent。还有 em、vh 等其他单位也依赖于他们的环境。</p><p>我们使用 translate 来代替 left</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span>, <span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#a</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2</span>;</span><br><span class="language-css"> <span class="hljs-attribute">animation</span>: move <span class="hljs-number">1s</span> linear;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#b</span> &#123;</span><br><span class="language-css"> <span class="hljs-attribute">left</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css"> <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><br><span class="language-css"><span class="hljs-keyword">@keyframes</span> move &#123;</span><br><span class="language-css"> <span class="hljs-selector-tag">from</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>); &#125;</span><br><span class="language-css"> <span class="hljs-selector-tag">to</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">70px</span>); &#125;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#a&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;#b&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器在动画执行之前就知道动画如何开始和结束，因为浏览器没有看到需要 reflow 和 repaint 的操作；浏览器就会画两张图像作为复合层，并将它们传入 GPU。</p><p>这样做有两个优势：</p><ul><li><p>动画将会非常流畅</p></li><li><p>动画不在绑定到 CPU，即使 js 执行大量的工作；动画依然流畅。</p></li></ul><p>看起来性能问题好像已经解决了？在下文你会看到 GPU 动画的一些问题。</p><h3 id="GPU-是如何合成图像的"><a href="#GPU-是如何合成图像的" class="headerlink" title="GPU 是如何合成图像的"></a>GPU 是如何合成图像的</h3><p>GPU 实际上可以看作一个独立的计算机，它有自己的处理器和存储器及数据处理模型。当浏览器向 GPU 发送消息的时候，就像向一个外部设备发送消息。</p><p>你可以把浏览器向 GPU 发送数据的过程，与使用 ajax 向服务器发送消息非常类似。想一下，你用 ajax 向服务器发送数据，服务器是不会直接接受浏览器的存储的信息的。你需要收集页面上的数据，把它们放进一个载体里面（例如<br>JSON），然后发送数据到远程服务器。</p><p>同样的，浏览器向 GPU 发送数据也需要先创建一个载体；只不过 GPU 距离 CPU 很近，不会像远程服务器那样可能几千里那么远。但是对于远程服务器，2 秒的延迟是可以接受的；但是对于 GPU，几毫秒的延迟都会造成动画的卡顿。</p><p>浏览器向 GPU 发送的数据载体是什么样？这里给出一个简单的制作载体，并把它们发送到 GPU 的过程。</p><ul><li><p>画每个复合层的图像</p></li><li><p>准备图层的数据</p></li><li><p>准备动画的着色器（如果需要）</p></li><li><p>向 GPU 发送数据</p></li></ul><p>所以你可以看到，每次当你添加<code>transform:translateZ(0)</code>或<code>will-change：transform</code><br>给一个元素，你都会做同样的工作。重绘是非常消耗性能的，在这里它尤其缓慢。在大多数情况，浏览器不能增量重绘。它不得不重绘先前被复合层覆盖的区域。</p><h3 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h3><p>还记得刚才 a 元素和 b 元素动画的例子吗？现在我们将 b 元素做动画，a 元素静止不动。</p><p><img src="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/pic2.png" alt="image"></p><p>和刚才的例子不同，现在 b 元素将拥有一个独立复合层；然后它们将被 GPU 合成。但是因为 a 元素要在 b 元素的上面（因为 a 元素的 z-index 比 b 元素高），那么浏览器会做什么？浏览器会将 a 元素也单独做一个复合层！</p><p>所以我们现在有三个复合层 a 元素所在的复合层、b 元素所在的复合层、其他内容及背景层。</p><p>一个或多个没有自己复合层的元素要出现在有复合层元素的上方，它就会拥有自己的复合层；这种情况被称为隐式合成。</p><p>浏览器将 a 元素提升为一个复合层有很多种原因，下面列举了一些：</p><ul><li><p>3d 或透视变换 css 属性，例如 translate3d,translateZ 等等（js 一般通过这种方式，使元素获得复合层）</p></li><li><p>video、iframe、canvas、webgl  等元素。</p></li><li><p>混合插件（如 flash）。</p></li><li><p>元素自身的 opacity 和 transform 做 CSS 动画。</p></li><li><p>拥有 css 过滤器的元素。</p></li><li><p>使用 will-change 属性。</p></li><li><p>position:fixed。</p></li><li><p>元素有一个 z-index 较低且包含一个复合层的兄弟元素 (换句话说就是该元素在复合层上面渲染)</p></li></ul><p>这看起来 css 动画的性能瓶颈是在重绘上，但是真实的问题是在内存上：</p><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><p>使用 GPU 动画需要发送多张渲染层的图像给 GPU，GPU 也需要缓存它们以便于后续动画的使用。</p><p>一个渲染层，需要多少内存占用？为了便于理解，举一个简单的例子；一个宽、高都是 300px 的纯色图像需要多少内存？</p><p>300 <em>300</em> 4 &#x3D; 360000 字节，即 360kb。这里乘以 4 是因为，每个像素需要四个字节计算机内存来描述。</p><p>假设我们做一个轮播图组件，轮播图有 10 张图片；为了实现图片间平滑过渡的交互；为每个图像添加了 will-change:transform。这将提升图像为复合层，它将多需要 19mb 的空间。800 <em>600</em> 4 * 10 &#x3D;<br>1920000。</p><p>仅仅是一个轮播图组件就需要 19m 的额外空间！</p><p>在 chrome 的开发者工具中打开 setting——》Experiments——》layers 可以看到每个层的内存占用。如图所示：</p><p><img src="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/pic3.png" alt="image"></p><p><img src="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/pic4.png" alt="image"></p><h3 id="GPU-动画的优点和缺点"><a href="#GPU-动画的优点和缺点" class="headerlink" title="GPU 动画的优点和缺点"></a>GPU 动画的优点和缺点</h3><p>现在我们可以总结一下 GPU 动画的优点和缺点：</p><ul><li><p>每秒 60 帧，动画平滑、流畅。</p></li><li><p>一个合适的动画工作在一个单独的线程，它不会被大量的 js 计算阻塞。</p></li><li><p>3D“变换” 是便宜的。</p></li></ul><p>缺点：</p><ul><li><p>提升一个元素到复合层需要额外的重绘，有时这是慢的。（即我们得到的是一个全层重绘，而不是一个增量）</p></li><li><p>绘图层必须传输到 GPU。取决于层的数量和传输可能会非常缓慢。这可能让一个元素在中低档设备上闪烁。</p></li><li><p>每个复合层都需要消耗额外的内存，过多的内存可能导致浏览器的崩溃。</p></li><li><p>如果你不考虑隐式合成，而使用重绘；会导致额外的内存占用，并且浏览器崩溃的概率是非常高的。</p></li><li><p>我们会有视觉假象，例如在 Safari 中的文本渲染，在某些情况下页面内容将消失或变形。</p></li></ul><h2 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h2><h3 id="避免隐式合成"><a href="#避免隐式合成" class="headerlink" title="避免隐式合成"></a>避免隐式合成</h3><ul><li><p>保持动画的对象的 z-index 尽可能的高。理想的，这些元素应该是 body 元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在 body 元素下仅仅是为了做动画。</p></li><li><p>将元素上设置 will-change CSS 属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。</p></li></ul><h3 id="动画中只使用-transform-和-opacity"><a href="#动画中只使用-transform-和-opacity" class="headerlink" title="动画中只使用 transform 和 opacity"></a>动画中只使用 transform 和 opacity</h3><p>如上所说，transform 和 opacity 保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成 repaint。<br>有些时候你可能想要改变其他的 css 属性，作为动画。例如：你可能想使用 background 属性改变背景：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bg-change&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>.bg-change &#123;<br>  width: 100px;<br>  height: 100px;<br>  background: red;<br>  transition: opacity 2s;<br>&#125;<br>.bg-change:hover &#123;<br>  background: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换 opacity 属性：</p><div class="bg-change"></div> <style> .bg-change { width: 100px; height: 100px; background: red; } .bg-change::before { content: ''; display: block; width: 100%; height: 100%; background: blue; opacity: 0; transition: opacity 20s; } .bg-change:hover::before { opacity: 1; } </style><h3 id="减小复合层的尺寸"><a href="#减小复合层的尺寸" class="headerlink" title="减小复合层的尺寸"></a>减小复合层的尺寸</h3><p>看一下两张图片，有什么不同吗？</p><p><img src="/2021/06/01/%E4%BD%BF%E7%94%A8css%E7%9A%84GPU%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/pic5.png" alt="image"></p><p>这两张图片视觉上是一样的，但是它们的尺寸一个是 39kb；另外一个是 400b。不同之处在于，第二个纯色层是通过 scale 放大 10 倍做到的。</p><div id="a"></div> <div id="b"></div> <style> #a, #b { will-change: transform; } #a { width: 100px; height: 100px; } #b { width: 10px; height: 10px; transform: scale(10); } </style><p>对于图片，你要怎么做呢？你可以将图片的尺寸减少 5%——10%，然后使用 scale 将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。</p><h3 id="用-css-动画而不是-js-动画"><a href="#用-css-动画而不是-js-动画" class="headerlink" title="用 css 动画而不是 js 动画"></a>用 css 动画而不是 js 动画</h3><p>css 动画有一个重要的特性，它是完全工作在 GPU 上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给 GPU。而如果使用 js<br>动画，浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给 GPU 至少 60 次每秒。除了计算和发送数据比 css 动画要慢，主线程的负载也会影响动画；<br>当主线程的计算任务过多时，会造成动画的延迟、卡顿。</p><p>所以尽可能地使用基于 css 的动画，不仅仅更快；也不会被大量的 js 计算所阻塞。</p><h2 id="优化技巧总结"><a href="#优化技巧总结" class="headerlink" title="优化技巧总结"></a>优化技巧总结</h2><ul><li><p>减少浏览器的重排和重绘的发生。</p></li><li><p>不要使用 table 布局。</p></li><li><p>css 动画中尽量只使用 transform 和 opacity，这不会发生重排和重绘。</p></li><li><p>尽可能地只使用 css 做动画。</p></li><li><p>避免浏览器的隐式合成。</p></li><li><p>改变复合层的尺寸。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>GPU 合成主要参考：</p><p><a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/">https://www.smashingmagazine....</a></p><p>哪些属性会引起 reflow、repaint 及 composite，你可以在这个网站找到：</p><p><a href="https://csstriggers.com/">https://csstriggers.com/</a>。</p><p>原文地址 <a href="https://segmentfault.com/a/1190000008015671">segmentfault.com</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从一道让我失眠的Promise面试题开始，深入分析Promise实现细节</title>
    <link href="/2021/03/31/%E4%BB%8E%E4%B8%80%E9%81%93%E8%AE%A9%E6%88%91%E5%A4%B1%E7%9C%A0%E7%9A%84Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Promise%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <url>/2021/03/31/%E4%BB%8E%E4%B8%80%E9%81%93%E8%AE%A9%E6%88%91%E5%A4%B1%E7%9C%A0%E7%9A%84Promise%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Promise%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 原文地址 <a href="https://juejin.cn/post/6945319439772434469?utm_source=gold_browser_extension">juejin.cn</a></p></blockquote><p><strong>先把罪魁祸首挂在这里给大家群殴</strong> 👇</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> Promise.resolve(<span class="hljs-number">4</span>);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;)<br><br>Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-comment">// 大家先思考一下</span><br><br>复制代码<br></code></pre></td></tr></table></figure><p>这道面试题是无意间在微信群里看到的，据说是某厂的面试题。一般关于 Promise 的面试题无非是考察宏微任务、EventLoop 之类的，当我认真去分析这道题的时候，越看越不对劲，感觉有诈！这是要考察啥？</p><p>不管了，先在浏览器输出一下看看 🤨</p><p>打印结果：<strong>0、1、2、3、4、5、6</strong> 😱</p><p>这里 4 怎么跑到 3 后面去了，不讲武德？ Why……</p><p>在我看来，这道题有两个 <code>Promise.resolve()</code>，相当于创建两个<strong>状态为 fulfilled 的 Promise</strong>。</p><p>紧随他们后面的第一个 then 方法会交替将其执行函数送入<strong>微任务队列排队执行</strong>，所以这里的 0 和 1，大家都可以理解，但是接下来执行的不是 <code>console.log(res)</code> 而是 <code>console.log(2)</code>。</p><p>如果说需要等待 <code>return Promise.resolve(4)</code> 执行完并将其结果和状态同步给外部的 Promise，那么这里只需要创建一个微任务去处理就应该可以了，也就是 4 会在 2 后面才对，为啥需要<strong>创建两个微任务</strong>呢？ 🤔</p><p>想了很久，也找很多朋友讨论这个问题，都没有得到有说服力的结论，真是百思不得其解！这样死抠细节，感觉有点浪费时间，毕竟这种面试题在生产中并不会出现，谁会去写这么奇葩的 Promise 代码， 放弃了，不去想了。</p><p>然而😂，当天晚上<del>夜黑风高</del>夜深人静的时候，脑海里面依然轮播这道面试题，真的很想知道 Promise 内部到底是个什么逻辑，越想越睡不着～越睡不着越想~</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ede6d693a30f4841a51d5a7281ffc149~tplv-k3u1fbpfcp-watermark.image"></p><p>无奈之下，决定参考 Promise A+ 规范手写一版 Promise，看看能不能从实现细节中找到蛛丝马迹。为了方便大家理解，下面我会利用不同 🌰 来介绍手写的细节和思路。<strong>文章最后会依据实现细节来探讨这道面试题，有手写经验的可以直接跳过手写 Promise 实现过程，看最后的结论。</strong></p><h2 id="手写前需要先了解这些"><a href="#手写前需要先了解这些" class="headerlink" title="手写前需要先了解这些"></a>手写前需要先了解这些</h2><p>如果感觉对 Promise 还不太熟悉的就先移步 <a href="https://es6.ruanyifeng.com/#docs/promise">Promise 入门</a>，稍微做一下知识预习，了解一下 Promise 的常规用法。</p><h3 id="什么是宏任务与微任务？"><a href="#什么是宏任务与微任务？" class="headerlink" title="什么是宏任务与微任务？"></a>什么是宏任务与微任务？</h3><p>我们都知道 Js 是单线程都，但是一些高耗时操作就带来了进程阻塞问题。为了解决这个问题，Js 有两种任务的执行模式：<strong>同步模式（Synchronous）和异步模式（Asynchronous）</strong>。</p><p>在异步模式下，创建<strong>异步任务主要分为宏任务与微任务两种</strong>。ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。</p><p><strong>宏任务与微任务的几种创建方式</strong> 👇</p><table><thead><tr><th>宏任务（Macrotask）</th><th>微任务（Microtask）</th></tr></thead><tbody><tr><td>setTimeout</td><td>requestAnimationFrame（有争议）</td></tr><tr><td>setInterval</td><td>MutationObserver（浏览器环境）</td></tr><tr><td>MessageChannel</td><td>Promise.[then/catch/finally]</td></tr><tr><td>I/O，事件队列</td><td>process.nextTick（Node 环境）</td></tr><tr><td>setImmediate（Node 环境）</td><td>queueMicrotask</td></tr><tr><td>script（整体代码块）</td><td></td></tr></tbody></table><p><strong>如何理解 script（整体代码块）是个宏任务呢</strong> 🤔</p><p>实际上如果同时存在两个 script 代码块，会首先在执行第一个 script 代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去清空微任务队列，再去开启第二个 script 代码块的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。</p><h3 id="什么是-EventLoop-？"><a href="#什么是-EventLoop-？" class="headerlink" title="什么是 EventLoop ？"></a>什么是 EventLoop ？</h3><p>先来看个图</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2baaf009636748c491898aafeceddb32~tplv-k3u1fbpfcp-watermark.image"></p><ol><li><p>判断宏任务队列是否为空</p><ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; 执行下一步</li><li>空 –&gt; 执行下一步</li></ul></li><li><p>判断微任务队列是否为空</p><ul><li>不空 –&gt; 执行最早进入队列的任务 –&gt; <strong>继续检查微任务队列空不空</strong></li><li>空 –&gt; 执行下一步</li></ul></li></ol><p>因为首次执行宏队列中会有 script（整体代码块）任务，所以实际上就是 Js 解析完成后，在异步任务中，会先执行完所有的微任务，这里也是很多面试题喜欢考察的。需要注意的是，新创建的微任务会立即进入微任务队列排队执行，不需要等待下一次轮回。</p><h3 id="什么是-Promise-A-规范？"><a href="#什么是-Promise-A-规范？" class="headerlink" title="什么是 Promise A+ 规范？"></a>什么是 Promise A+ 规范？</h3><p>看到 A+ 肯定会想到是不是还有 A，事实上确实有。其实 Promise 有多种规范，除了前面的 Promise A、promise A+ 还有 Promise&#x2F;B，Promise&#x2F;D。<strong>目前我们使用的 Promise 是基于 Promise A+ 规范实现的</strong>，感兴趣的移步 <a href="https://promisesaplus.com/">Promise A + 规范</a>了解一下，这里不赘述。</p><p>检验一份手写 Promise 靠不靠谱，通过 Promise A+ 规范自然是基本要求，这里我们可以借助 <a href="https://www.npmjs.com/package/promises-aplus-tests">promises-aplus-tests</a> 来检测我们的代码是否符合规范，后面我会讲到如何使用它。</p><h2 id="手写开始"><a href="#手写开始" class="headerlink" title="手写开始"></a>手写开始</h2><p>很多手写版本都是使用 setTimeout 去做异步处理，但是 setTimeout 属于宏任务，这与 Promise 是个微任务相矛盾，所以我打算选择一种创建微任务的方式去实现我们的手写代码。</p><p>这里我们有几种选择，一种就是 Promise A+ 规范中也提到的，process.nextTick（ Node 端 ） 与 MutationObserver（ 浏览器端 ），考虑到利用这两种方式需要做环境判断，所以在这里我们就推荐另外一种创建微任务的方式 <code>queueMicrotask</code>，了解更多 –&gt; <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">在 JavaScript 中通过 queueMicrotask() 使用微任务</a>;</p><h3 id="一、Promise-核心逻辑实现"><a href="#一、Promise-核心逻辑实现" class="headerlink" title="一、Promise 核心逻辑实现"></a>一、Promise 核心逻辑实现</h3><p>我们先简单实现一下 Promise 的基础功能。先看原生 Promise 实现的 🌰，第一步我们要完成相同的功能。</p><p>原生🌰 👇</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>   resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>   reject(<span class="hljs-string">&#x27;err&#x27;</span>)<br>&#125;)<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, reason =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;reject&#x27;</span>, reason)<br>&#125;)<br><br><span class="hljs-comment">// 输出 resolve success</span><br>复制代码<br></code></pre></td></tr></table></figure><p>我们来分析一下<strong>基本原理</strong>：</p><blockquote><ol><li>Promise 是一个类，在执行这个类的时候会传入一个执行器，这个执行器会立即执行</li><li>Promise 会有三种状态<ul><li>Pending 等待</li><li>Fulfilled 完成</li><li>Rejected 失败</li></ul></li><li>状态只能由 Pending –&gt; Fulfilled 或者 Pending –&gt; Rejected，且一但发生改变便不可二次修改；</li><li>Promise 中使用 resolve 和 reject 两个函数来更改状态；</li><li>then 方法内部做但事情就是状态判断<ul><li>如果状态是成功，调用成功回调函数</li><li>如果状态是失败，调用失败回调函数</li></ul></li></ol></blockquote><p><strong>下面开始实现</strong>：</p><h4 id="1-新建-MyPromise-类，传入执行器-executor"><a href="#1-新建-MyPromise-类，传入执行器-executor" class="headerlink" title="1. 新建 MyPromise 类，传入执行器 executor"></a>1. 新建 MyPromise 类，传入执行器 executor</h4><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">// 新建 MyPromise.js</span><br><br><span class="hljs-comment">// 新建 MyPromise 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>)&#123;<br>    <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>    <span class="hljs-title function_">executor</span>() <br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="2-executor-传入-resolve-和-reject-方法"><a href="#2-executor-传入-resolve-和-reject-方法" class="headerlink" title="2. executor 传入 resolve 和 reject 方法"></a>2. executor 传入 resolve 和 reject 方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 新建 MyPromise 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>)&#123;<br>    <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>    <span class="hljs-comment">// 并传入resolve和reject方法</span><br>    <span class="hljs-title function_">executor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>) <br>  &#125;<br>  <span class="hljs-comment">// resolve和reject为什么要用箭头函数？</span><br>  <span class="hljs-comment">// 如果直接调用的话，普通函数this指向的是window或者undefined</span><br>  <span class="hljs-comment">// 用箭头函数就可以让this指向当前实例对象</span><br>  <span class="hljs-comment">// 更改成功后的状态</span><br>  resolve = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-comment">// 更改失败后的状态</span><br>  reject = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="3-状态与结果的管理"><a href="#3-状态与结果的管理" class="headerlink" title="3. 状态与结果的管理"></a>3. 状态与结果的管理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 先定义三个常量表示状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-comment">// 新建 MyPromise 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(executor)&#123;<br>    <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>    <span class="hljs-comment">// 并传入resolve和reject方法</span><br>    executor(<span class="hljs-keyword">this</span>.resolve, <span class="hljs-keyword">this</span>.reject)<br>  &#125;<br><br>  <span class="hljs-comment">// 储存状态的变量，初始值是 pending</span><br>  status = PENDING;<br><br>  <span class="hljs-comment">// resolve和reject为什么要用箭头函数？</span><br>  <span class="hljs-comment">// 如果直接调用的话，普通函数this指向的是window或者undefined</span><br>  <span class="hljs-comment">// 用箭头函数就可以让this指向当前实例对象</span><br>  <span class="hljs-comment">// 成功之后的值</span><br>  value = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 失败之后的原因</span><br>  reason = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 更改成功后的状态</span><br>  resolve = (value) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态修改为成功</span><br>      <span class="hljs-keyword">this</span>.status = FULFILLED;<br>      <span class="hljs-comment">// 保存成功之后的值</span><br>      <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 更改失败后的状态</span><br>  reject = (reason) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态成功为失败</span><br>      <span class="hljs-keyword">this</span>.status = REJECTED;<br>      <span class="hljs-comment">// 保存失败后的原因</span><br>      <span class="hljs-keyword">this</span>.reason = reason;<br>    &#125;<br>  &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="4-then-的简单实现"><a href="#4-then-的简单实现" class="headerlink" title="4. then 的简单实现"></a>4. then 的简单实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br>then(onFulfilled, onRejected) &#123;<br>  <span class="hljs-comment">// 判断状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>    <span class="hljs-comment">// 调用成功回调，并且把值返回</span><br>    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>    <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>    onRejected(<span class="hljs-keyword">this</span>.reason);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="5-使用-module-exports-对外暴露-MyPromise-类"><a href="#5-使用-module-exports-对外暴露-MyPromise-类" class="headerlink" title="5. 使用 module.exports 对外暴露 MyPromise 类"></a>5. 使用 module.exports 对外暴露 MyPromise 类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MyPromise.js</span><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = MyPromise;<br>复制代码<br></code></pre></td></tr></table></figure><p>看一下我们目前实现的<strong>完整代码</strong>🥳</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 先定义三个常量表示状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-comment">// 新建 MyPromise 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(executor)&#123;<br>    <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>    <span class="hljs-comment">// 并传入resolve和reject方法</span><br>    executor(<span class="hljs-keyword">this</span>.resolve, <span class="hljs-keyword">this</span>.reject)<br>  &#125;<br><br>  <span class="hljs-comment">// 储存状态的变量，初始值是 pending</span><br>  status = PENDING;<br><br>  <span class="hljs-comment">// resolve和reject为什么要用箭头函数？</span><br>  <span class="hljs-comment">// 如果直接调用的话，普通函数this指向的是window或者undefined</span><br>  <span class="hljs-comment">// 用箭头函数就可以让this指向当前实例对象</span><br>  <span class="hljs-comment">// 成功之后的值</span><br>  value = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 失败之后的原因</span><br>  reason = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 更改成功后的状态</span><br>  resolve = (value) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态修改为成功</span><br>      <span class="hljs-keyword">this</span>.status = FULFILLED;<br>      <span class="hljs-comment">// 保存成功之后的值</span><br>      <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 更改失败后的状态</span><br>  reject = (reason) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态成功为失败</span><br>      <span class="hljs-keyword">this</span>.status = REJECTED;<br>      <span class="hljs-comment">// 保存失败后的原因</span><br>      <span class="hljs-keyword">this</span>.reason = reason;<br>    &#125;<br>  &#125;<br><br>  then(onFulfilled, onRejected) &#123;<br>    <span class="hljs-comment">// 判断状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>      <span class="hljs-comment">// 调用成功回调，并且把值返回</span><br>      onFulfilled(<span class="hljs-keyword">this</span>.value);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>      <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>      onRejected(<span class="hljs-keyword">this</span>.reason);<br>    &#125;<br>  &#125;<br>&#125;<br><br>module.exports = MyPromise<br>复制代码<br></code></pre></td></tr></table></figure><p>使用我的手写代码执行一下上面那个🌰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 新建 test.js</span><br><br><span class="hljs-comment">// 引入我们的 MyPromise.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>   <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>   <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err&#x27;</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject&#x27;</span>, reason)<br>&#125;)<br><br><span class="hljs-comment">// 执行结果：resolve success</span><br>复制代码<br></code></pre></td></tr></table></figure><p>执行结果符合我们的预期，第一步完成了👏👏👏</p><h3 id="二、在-Promise-类中加入异步逻辑"><a href="#二、在-Promise-类中加入异步逻辑" class="headerlink" title="二、在 Promise 类中加入异步逻辑"></a>二、在 Promise 类中加入异步逻辑</h3><p>上面还没有经过异步处理，如果有异步逻辑加如来会带来一些问题，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>); <br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject&#x27;</span>, reason)<br>&#125;)<br><br><span class="hljs-comment">// 没有打印信息！！！</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>分析原因</strong>：</p><blockquote><p>主线程代码立即执行，setTimeout 是异步代码，then 会马上执行，这个时候判断 Promise 状态，状态是 Pending，然而之前并没有判断等待这个状态</p></blockquote><p>这里就需要我们处理一下 Pending 状态，我们改造一下之前的代码 🤔</p><h4 id="1-缓存成功与失败回调"><a href="#1-缓存成功与失败回调" class="headerlink" title="1. 缓存成功与失败回调"></a>1. 缓存成功与失败回调</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// MyPromise 类中新增</span><br><span class="hljs-comment">// 存储成功回调函数</span><br>onFulfilledCallback <span class="hljs-punctuation">=</span> <span class="hljs-literal">null</span><span class="hljs-punctuation">;</span><br><span class="hljs-comment">// 存储失败回调函数</span><br>onRejectedCallback <span class="hljs-punctuation">=</span> <span class="hljs-literal">null</span><span class="hljs-punctuation">;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="2-then-方法中的-Pending-的处理"><a href="#2-then-方法中的-Pending-的处理" class="headerlink" title="2. then 方法中的 Pending 的处理"></a>2. then 方法中的 Pending 的处理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br>then(onFulfilled, onRejected) &#123;<br>  <span class="hljs-comment">// 判断状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>    <span class="hljs-comment">// 调用成功回调，并且把值返回</span><br>    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>    <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>    onRejected(<span class="hljs-keyword">this</span>.reason);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br>    <span class="hljs-comment">// 等到执行成功失败函数的时候再传递</span><br>    <span class="hljs-keyword">this</span>.onFulfilledCallback = onFulfilled;<br>    <span class="hljs-keyword">this</span>.onRejectedCallback = onRejected;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="3-resolve-与-reject-中调用回调函数"><a href="#3-resolve-与-reject-中调用回调函数" class="headerlink" title="3. resolve 与 reject 中调用回调函数"></a>3. resolve 与 reject 中调用回调函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 更改成功后的状态</span><br>resolve = (value) =&gt; &#123;<br>  <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>    <span class="hljs-comment">// 状态修改为成功</span><br>    <span class="hljs-keyword">this</span>.status = FULFILLED;<br>    <span class="hljs-comment">// 保存成功之后的值</span><br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// 判断成功回调是否存在，如果存在就调用</span><br>    <span class="hljs-keyword">this</span>.onFulfilledCallback &amp;&amp; <span class="hljs-keyword">this</span>.onFulfilledCallback(value);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><span class="hljs-comment">// 更改失败后的状态</span><br>reject = (reason) =&gt; &#123;<br>  <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>    <span class="hljs-comment">// 状态成功为失败</span><br>    <span class="hljs-keyword">this</span>.status = REJECTED;<br>    <span class="hljs-comment">// 保存失败后的原因</span><br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// 判断失败回调是否存在，如果存在就调用</span><br>    <span class="hljs-keyword">this</span>.onRejectedCallback &amp;&amp; <span class="hljs-keyword">this</span>.onRejectedCallback(reason)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>我们再执行一下上面的🌰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>); <br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;reject&#x27;</span>, reason)<br>&#125;)<br><br><span class="hljs-comment">// 等待 2s 输出 resolve success</span><br>复制代码<br></code></pre></td></tr></table></figure><p>目前已经可以简单处理异步问题了✌️</p><h3 id="三、实现-then-方法多次调用添加多个处理函数"><a href="#三、实现-then-方法多次调用添加多个处理函数" class="headerlink" title="三、实现 then 方法多次调用添加多个处理函数"></a>三、实现 then 方法多次调用添加多个处理函数</h3><blockquote><p>Promise 的 then 方法是可以被多次调用的。这里如果有三个 then 的调用，如果是同步回调，那么直接返回当前的值就行；如果是异步回调，那么保存的成功失败的回调，需要用不同的值保存，因为都互不相同。之前的代码需要改进。</p></blockquote><p>同样的先看一个🌰</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br>const promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>); <br>&#125;)<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;)<br> <br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;)<br><br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;)<br><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// resolve success</span><br><br>复制代码<br></code></pre></td></tr></table></figure><p>目前的代码只能输出：<code>3 resolve success</code>，怎么可以把 1、2 弄丢呢！</p><p>我们应该一视同仁，保证所有 then 中的回调函数都可以执行 🤔 继续改造</p><h4 id="1-MyPromise-类中新增两个数组"><a href="#1-MyPromise-类中新增两个数组" class="headerlink" title="1. MyPromise 类中新增两个数组"></a>1. MyPromise 类中新增两个数组</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// MyPromise.js<br><br>// 存储成功回调函数<br>// onFulfilledCallback <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br><span class="hljs-attribute">onFulfilledCallbacks</span> <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>// 存储失败回调函数<br>// onRejectedCallback <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br><span class="hljs-attribute">onRejectedCallbacks</span> <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="2-回调函数存入数组中"><a href="#2-回调函数存入数组中" class="headerlink" title="2. 回调函数存入数组中"></a>2. 回调函数存入数组中</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br>then(onFulfilled, onRejected) &#123;<br>  <span class="hljs-comment">// 判断状态</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>    <span class="hljs-comment">// 调用成功回调，并且把值返回</span><br>    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>    <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>    onRejected(<span class="hljs-keyword">this</span>.reason);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// 因为不知道后面状态的变化，这里先将成功回调和失败回调存储起来</span><br>    <span class="hljs-comment">// 等待后续调用</span><br>    <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);<br>    <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(onRejected);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="3-循环调用成功和失败回调"><a href="#3-循环调用成功和失败回调" class="headerlink" title="3. 循环调用成功和失败回调"></a>3. 循环调用成功和失败回调</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 更改成功后的状态</span><br>resolve = (value) =&gt; &#123;<br>  <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>    <span class="hljs-comment">// 状态修改为成功</span><br>    <span class="hljs-keyword">this</span>.status = FULFILLED;<br>    <span class="hljs-comment">// 保存成功之后的值</span><br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// resolve里面将所有成功的回调拿出来执行</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledCallbacks.length) &#123;<br>      <span class="hljs-comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span><br>      <span class="hljs-keyword">this</span>.onFulfilledCallbacks.shift()(value)<br>    &#125;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// MyPromise.js<br><br>// 更改失败后的状态<br><span class="hljs-attribute">reject</span> <span class="hljs-operator">=</span> (reason) <span class="hljs-operator">=</span>&gt; &#123;<br>  // 只有状态是等待，才执行状态修改<br>  if (this.status <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> PENDING) &#123;<br>    // 状态成功为失败<br>    this.status <span class="hljs-operator">=</span> REJECTED<span class="hljs-comment">;</span><br>    // 保存失败后的原因<br>    this.reason <span class="hljs-operator">=</span> reason<span class="hljs-comment">;</span><br>    // <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> 新增 <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>    // resolve里面将所有失败的回调拿出来执行<br>    while (this.onRejectedCallbacks.length) &#123;<br>      this.onRejectedCallbacks.shift()(reason)<br>    &#125;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>再来运行一下，看看结果👇</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">resolve</span> success<br><span class="hljs-built_in">resolve</span> success<br><span class="hljs-built_in">resolve</span> success<br>复制代码<br></code></pre></td></tr></table></figure><p>👏👏👏 完美，继续</p><h3 id="四、实现-then-方法的链式调用"><a href="#四、实现-then-方法的链式调用" class="headerlink" title="四、实现 then 方法的链式调用"></a>四、实现 then 方法的链式调用</h3><blockquote><p>then 方法要链式调用那么就需要返回一个 Promise 对象<br>then 方法里面 return 一个返回值作为下一个 then 方法的参数，如果是 return 一个 Promise 对象，那么就需要判断它的状态</p></blockquote><p>举个栗子 🌰</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br>const promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 目前这里只处理同步的问题</span><br>  resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>&#125;)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">other</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;other&#x27;</span>)<br>  &#125;)<br>&#125;<br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>  <span class="hljs-keyword">return</span> other()<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>用目前的手写代码运行的时候会报错 😣 无法链式调用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  ^<br><br>TypeError: Cannot read property <span class="hljs-string">&#x27;then&#x27;</span> of <span class="hljs-literal">undefined</span><br>复制代码<br></code></pre></td></tr></table></figure><p>接着改 💪</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  ......<br>  then(onFulfilled, onRejected) &#123;<br>    <span class="hljs-comment">// ==== 新增 ====</span><br>    <span class="hljs-comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br>    <span class="hljs-keyword">const</span> promise2 = new MyPromise((resolve, reject) =&gt; &#123;<br>      <span class="hljs-comment">// 这里的内容在执行器中，会立即执行</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>        <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>        <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>        resolvePromise(x, resolve, reject);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>        onRejected(<span class="hljs-keyword">this</span>.reason);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(onRejected);<br>      &#125;<br>    &#125;) <br>    <br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br><br>function resolvePromise(x, resolve, reject) &#123;<br>  <span class="hljs-comment">// 判断x是不是 MyPromise 实例对象</span><br>  <span class="hljs-keyword">if</span>(x instanceof MyPromise) &#123;<br>    <span class="hljs-comment">// 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span><br>    <span class="hljs-comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span><br>    <span class="hljs-comment">// 简化之后</span><br>    x.then(resolve, reject)<br>  &#125; <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 普通值</span><br>    resolve(x)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>执行一下，结果👇</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">resolve</span> success<br><span class="hljs-built_in">resolve</span> other<br>复制代码<br></code></pre></td></tr></table></figure><p>em… 符合预期 😎</p><h3 id="五、then-方法链式调用识别-Promise-是否返回自己"><a href="#五、then-方法链式调用识别-Promise-是否返回自己" class="headerlink" title="五、then 方法链式调用识别 Promise 是否返回自己"></a>五、then 方法链式调用识别 Promise 是否返回自己</h3><blockquote><p>如果 then 方法返回的是自己的 Promise 对象，则会发生循环调用，这个时候程序会报错</p></blockquote><p>例如下面这种情况👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p1 = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>  <span class="hljs-keyword">return</span> p1<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>使用原生 Promise 执行这个代码，会报类型错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Uncaught</span> (in promise) TypeError: Chaining cycle detected <span class="hljs-keyword">for</span> promise #&lt;Promise&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p>我们在 MyPromise 实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  ......<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>        <span class="hljs-comment">// resolvePromise 集中处理，将 promise2 传入</span><br>        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>        <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(onFulfilled);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>      &#125;<br>    &#125;) <br>    <br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span><br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))<br>  &#125;<br>  <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>    x.<span class="hljs-title function_">then</span>(resolve, reject)<br>  &#125; <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(x)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>执行一下，竟然报错了 😱</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">resolvePromise(promise2, x, resolve, reject);<br>                       ^<br><br>ReferenceError: Cannot <span class="hljs-keyword">access</span> <span class="hljs-string">&#x27;promise2&#x27;</span> <span class="hljs-keyword">before</span> initialization<br>复制代码<br></code></pre></td></tr></table></figure><p>为啥会报错呢？从错误提示可以看出，我们必须要等 promise2 完成初始化。这个时候我们就要用上宏微任务和事件循环的知识了，这里就需要创建一个异步函数去等待 promise2 完成初始化，前面我们已经确认了创建微任务的技术方案 –&gt; <code>queueMicrotask</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  ......<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>        <span class="hljs-comment">// ==== 新增 ====</span><br>        <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>        <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>          <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>          <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>          <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject);<br>        &#125;)  <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      ......<br>    &#125;) <br>    <br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>执行一下</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br>const promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>&#125;)<br> <br><span class="hljs-comment">// 这个时候将promise定义一个p1，然后返回的时候返回p1这个promise</span><br>const p1 = promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>   <span class="hljs-keyword">return</span> p1<br>&#125;)<br> <br><span class="hljs-comment">// 运行的时候会走reject</span><br>p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, reason =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(reason.message)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>这里得到我们的结果 👇</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">resolve</span> success<br>Chaining cycle detected <span class="hljs-keyword">for</span> promise <span class="hljs-comment">#&lt;Promise&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>哈哈，搞定 😎 开始下一步</p><h3 id="六、捕获错误及-then-链式调用其他状态代码补充"><a href="#六、捕获错误及-then-链式调用其他状态代码补充" class="headerlink" title="六、捕获错误及 then 链式调用其他状态代码补充"></a>六、捕获错误及 then 链式调用其他状态代码补充</h3><p>目前还缺少重要的一个环节，就是我们的错误捕获还没有处理</p><h4 id="1-捕获执行器错误"><a href="#1-捕获执行器错误" class="headerlink" title="1. 捕获执行器错误"></a>1. 捕获执行器错误</h4><blockquote><p>捕获执行器中的代码，如果执行器中有代码错误，那么 Promise 的状态要变为失败</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-keyword">constructor</span>(executor)&#123;<br>  <span class="hljs-comment">// ==== 新增 ====</span><br>  <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>  <span class="hljs-comment">// 并传入resolve和reject方法</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    executor(<span class="hljs-keyword">this</span>.resolve, <span class="hljs-keyword">this</span>.reject)<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-comment">// 如果有错误，就直接执行 reject</span><br>    <span class="hljs-keyword">this</span>.reject(error)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve(&#x27;success&#x27;)</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;执行器错误&#x27;</span>)<br>&#125;)<br> <br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason.<span class="hljs-property">message</span>)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>执行结果 👇</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">执行器错误<br>复制代码<br></code></pre></td></tr></table></figure><p>OK，通过 😀</p><h4 id="2-then-执行的时错误捕获"><a href="#2-then-执行的时错误捕获" class="headerlink" title="2. then 执行的时错误捕获"></a>2. then 执行的时错误捕获</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br>then(onFulfilled, onRejected) &#123;<br>  <span class="hljs-comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br>  <span class="hljs-keyword">const</span> promise2 = new MyPromise((resolve, reject) =&gt; &#123;<br>    <span class="hljs-comment">// 判断状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>      <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>      queueMicrotask(() =&gt; &#123;<br>        <span class="hljs-comment">// ==== 新增 ====</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>          <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>          <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>          resolvePromise(promise2, x, resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          reject(error)<br>        &#125;  <br>      &#125;)  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;<br>      <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>      onRejected(<span class="hljs-keyword">this</span>.reason);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 等待</span><br>      <span class="hljs-comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br>      <span class="hljs-comment">// 等到执行成功失败函数的时候再传递</span><br>      <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(onFulfilled);<br>      <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(onRejected);<br>    &#125;<br>  &#125;) <br>  <br>  <span class="hljs-keyword">return</span> promise2;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br>const promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>    <span class="hljs-comment">// throw new Error(&#x27;执行器错误&#x27;)</span><br> &#125;)<br> <br><span class="hljs-comment">// 第一个then方法中的错误要在第二个then方法中捕获到</span><br>promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolve&#x27;</span>, value)<br>  throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;then error&#x27;</span>)<br>&#125;, reason =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(reason.message)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);<br>&#125;, reason =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(reason.message)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>执行结果 👇</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">resolve</span> success<br>then <span class="hljs-literal">error</span><br>复制代码<br></code></pre></td></tr></table></figure><p>这里成功打印了 1 中抛出的错误 <code>then error</code></p><h3 id="七、参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造"><a href="#七、参考-fulfilled-状态下的处理方式，对-rejected-和-pending-状态进行改造" class="headerlink" title="七、参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造"></a>七、参考 fulfilled 状态下的处理方式，对 rejected 和 pending 状态进行改造</h3><p><strong>改造内容包括：</strong></p><blockquote><ol><li>增加异步状态下的链式调用</li><li>增加回调函数执行结果的判断</li><li>增加识别 Promise 是否返回自己</li><li>增加错误捕获</li></ol></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br>then(onFulfilled, onRejected) &#123;<br>  <span class="hljs-comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br>  <span class="hljs-keyword">const</span> promise2 = new MyPromise((resolve, reject) =&gt; &#123;<br>    <span class="hljs-comment">// 判断状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>      <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>      queueMicrotask(() =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>          <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>          <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>          resolvePromise(promise2, x, resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          reject(error)<br>        &#125; <br>      &#125;)  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123; <br>      <span class="hljs-comment">// ==== 新增 ====</span><br>      <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>      queueMicrotask(() =&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>          <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>          <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>          resolvePromise(promise2, x, resolve, reject);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>          reject(error)<br>        &#125; <br>      &#125;) <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 等待</span><br>      <span class="hljs-comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br>      <span class="hljs-comment">// 等到执行成功失败函数的时候再传递</span><br>      <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(() =&gt; &#123;<br>        <span class="hljs-comment">// ==== 新增 ====</span><br>        queueMicrotask(() =&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>            <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>            resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error)<br>          &#125; <br>        &#125;) <br>      &#125;);<br>      <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(() =&gt; &#123;<br>        <span class="hljs-comment">// ==== 新增 ====</span><br>        queueMicrotask(() =&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>            <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>            <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>            resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error)<br>          &#125; <br>        &#125;) <br>      &#125;);<br>    &#125;<br>  &#125;) <br>  <br>  <span class="hljs-keyword">return</span> promise2;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="八、then-中的参数变为可选"><a href="#八、then-中的参数变为可选" class="headerlink" title="八、then 中的参数变为可选"></a>八、then 中的参数变为可选</h3><p>上面我们处理 then 方法的时候都是默认传入 onFulfilled、onRejected 两个回调函数，但是实际上原生 Promise 是可以选择参数的单传或者不传，都不会影响执行。</p><p>例如下面这种 👇</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  resolve(<span class="hljs-number">100</span>)<br>&#125;)<br><br>promise<br>  .then()<br>  .then()<br>  .then()<br>  .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value))<br><br><span class="hljs-comment">// 输出 100</span><br>复制代码<br></code></pre></td></tr></table></figure><p>所以我们需要对 then 方法做一点小小的调整</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 如果不传，就使用默认函数</span><br>  onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>  onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<span class="hljs-keyword">throw</span> reason&#125;;<br><br>  <span class="hljs-comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br>  <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  ......<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>改造完自然是需要验证一下的</p><p><strong>先看情况一</strong>：resolve 之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;succ&#x27;</span>)<br>&#125;)<br> <br>promise.<span class="hljs-title function_">then</span>().<span class="hljs-title function_">then</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value))<br><br><span class="hljs-comment">// 打印 succ</span><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>先看情况一</strong>：reject 之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyPromise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;err&#x27;</span>)<br>&#125;)<br> <br>promise.<span class="hljs-title function_">then</span>().<span class="hljs-title function_">then</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value), <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason))<br><br><span class="hljs-comment">// 打印 err</span><br>复制代码<br></code></pre></td></tr></table></figure><p>写到这里，麻雀版的 Promise 基本完成了，鼓掌 👏👏👏</p><h3 id="九、实现-resolve-与-reject-的静态调用"><a href="#九、实现-resolve-与-reject-的静态调用" class="headerlink" title="九、实现 resolve 与 reject 的静态调用"></a>九、实现 resolve 与 reject 的静态调用</h3><p>就像开头挂的那道面试题使用 <code>return Promise.resolve</code> 来返回一个 Promise 对象，我们用现在的手写代码尝试一下</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise&#x27;</span>)<br><br>MyPromise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> MyPromise.resolve(<span class="hljs-number">4</span>);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>结果它报错了 😥</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">MyPromise.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>          ^<br><br>TypeError: MyPromise.resolve <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a function<br>复制代码<br></code></pre></td></tr></table></figure><p>除了 Promise.resolve 还有 Promise.reject 的用法，我们都要去支持，接下来我们来实现一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-title class_">MyPromise</span> &#123;<br>  ......<br>  <span class="hljs-comment">// resolve 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span> (parameter) &#123;<br>    <span class="hljs-comment">// 如果传入 MyPromise 就直接返回</span><br>    <span class="hljs-keyword">if</span> (parameter <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> parameter;<br>    &#125;<br><br>    <span class="hljs-comment">// 转成常规方式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>      <span class="hljs-title function_">resolve</span>(parameter);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// reject 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span> (reason) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(reason);<br>    &#125;);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>这样我们再测试上面的 🌰 就不会有问题啦</p><p>执行结果 👇</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">复制代码<br></code></pre></td></tr></table></figure><p>到这里手写工作就基本完成了，前面主要为了方便理解，所以有一些冗余代码，我规整一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 先定义三个常量表示状态</span><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-comment">// 新建 MyPromise 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  <span class="hljs-keyword">constructor</span>(executor)&#123;<br>    <span class="hljs-comment">// executor 是一个执行器，进入会立即执行</span><br>    <span class="hljs-comment">// 并传入resolve和reject方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      executor(<span class="hljs-keyword">this</span>.resolve, <span class="hljs-keyword">this</span>.reject)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-keyword">this</span>.reject(error)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 储存状态的变量，初始值是 pending</span><br>  status = PENDING;<br>  <span class="hljs-comment">// 成功之后的值</span><br>  value = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 失败之后的原因</span><br>  reason = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 存储成功回调函数</span><br>  onFulfilledCallbacks = [];<br>  <span class="hljs-comment">// 存储失败回调函数</span><br>  onRejectedCallbacks = [];<br><br>  <span class="hljs-comment">// 更改成功后的状态</span><br>  resolve = (value) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态修改为成功</span><br>      <span class="hljs-keyword">this</span>.status = FULFILLED;<br>      <span class="hljs-comment">// 保存成功之后的值</span><br>      <span class="hljs-keyword">this</span>.value = value;<br>      <span class="hljs-comment">// resolve里面将所有成功的回调拿出来执行</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledCallbacks.length) &#123;<br>        <span class="hljs-comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span><br>        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.shift()(value)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 更改失败后的状态</span><br>  reject = (reason) =&gt; &#123;<br>    <span class="hljs-comment">// 只有状态是等待，才执行状态修改</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>      <span class="hljs-comment">// 状态成功为失败</span><br>      <span class="hljs-keyword">this</span>.status = REJECTED;<br>      <span class="hljs-comment">// 保存失败后的原因</span><br>      <span class="hljs-keyword">this</span>.reason = reason;<br>      <span class="hljs-comment">// resolve里面将所有失败的回调拿出来执行</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onRejectedCallbacks.length) &#123;<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks.shift()(reason)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  then(onFulfilled, onRejected) &#123;<br>    <span class="hljs-keyword">const</span> realOnFulfilled = typeof onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : value =&gt; value;<br>    <span class="hljs-keyword">const</span> realOnRejected = typeof onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : reason =&gt; &#123;<span class="hljs-keyword">throw</span> reason&#125;;<br><br>    <span class="hljs-comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span><br>    <span class="hljs-keyword">const</span> promise2 = new MyPromise((resolve, reject) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> fulfilledMicrotask = () =&gt;  &#123;<br>        <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>        queueMicrotask(() =&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取成功回调函数的执行结果</span><br>            <span class="hljs-keyword">const</span> x = realOnFulfilled(<span class="hljs-keyword">this</span>.value);<br>            <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>            resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error)<br>          &#125; <br>        &#125;)  <br>      &#125;<br><br>      <span class="hljs-keyword">const</span> rejectedMicrotask = () =&gt; &#123; <br>        <span class="hljs-comment">// 创建一个微任务等待 promise2 完成初始化</span><br>        queueMicrotask(() =&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用失败回调，并且把原因返回</span><br>            <span class="hljs-keyword">const</span> x = realOnRejected(<span class="hljs-keyword">this</span>.reason);<br>            <span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>            resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            reject(error)<br>          &#125; <br>        &#125;) <br>      &#125;<br>      <span class="hljs-comment">// 判断状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;<br>        fulfilledMicrotask() <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123; <br>        rejectedMicrotask()<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === PENDING) &#123;<br>        <span class="hljs-comment">// 等待</span><br>        <span class="hljs-comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span><br>        <span class="hljs-comment">// 等到执行成功失败函数的时候再传递</span><br>        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(fulfilledMicrotask);<br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(rejectedMicrotask);<br>      &#125;<br>    &#125;) <br>    <br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br><br>  <span class="hljs-comment">// resolve 静态方法</span><br>  static resolve (parameter) &#123;<br>    <span class="hljs-comment">// 如果传入 MyPromise 就直接返回</span><br>    <span class="hljs-keyword">if</span> (parameter instanceof MyPromise) &#123;<br>      <span class="hljs-keyword">return</span> parameter;<br>    &#125;<br><br>    <span class="hljs-comment">// 转成常规方式</span><br>    <span class="hljs-keyword">return</span> new MyPromise(resolve =&gt;  &#123;<br>      resolve(parameter);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// reject 静态方法</span><br>  static reject (reason) &#123;<br>    <span class="hljs-keyword">return</span> new MyPromise((resolve, reject) =&gt; &#123;<br>      reject(reason);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>function resolvePromise(promise2, x, resolve, reject) &#123;<br>  <span class="hljs-comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span><br>  <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>    <span class="hljs-keyword">return</span> reject(new TypeError(<span class="hljs-string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))<br>  &#125;<br>  <span class="hljs-comment">// 判断x是不是 MyPromise 实例对象</span><br>  <span class="hljs-keyword">if</span>(x instanceof MyPromise) &#123;<br>    <span class="hljs-comment">// 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span><br>    <span class="hljs-comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span><br>    <span class="hljs-comment">// 简化之后</span><br>    x.then(resolve, reject)<br>  &#125; <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 普通值</span><br>    resolve(x)<br>  &#125;<br>&#125;<br><br>module.exports = MyPromise;<br>复制代码<br></code></pre></td></tr></table></figure><p>到这一步手写部分基本大功告成 🎉🎉🎉</p><h2 id="Promise-A-测试"><a href="#Promise-A-测试" class="headerlink" title="Promise A+ 测试"></a>Promise A+ 测试</h2><p>上面介绍了 Promise A+ 规范，当然我们手写的版本也得符合了这个规范才有资格叫 Promise， 不然就只能是伪 Promise 了。</p><p>上文讲到了 <code>promises-aplus-tests</code>，现在我们正式开箱使用</p><h4 id="1-安装一下"><a href="#1-安装一下" class="headerlink" title="1. 安装一下"></a>1. 安装一下</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> promises-aplus-tests -D<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="2-手写代码中加入-deferred"><a href="#2-手写代码中加入-deferred" class="headerlink" title="2. 手写代码中加入 deferred"></a>2. 手写代码中加入 deferred</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-title class_">MyPromise</span> &#123;<br>  ......<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> result = &#123;&#125;;<br>  result.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    result.<span class="hljs-property">resolve</span> = resolve;<br>    result.<span class="hljs-property">reject</span> = reject;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPromise</span>;<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="3-配置启动命令"><a href="#3-配置启动命令" class="headerlink" title="3. 配置启动命令"></a>3. 配置启动命令</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;promise&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my promise&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MyPromise.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;promises-aplus-tests MyPromise&quot;</span><br>  &#125;<span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ITEM&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;promises-aplus-tests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.1.2&quot;</span><br>  &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>开启测试</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="language-bash"> <span class="hljs-built_in">test</span></span><br>复制代码<br></code></pre></td></tr></table></figure><p>迫不及待了吧 😄 看看我们的结果如何，走起 🐱‍🏍</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6b60d615564bf892084c277f2e111b~tplv-k3u1fbpfcp-watermark.image"></p><p>虽然功能上没啥问题，但是测试却失败了 😥</p><p>针对提示信息，我翻看了一下 Promise A+ 规范，发现我们应该是在 2.3.x 上出现了问题，这里规范使用了不同的方式进行了 then 的返回值判断。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/535045144acb4d7794d05569b231e892~tplv-k3u1fbpfcp-watermark.image"></p><p>自红线向下的细节，我们都没有处理，这里要求判断 x 是否为 object 或者 function，满足则接着判断 x.then 是否存在，这里可以理解为判断 x 是否为 promise，这里都功能实际与我们手写版本中 <code>x instanceof MyPromise</code> 功能相似。</p><p>我们还是按照规范改造一下 <code>resolvePromise</code> 方法吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise, x, resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span><br>  <span class="hljs-keyword">if</span> (promise === x) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;The promise and the return value are the same&#x27;</span>));<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// x 为 null 直接返回，走后面的逻辑会报错</span><br>    <span class="hljs-keyword">if</span> (x === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(x);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> then;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 把 x.then 赋值给 then </span><br>      then = x.<span class="hljs-property">then</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 如果取 x.then 的值时抛出错误 error ，则以 error 为据因拒绝 promise</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 then 是函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        then.<span class="hljs-title function_">call</span>(<br>          x, <span class="hljs-comment">// this 指向 x</span><br>          <span class="hljs-comment">// 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span><br>          <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;<br>            <span class="hljs-comment">// 如果 resolvePromise 和 rejectPromise 均被调用，</span><br>            <span class="hljs-comment">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span><br>            <span class="hljs-comment">// 实现这条需要前面加一个变量 called</span><br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">resolvePromise</span>(promise, y, resolve, reject);<br>          &#125;,<br>          <span class="hljs-comment">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span><br>          <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-title function_">reject</span>(r);<br>          &#125;);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-comment">// 如果调用 then 方法抛出了异常 error：</span><br>        <span class="hljs-comment">// 如果 resolvePromise 或 rejectPromise 已经被调用，直接返回</span><br>        <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 否则以 error 为据因拒绝 promise</span><br>        <span class="hljs-title function_">reject</span>(error);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果 then 不是函数，以 x 为参数执行 promise</span><br>      <span class="hljs-title function_">resolve</span>(x);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span><br>    <span class="hljs-title function_">resolve</span>(x);<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>改造后启动测试</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c62e0df759748eb97b453ff94492877~tplv-k3u1fbpfcp-watermark.image"></p><p>完美通过 👏👏👏</p><h2 id="最终时刻，如何解释那道面试题的执行结果"><a href="#最终时刻，如何解释那道面试题的执行结果" class="headerlink" title="最终时刻，如何解释那道面试题的执行结果"></a>最终时刻，如何解释那道面试题的执行结果</h2><p>先用我们自己的 Promise 运行一下那道面试题 👇</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// test.js</span><br><br>const MyPromise = require(<span class="hljs-string">&#x27;./MyPromise.js&#x27;</span>)<br><br>MyPromise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> MyPromise.resolve(<span class="hljs-number">4</span>);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;)<br><br>MyPromise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br>复制代码<br></code></pre></td></tr></table></figure><p>执行结果：<strong>0、1、2、4、3、5、6</strong> 🤯</p><p>这里我们手写版本的 4 并没有和 原生 Promise 一样在 3 后面，而是在 2 后面</p><p>其实从我们的手写代码上看，在判断 then 内部函数执行结果，也就是在这里 👇</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// MyPromise.js</span><br><br><span class="hljs-comment">// 获取成功回调函数的执行结果</span><br><span class="hljs-keyword">const</span> x = realOnFulfilled(<span class="hljs-keyword">this</span>.value);<br><span class="hljs-comment">// 传入 resolvePromise 集中处理</span><br>resolvePromise(promise2, x, resolve, reject);<br>复制代码<br></code></pre></td></tr></table></figure><p>面试题中 x 为 <code>MyPromise.resolve(4)</code> 的时候，在传入 resolvePromise 方法中会对 x 的类型进行判断时，会发现它是一个 Promise，并让其调用 then 方法完成状态转换。再看 resolvePromis 方法中这一块判断逻辑 👇</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> <span class="hljs-variable language_">x</span> === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-built_in">typeof</span> <span class="hljs-variable language_">x</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// x 为 null 直接返回，走后面的逻辑会报错</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">x</span> === null) &#123;<br>      <span class="hljs-keyword">return</span> resolve(<span class="hljs-variable language_">x</span>);<br>    &#125;<br><br>    let <span class="hljs-keyword">then</span>;<br>    try &#123;<br>      <span class="hljs-comment">// 把 x.then 赋值给 then </span><br>      <span class="hljs-keyword">then</span> = <span class="hljs-variable language_">x</span>.<span class="hljs-keyword">then</span>;<br>    &#125; catch (error) &#123;<br>      <span class="hljs-comment">// 如果取 x.then 的值时抛出错误 error ，则以 error 为据因拒绝 promise</span><br>      <span class="hljs-keyword">return</span> reject(error);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 then 是函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> <span class="hljs-keyword">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      let called = <span class="hljs-symbol">false</span>;<br>      try &#123;<br>        <span class="hljs-keyword">then</span>.call(<br>          <span class="hljs-variable language_">x</span>, <span class="hljs-comment">// this 指向 x</span><br>          <span class="hljs-comment">// 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y)</span><br>          <span class="hljs-variable language_">y</span> =&gt; &#123;<br>            <span class="hljs-comment">// 如果 resolvePromise 和 rejectPromise 均被调用，</span><br>            <span class="hljs-comment">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span><br>            <span class="hljs-comment">// 实现这条需要前面加一个变量 called</span><br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-symbol">true</span>;<br>            resolvePromise(promise, <span class="hljs-variable language_">y</span>, resolve, reject);<br>          &#125;,<br>          <span class="hljs-comment">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span><br>          r =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-symbol">true</span>;<br>            reject(r);<br>          &#125;);<br>      &#125; <br>      ......   <br>复制代码<br></code></pre></td></tr></table></figure><p>那么问题来了</p><ul><li><strong>为什么我们 Promise A+ 测试全部通过的手写代码，执行结果却与原生 Promise 不同？</strong></li><li><strong>在我们手写代码使用创建一次微任务的方式，会带来什么问题吗？</strong></li></ul><p>ES6 中的 Promise 虽然是遵循 Promise A+ 规范实现的，但实际上也 Promise A+ 上做了一些功能扩展，例如：Promise.all、Promise.race 等，所以即使都符合 Promise A+ ，执行结果也是可能存在差异的。我们这里更需要思考的是第二个问题，<strong>不这么做会带来什么问题，也就是加一次微任务的必要性。</strong></p><p>我尝试过很多例子，都没有找到相关例证，我们手写实现的 Promise 都很好的完成工作，拿到了结果。我不得不去翻看更多的相关文章，我发现有些人会为了让执行结果与原生相同，强行去再多加一次微任务，这种做法是很牵强的。</p><p>毕竟实现 Promise 的目的是为了解决异步编程的问题，能够拿到正确的结果才是最重要的，强行为了符合面试题的输出顺序去多加一次微任务，只能让手写代码变的更加复杂，不好理解。</p><p>在 stackoverflow 上，有一个类似的问题 <a href="https://stackoverflow.com/questions/58217603/what-is-the-difference-between-returned-promise">What is the difference between returned Promise?</a> 回答中有一个信息就是</p><blockquote><p><code>It only required the execution context stack contains only platform code.</code> 也就相当于等待 <code>execution context stack</code> 清空。</p></blockquote><p>这个在掘金中的一篇文章 <a href="https://juejin.cn/post/6937076967283884040">我以为我很懂 Promise，直到我开始实现 Promise&#x2F;A + 规范</a> 也有一段关于这道面试题的讨论</p><blockquote><p><code>return Promise.resolve(4)</code>，JS 引擎会安排一个 job（job 是 ECMA 中的概念，等同于微任务的概念)，其回调目的是让其状态变为 fulfilled。</p></blockquote><p>实际上我们已经在 <code>static resolve</code> 创建了一个新的 MyPromsie，并调用其 then 方法，创建了一个微任务。</p><p>所以，就目前的信息来说，两次微任务依旧不能证明其必要性，目前的 Promise 日常操作，一次微任务都是可以满足。</p><p>大家对于这个道面试题有什么想法或者意见，赶紧在留言区告诉我吧，一起探讨一下到底是必然还是巧合🤔</p><p><strong>长文整理不易，记得 点赞 👍 支持一下哦 😘</strong></p>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在大厂是如何高效组织npmscript的</title>
    <link href="/2021/02/12/%E5%9C%A8%E5%A4%A7%E5%8E%82%E6%98%AF%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%BB%84%E7%BB%87npmscript%E7%9A%84/"/>
    <url>/2021/02/12/%E5%9C%A8%E5%A4%A7%E5%8E%82%E6%98%AF%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%BB%84%E7%BB%87npmscript%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 原文地址 <a href="https://juejin.cn/post/6945236994247098381?utm_source=gold_browser_extension">juejin.cn</a></p></blockquote><p>众所周知，一个 Javasript 项目的脚本类工具，可以使用 package.json 中的 <code>scripts</code> 字段来组织，简单来说，这就是 <code>npm script</code>。</p><p>最典型最常用约定俗成的一个是 <code>npm start</code>，用以启动项目：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>约定俗成的还有很多，如下所列</p><ul><li>npm install</li><li>npm test</li><li>npm publish</li><li>…</li></ul><p>约定俗成的亲儿子脚本自然和其它第三方脚本不一样，如果需要执行它，直接使用 <code>npm</code> 前缀即可，如 <code>npm start</code>，那其它脚本呢？那就需要 <code>npm run</code> 前缀了。而 <code>yarn</code> 就没这么多讲究了，一视同仁。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>npm run &lt;user <span class="hljs-keyword">defined</span>&gt;<br><span class="hljs-variable">$ </span>npm run-script dev<br><br><span class="hljs-comment"># 为了简单方便，等同于</span><br><span class="hljs-variable">$ </span>npm run dev<br><br><span class="hljs-comment"># yarn </span><br><span class="hljs-variable">$ </span>yarn dev<br>复制代码<br></code></pre></td></tr></table></figure><p>以上是众所周知的，以下讲一讲有可能不是众所周知的</p><h2 id="运行-npm-run-dev-与-npm-start-的区别"><a href="#运行-npm-run-dev-与-npm-start-的区别" class="headerlink" title="运行: npm run dev 与 npm start 的区别"></a>运行: npm run dev 与 npm start 的区别</h2><p>对于一个<strong>纯生成静态页面打包</strong>的前端项目而言，它们是没有多少区别的：生产环境的部署只依赖于构建生成的资源，更不依赖 npm scripts。可见 <a href="https://shanyue.tech/frontend-engineering/docker.html">如何部署前端项目</a>。</p><p>使用 <code>create-react-app</code> 生成的项目，它的 npm script 中只有 <code>npm start</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts start&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts build&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts test&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;eject&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react-scripts eject&quot;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>使用 <code>vuepress</code> 生成的项目，它的 npm script 中只有 <code>npm run dev</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vuepress dev&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vuepress build&quot;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>在一个<strong>面向服务端</strong>的项目中，如 <code>next</code>、<code>nuxt</code> 与 <code>nest</code>。dev 与 start 的区别趋于明显，一个为生产环境，一个为开发环境</p><ul><li>dev: 在开发环境启动项目，一般带有 watch 选项，监听文件变化而重启服务，此时会耗费大量的 CPU 性能，不宜放在生产环境</li><li>start: 在生产环境启动项目</li></ul><p>在 <code>nest</code> 项目中进行配置</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nest start&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nest start --watch&quot;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="运行：Script-Hooks-如何把新项目快速跑起来"><a href="#运行：Script-Hooks-如何把新项目快速跑起来" class="headerlink" title="运行：Script Hooks -&gt; 如何把新项目快速跑起来"></a>运行：Script Hooks -&gt; 如何把新项目快速跑起来</h2><p>新人入职新上手项目，如何把它跑起来，这是所有人都会碰到的问题：所有人都是从新手开始的。</p><p>有可能你会脱口而出：<code>npm run dev/npm start</code>，但实际工作中，处处藏坑，往往没这么简单。</p><ol><li>查看是否有 <code>CI/CD</code>，如果有跟着 <code>CI/CD</code> 部署的脚本跑命令</li><li>查看是否有 <code>dockerfile</code>，如果有跟着 <code>dockerfile</code> 跑命令</li><li>查看 npm scripts 中是否有 dev&#x2F;start，尝试 <code>npm run dev/npm start</code></li><li>查看是否有文档，如果有跟着文档走。为啥要把文档放到最后一个？原因你懂的</li></ol><p>但即便是十分谨慎，也有可能遇到以下几个叫苦不迭、浪费了一下午时间的坑:</p><ol><li>前端有可能在<strong>本地环境启动时需要依赖前端构建时所产生的文件</strong>，所以有时需要**先正常部署一遍，再试着按照本地环境启动 (即需要先 <code>npm run build</code> 一下，再 <code>npm run dev/npm start</code>)**。(比如，一次我们的项目 npm run dev 时需要 webpack DllPlugin 构建后的东西）</li><li>别忘了设置环境变量或者配置文件</li></ol><p>因此，设置一个少的 script，可以很好地避免后人踩坑，更重要的是，可以避免后人骂你</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run dev&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node assets &amp;&amp; node config&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 设置一个 dev 的钩子，在 npm run dev 前执行，此处有可能不是必须的</span><br>    <span class="hljs-string">&quot;predev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --inline --progress&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>在 npm script 中，对于每一个命令都有 Pre&#x2F;Post 钩子，分别在命令执行前后执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">npm run <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">pre<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">post<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span></span></span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="language-handlebars">复制代码</span></span></span></span></span></span><br></code></pre></td></tr></table></figure><p>在工作中，这些钩子与内置的命令为项目提供了简便的操作方式，也提供了更安全的项目操作流程</p><ol><li>装包之后，进行 husky(v5.0) 的设置</li><li>打包之前，清理目标文件件</li><li>发包之前，进行打包构建</li><li>运行之前，准备好资源文件</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;postinstall&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;husky install&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;prebuild&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rimraf dist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;predev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run assets&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack-dev-server --inline --progress&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建打包，基本上所有的项目都含有这个命令，并且默认为 <code>npm run build</code>。</p><p>在 CI 或前端托管平台 Vercel&#x2F;Netlify 中，对于部署前端项目，最重要的一步就是打包。但是有些项目有可能不需要打包，此时可以使用 <code>if-present</code> 参数，代表如果存在该 script，则执行，否则跳过</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ npm <span class="hljs-built_in">run</span> <span class="hljs-comment">--if-present build</span><br>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;next build&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="测试-Script-后缀"><a href="#测试-Script-后缀" class="headerlink" title="测试: Script 后缀"></a>测试: Script 后缀</h2><p>对于完成一件极为复杂的事情，可以使用前缀进行分组组织 npm script，比如测试。</p><ul><li><code>npm run test</code>: 使用 <a href="https://npm.devtool.tech/mocha">mocha</a> 进行单元测试</li><li><code>npm run test:coverage</code>: 使用 <a href="https://npm.devtool.tech/nyc">nyc</a> 查看单元测试覆盖率</li><li><code>npm run test:e2e</code>: 使用 <a href="https://npm.devtool.tech/cypress">cypress</a> 进行 UI 自动化测试</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;test:coverage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nyc npm test&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;test:e2e&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run cy:run --&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;cy:run&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cypress run --config-file cypress/config.json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-string">&quot;cy:open&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cypress open --config-file cypress/config.json&quot;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>对于测试而言，<code>mocha</code> 与 <code>nyc</code> 结合可以很好地进行单元测试，并提供覆盖率报告。</p><p>对于前端 e2e 测试而言，<code>cypress</code> 与 <code>puppeteer</code> 无疑是最流行的框架。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48fc28f255b24dc397fd986328ecf644~tplv-k3u1fbpfcp-zoom-1.image"></p><p>那如何对 Vue&#x2F;React 组件进行更好地测试及文档呢？</p><h2 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试:"></a>组件测试:</h2><p><a href="https://storybook.js.org/">storybook</a> 可以更好地对 React&#x2F;Vue 组件进行调试、测试并形成帮助文档。开发基础组件库时，可以配置 <code>npm run storybook</code> 进行更好的测试</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ npm <span class="hljs-built_in">run</span> storybook<br>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;storybook&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;start-storybook -p 9001 -c .storybook&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;storybook:build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build-storybook -c .storybook -o .out&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;prepublishOnly&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68555f54b5734ebf8a30820f6c7909ef~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="格式化-Prettier"><a href="#格式化-Prettier" class="headerlink" title="格式化: Prettier"></a>格式化: Prettier</h2><p><a href="https://npm.devtool.tech/prettier">Prettier</a> 是一款支持多种编程语言，如 html、css、js、graphql、markdown 等并且可与编辑器 (vscode) 深度集成的代码格式化工具。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5512ac6e65f444b1b26d97f937172741~tplv-k3u1fbpfcp-zoom-1.image"></p><p>在 npm script 中配置代码格式化如下所示：对 <code>js</code>、<code>css</code>、<code>json</code>、<code>markdown</code> 进行格式化</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">//</span> 配置文件: <span class="hljs-string">.prettierrc</span><br>    <span class="hljs-string">//</span> 格式化: <span class="hljs-params">--write</span><br>    <span class="hljs-string">//</span> 文件: *<span class="hljs-string">.js</span><br>    <span class="hljs-string">&quot;prettier&quot;</span>: <span class="hljs-string">&quot;prettier --config .prettierrc --write &#123;.,components,lib,pages&#125;/*.&#123;js,css,json,md&#125;&quot;</span>,<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>.prettierrc</code> 是 <code>prettier</code> 的配置文件，一般是比较简单的配置，可供配置的 <a href="https://prettier.io/docs/en/options.html#parser">Prettier Options</a> 也没有很多。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">&#123;<br>  <span class="hljs-string">&quot;singleQuote&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;printWidth&quot;</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-string">&quot;semi&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;arrowParens&quot;</span>: <span class="hljs-string">&quot;avoid&quot;</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="Lint-代码格式化及质量检查"><a href="#Lint-代码格式化及质量检查" class="headerlink" title="Lint: 代码格式化及质量检查"></a>Lint: 代码格式化及质量检查</h2><p>那 Prettier 与 ESLint&#x2F;StyleLint&#x2F;TSLint 有什么区别？</p><p><code>Prettier</code> 仅仅作代码的格式化，如空格、是否添加分号之类。而 ESLint 之类对代码格式化外，还对代码进行<strong>质量检查</strong>，如 <code>no-unused-vars</code>, <code>no-implicit-globals</code> 等规则。</p><p>JS 与 TS 的质量检查，还是要看 <a href="https://npm.devtool.tech/eslint">eslint</a>。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;lint:fix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint . --fix&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>除了 eslint 之外，还可以对 markdown、gitcommit 进行格式化</p><ul><li><a href="https://npm.devtool.tech/markdownlint">markdownlint</a></li><li><a href="https://www.npmjs.com/package/@commitlint/cli">commitlint</a></li></ul><h2 id="Git-你好，代码不合格，这里禁止提交"><a href="#Git-你好，代码不合格，这里禁止提交" class="headerlink" title="Git: 你好，代码不合格，这里禁止提交"></a>Git: 你好，代码不合格，这里禁止提交</h2><p>你的代码不合格，为了避免你被他人吐槽，这里不允许提交。这时候 Git Hooks 就派上了用场。</p><p>Git Hooks 中的 <code>precommit hook</code> 会在代码提交之前执行脚本，如果脚本不通过 (Exit Code 不是 0)，则禁止提交。</p><p><a href="https://npm.devtool.tech/husky">husky</a> 与 <a href="https://github.com/okonet/lint-staged">lint-staged</a> 是 <code>Git Hooks</code> 的最佳搭配。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;lint&quot;</span>: <span class="hljs-string">&quot;eslint .&quot;</span>,<br>    <span class="hljs-string">&quot;prettier&quot;</span>: <span class="hljs-string">&quot;prettier --config .prettierrc --write &#123;.,components,lib,pages&#125;/*.&#123;js,css,json,md&#125;&quot;</span>,<br>  &#125;,<br>  <span class="hljs-string">&quot;husky&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hooks&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;pre-commit&quot;</span>: <span class="hljs-string">&quot;lint-staged&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;*.js&quot;</span>: [<br>      <span class="hljs-string">&quot;npm run lint&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;*.&#123;js,css,json,md&#125;&quot;</span>: [<br>      <span class="hljs-string">&quot;npm run prettier&quot;</span><br>    ]<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="Outdated-你的依赖已过期"><a href="#Outdated-你的依赖已过期" class="headerlink" title="Outdated: 你的依赖已过期"></a>Outdated: 你的依赖已过期</h2><p>当一个库过期了会怎么样？</p><ul><li>找不到文档，无处下手</li><li>经常有 Bug 由过期库引起，很难修复</li><li>存在安全风险</li></ul><p>没有人会喜欢过期的库。</p><p>使用 <code>npm outdated</code> 可以发现 package.json 中依赖的过期库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm outdated<br>Package                            Current  Wanted  Latest  Location                                        Depended by<br>@vuepress/plugin-google-analytics    1.7.1   1.8.2   1.8.2  node_modules/@vuepress/plugin-google-analytics  blog<br>axios                               0.21.0  0.21.1  0.21.1  node_modules/axios                              blog<br>dayjs                                1.9.6  1.10.4  1.10.4  node_modules/dayjs                              blog<br>graphql                             15.4.0  15.5.0  15.5.0  node_modules/graphql                            blog<br>koa                                 2.13.0  2.13.1  2.13.1  node_modules/koa                                blog<br>npm-check-updates                   10.2.2  10.3.1  11.3.0  node_modules/npm-check-updates                  blog<br>vuepress                             1.7.1   1.8.2   1.8.2  node_modules/vuepress                           blog<br>复制代码<br></code></pre></td></tr></table></figure><p>但是 <code>npm outdated</code> 并不好用，比如如何一键升级？就像应用商店升级所有手机软件一样。</p><p><code>node-check-updates</code> 是加强版的 <code>npm outdated</code>，它最简单的功能是一键升级，细化功能是升级策略与安全升级。ncu 是它的二进制命令</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="language-xml">$ ncu</span><br><span class="language-xml">Checking package.json</span><br><span class="language-xml">[====================] </span><span class="hljs-number">5</span><span class="language-xml">/</span><span class="hljs-number">5</span><span class="language-xml"> </span><span class="hljs-number">100</span><span class="language-xml">%</span><br><span class="language-xml"></span><br><span class="language-xml">express           </span><span class="hljs-number">4.12</span><span class="language-xml">.x  →   </span><span class="hljs-number">4.13</span><span class="language-xml">.x</span><br><span class="language-xml">multer            </span><span class="hljs-keyword">^0.1.8</span><span class="language-xml">  →   </span><span class="hljs-keyword">^1.0.1</span><span class="language-xml"></span><br><span class="language-xml">react-bootstrap  </span><span class="hljs-keyword">^0.22.6</span><span class="language-xml">  →  </span><span class="hljs-keyword">^0.24.0</span><span class="language-xml"></span><br><span class="language-xml">react-a11y        </span><span class="hljs-keyword">^0.1.1</span><span class="language-xml">  →   </span><span class="hljs-keyword">^0.2.6</span><span class="language-xml"></span><br><span class="language-xml">webpack          ~</span><span class="hljs-number">1.9</span><span class="hljs-number">.10</span><span class="language-xml">  →  ~</span><span class="hljs-number">1.10</span><span class="hljs-number">.5</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">Run ncu -u to upgrade package.json</span><br><span class="language-xml">复制代码</span><br></code></pre></td></tr></table></figure><p>使用 <code>ncu --doctor</code>，在升级每一个依赖时会对项目进行测试，如果测试通过则安装依赖成功，否则回退到原先版本</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ ncu --doctor -<span class="hljs-keyword">u</span><br>npm install<br>npm <span class="hljs-keyword">run</span> <span class="hljs-keyword">test</span><br>ncu -<span class="hljs-keyword">u</span><br>npm install<br>npm <span class="hljs-keyword">run</span> <span class="hljs-keyword">test</span><br>Failing tests found:<br>/projects/myproject/<span class="hljs-keyword">test</span>.js:13<br>  throw new <span class="hljs-keyword">Error</span>(&#x27;<span class="hljs-keyword">Test</span> failed!&#x27;)<br>  ^<br>Now let&#x27;s identify the culprit, shall we?<br>Restoring package.json<br>Restoring package-lock.json<br>npm install<br>npm install --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">save</span> react@16.0.0<br>npm <span class="hljs-keyword">run</span> <span class="hljs-keyword">test</span><br>  ✓ react 15.0.0 → 16.0.0<br>npm install --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">save</span> react-redux@7.0.0<br>npm <span class="hljs-keyword">run</span> <span class="hljs-keyword">test</span><br>  ✗ react-redux 6.0.0 → 7.0.0<br>Saving partially upgraded package.json<br>复制代码<br></code></pre></td></tr></table></figure><p>在 npm script 中进行配置 ncu:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;ncu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ncu&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="Audit-你的依赖存在安全风险"><a href="#Audit-你的依赖存在安全风险" class="headerlink" title="Audit: 你的依赖存在安全风险"></a>Audit: 你的依赖存在安全风险</h2><p>当某一个 package 存在安全风险时，这时候就要小心了，毕竟谁也不想自己的网站被攻击。唯一的解决办法就是 package 升级版本。就像 Github 的机器人这样:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6d03c707b22467da3ecfd3398d8c740~tplv-k3u1fbpfcp-zoom-1.image"></p><p>那使用 ncu 把所有依赖包升级到最新还会有安全风险吗？</p><p>会有，因为 ncu 只会把 package.json 中的依赖升级到最新，而不会把 lock file 中的依赖升级到最新。</p><p><code>npm audit</code> 可以发现项目中的风险库，并使用 <code>npm audit fix</code> 进行修复。</p><p>然而美中不足，<code>npm audit</code> 的精准度没有 <code>yarn audit</code> 高。</p><p>再美中不足，<code>yarn audit</code> 并不支持 <code>yarn audit fix</code> 自动修复</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> audit<br><br>$ <span class="hljs-built_in">npm</span> audit fix<br>复制代码<br></code></pre></td></tr></table></figure><p><code>snyk</code> 是一个检查包风险的一个服务，他提供了命令行工具检测风险，可以使用它代替 <code>npm audit</code>。他也有缺陷，依赖一个服务，可以根据容器自建或者使用 SASS。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> &#123;<br>    <span class="hljs-string">&quot;audit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;snyk test&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;audit:fix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;snyk protect&quot;</span><br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="Size-控制你的-bundle-大小"><a href="#Size-控制你的-bundle-大小" class="headerlink" title="Size: 控制你的 bundle 大小"></a>Size: 控制你的 bundle 大小</h2><p><a href="https://github.com/ai/size-limit/">size limit</a> 与 <a href="https://github.com/siddharthkp/bundlesize">bundle size</a> 都是可以控制 bundle 体积的两个工具，不过 size-limit 对启动时间也有更强的支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  &quot;scripts&quot;: &#123;<br>    &quot;size&quot;: <span class="hljs-string">&quot;size-limit&quot;</span>,<br>    <span class="hljs-string">&quot;analyze&quot;</span>: <span class="hljs-string">&quot;size-limit --why&quot;</span><br>  &#125;,<br>  &quot;size-limit&quot;: [<br>    &#123;<br>      &quot;<span class="hljs-selector-tag">path</span>&quot;: <span class="hljs-string">&quot;dist/promise-utils.cjs.production.min.js&quot;</span>,<br>      <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-string">&quot;10 KB&quot;</span><br>    &#125;,<br>    &#123;<br>      &quot;<span class="hljs-selector-tag">path</span>&quot;: <span class="hljs-string">&quot;dist/promise-utils.esm.js&quot;</span>,<br>      <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-string">&quot;10 KB&quot;</span><br>    &#125;<br>  ]<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在工作中高效使用 npm script，可以极高效率与代码质量，本文中涉及到的 package 如下所示</p><ul><li><a href="https://npm.devtool.tech/husky">husky</a></li><li><a href="https://npm.devtool.tech/mocha">mocha</a></li><li><a href="https://npm.devtool.tech/nyc">nyc</a></li><li><a href="https://npm.devtool.tech/cypress">cypress</a></li><li><a href="https://npm.devtool.tech/puppeteer">puppeteer</a></li><li><a href="https://npm.devtool.tech/storybook">storybook</a></li><li><a href="https://npm.devtool.tech/prettier">prettier</a></li><li><a href="https://npm.devtool.tech/eslint">eslint</a></li><li><a href="https://npm.devtool.tech/markdownlint">markdownlint</a></li><li><a href="https://npm.devtool.tech/@commitlint/cli">@commitlint&#x2F;cli</a></li><li><a href="https://npm.devtool.tech/lint-staged">lint-staged</a></li><li><a href="https://npm.devtool.tech/husky">husky</a></li><li><a href="https://npm.devtool.tech/npm-check-updates">npm-check-updates</a></li><li><a href="https://npm.devtool.tech/lerna">lerna</a></li><li><a href="https://npm.devtool.tech/size-limit">size-limit</a></li><li><a href="https://npm.devtool.tech/bundle-size">bundle-size</a></li></ul><p>你可以在 <a href="https://npm.devtool.tech/">npm devtool</a> 中找到更多有趣有用的库</p>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端优化详解以及需要关注的几个问题</title>
    <link href="/2020/11/02/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/02/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前端优化是一个大的课题，需要花好多时间才能理解，之前对前端优化陆陆续续有一些了解。所以这次从渲染优化，打包优化，代码优化做了一个系统的总结，并且引申出了几个需要关注的问题，文章可能有点长，大家一定要看到最后。最后写作不易，希望觉得还可以的话，帮忙点赞一波，提前感谢了。当然如果有写不好的地方，也请指出来，我会积极改进，共同成长。渲染优化"><a href="#前端优化是一个大的课题，需要花好多时间才能理解，之前对前端优化陆陆续续有一些了解。所以这次从渲染优化，打包优化，代码优化做了一个系统的总结，并且引申出了几个需要关注的问题，文章可能有点长，大家一定要看到最后。最后写作不易，希望觉得还可以的话，帮忙点赞一波，提前感谢了。当然如果有写不好的地方，也请指出来，我会积极改进，共同成长。渲染优化" class="headerlink" title="前端优化是一个大的课题，需要花好多时间才能理解，之前对前端优化陆陆续续有一些了解。所以这次从渲染优化，打包优化，代码优化做了一个系统的总结，并且引申出了几个需要关注的问题，文章可能有点长，大家一定要看到最后。最后写作不易，希望觉得还可以的话，帮忙点赞一波，提前感谢了。当然如果有写不好的地方，也请指出来，我会积极改进，共同成长。渲染优化"></a>前端优化是一个大的课题，需要花好多时间才能理解，之前对前端优化陆陆续续有一些了解。所以这次从渲染优化，打包优化，代码优化做了一个系统的总结，并且引申出了几个需要关注的问题，文章可能有点长，大家一定要看到最后。最后写作不易，希望觉得还可以的话，帮忙点赞一波，提前感谢了。当然如果有写不好的地方，也请指出来，我会积极改进，共同成长。<br><span id="more"></span><br>渲染优化</h1><p>渲染优化是前端优化中一个很重要的部分，一个好的首屏时间能给用户带来很好的体验，这里要说的一点是关于首屏时间的定义，不同的团队对首屏时间定义不一样，有的团队认为首屏时间就是白屏时间，是从页面加载到第一个画面出现的时间。但是当我们说到用户体验的时候，仅仅是这样还达不到效果，所以有的前端团队认为，首屏时间应该是从页面加载到用户可以进行正常的页面操作时间，那么我们就依照后者来进行说明</p><h2 id="js-css-加载顺序"><a href="#js-css-加载顺序" class="headerlink" title="js css 加载顺序"></a>js css 加载顺序</h2><p>说渲染优化之前，我们还需要说一个小插曲，就是比较经典的一道问题 “浏览器地址栏输入 url 发生了什么”，理解了这个我们才可以更清楚 js,css 加载顺序对渲染的影响</p><h3 id="问题-1：地址栏输入-url-发生了什么"><a href="#问题-1：地址栏输入-url-发生了什么" class="headerlink" title="问题 1：地址栏输入 url 发生了什么"></a>问题 1：地址栏输入 url 发生了什么</h3><p>这个问题经常被人提起，有人回答比较简洁点，有人可能回答的比较详细，下面就说一下主要流程</p><ul><li>首先会进行 url 解析，根据 dns 系统进行 ip 查找</li><li>根据 ip 就可以找到服务器，然后浏览器和服务器会进行 TCP 三次握手建立连接，如果此时是 https 的话，还会建立 TLS 连接以及协商加密算法，这里就会出现另一个需要注意的问题 “https 和 http 的区别”（下文会讲到）</li><li>连接建立之后浏览器开始发送请求获取文件，此时这里还会出现一种情况就是缓存，建立连接后是走缓存还是直接重新获取，需要看后台设置，所以这里会有一个关注的问题 “浏览器缓存机制”，缓存我们等会在讲，现在我们就当没有缓存，直接去获取文件</li><li>首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点</li><li>好了解析到 html 头部时候，又会出现一种问题，css,js 放到哪里了？不同的位置会造成渲染的不同，此时就会出现另一个需要关注的问题 “css,js 位置应该放哪里? 为什么”，我们先按照正确的位置来说明 (css 放头部, js 放尾部)</li><li>解析到了 html 头部发现有 css 文件，此时下载 css 文件，css 文件也是一边下载一边解析的，构建的是 CSSOM 树，当 DOM 树和 CSSOM 树全部构建完之后，浏览器会把 DOM 树和 CSSOM 树构建成渲染树。</li><li>样式计算, 上面最后一句 “DOM 树和 CSSOM 树会一起构建成渲染树” 说的有点笼统，其实还有更细一点的操作，但是一般回答到上面应该就可以了，我们现在接上面说一下构造渲染树的时候还做了哪些事情。第一个就是样式计算，DOM 树 和 CSSOM 树有了之后，浏览器开始样式计算，主要是为 DOM 树上的节点找到对应的样式</li><li>构建布局树，样式计算完之后就开始构建布局树。主要是为 DOM 树上的节点找到页面上对应位置以及一些 “display:none” 元素的隐藏。</li><li>构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，z-index，position 这些复杂的分层操作</li><li>将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染</li><li>最终渲染进程将整个页面渲染出来，在渲染的过程中会还出现重排和重绘，这也是比较爱问的问题 “重排重绘为什么会影响渲染，如何避免?”</li><li>以上过程大概讲解了一下从 url 到页面渲染的整个过程，其实涉及到了几个需要关注的问题，下面来具体讲讲</li></ul><h3 id="问题-2：js-css-顺序对前端优化影响"><a href="#问题-2：js-css-顺序对前端优化影响" class="headerlink" title="问题 2：js css 顺序对前端优化影响"></a>问题 2：js css 顺序对前端优化影响</h3><p>上面我们说到了整个渲染流程，但是没有说到 css 和 js 对渲染的影响。渲染树的构成必须要 DOM 树和 CSSOM 树的，所以尽快的构建 CSSOM 树是一个重要的优化手段，如果 css 文件放在尾部，那么整个过程就是一个串行的过程先解析了 dom，再去解析 css。所以 css 我们一般都是放在头部，这样 DOM 树和 CSSOM 树的构建是同步进行的。</p><p>再来看 js，因为 js 的运行会阻止 DOM 树的渲染的，所以一旦我们的 js 放在了头部，而且也没有异步加载这些操作的话，js 一旦一直在运行，DOM 树就一直构建不出来，那么页面就会一直出现白屏界面，所以一般我们会把 js 文件放在尾部。当然放到尾部也不是就没有问题了，只是问题相对较小，放到尾部的 js 文件如果过大，运行时间长，代码加载时，就会有大量耗时的操作造成页面不可点击，这就是另一个问题，但这肯定比白屏要好，白屏是什么页面都没有，这种是页面有了只是操作不流畅。</p><p>js 脚本放在尾部还有一个原因，有时候 js 代码会有操作 dom 节点的情况，如果放在头部执行，DOM 树还没有构建，拿不到 DOM 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉</p><h3 id="问题-3：重排重绘为什么会影响渲染，如何避免"><a href="#问题-3：重排重绘为什么会影响渲染，如何避免" class="headerlink" title="问题 3：重排重绘为什么会影响渲染，如何避免?"></a>问题 3：重排重绘为什么会影响渲染，如何避免?</h3><p>重排和重绘为什么会影响渲染，哪个影响更大，如何避免是经常被问到的一道题目，我们先来说一下重绘</p><ul><li><p>重绘</p><p>重绘指的是不影响界面布局的操作，比如更改颜色，那么根据上面的渲染讲解我们知道，重绘之后我们只需要在重复进行一下样式计算，就可以直接渲染了，对浏览器渲染的影响相对较小</p></li><li><p>重排</p><p>重排指的是影响界面布局的操作，比如改变宽高，隐藏节点等。对于重排就不是一个重新计算样式那么简单了，因为改变了布局，根据上面的渲染流程来看涉及到的阶段有样式计算，布局树重新生成，分层树重新生成，所以重排对浏览器的渲染影响是比较高的</p></li><li><p>避免方法</p><ul><li>js 尽量减少对样式的操作，能用 css 完成的就用 css</li><li>对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用</li><li>如果必须要用 js 操作样式，能合并尽量合并不要分多次操作</li><li>resize 事件 最好加上防抖，能尽量少触发就少触发</li><li>加载图片的时候，提前写好宽高</li></ul></li></ul><h3 id="问题-4：浏览器缓存机制"><a href="#问题-4：浏览器缓存机制" class="headerlink" title="问题 4：浏览器缓存机制"></a>问题 4：浏览器缓存机制</h3><p>浏览器缓存是比较常见的问题，我会从浏览器缓存的方式，缓存的实现， 缓存在哪里这几个点来说明</p><h4 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h4><p>我们经常说的浏览器缓存有两种，一种是强制缓存，一种是协商缓存，因为下面有具体实现讲解，所以这里就说一下概念</p><ul><li><p>协商缓存</p><p>协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头 &#x2F; 响应头的字段设置，下面会说到。需要注意的是协商缓存还是发了请求的</p></li><li><p>强制缓存</p><p>强制缓存就是文件直接从缓存中获取，不需要发送请求</p></li></ul><h4 id="缓存实现"><a href="#缓存实现" class="headerlink" title="缓存实现"></a>缓存实现</h4><ul><li>强制缓存</li></ul><p>强制缓存在 http1.0 的时候用的是 Expires，是响应头里面的一个字段表示的是文件过期时间。是一个绝对时间，正因为是绝对时间所以在某些情况下，服务器的时区和浏览器时区不一致的时候就会导致缓存失效。为了解决这个问题，HTPP1.1 引入了一个新的响应头 cache-control 它的可选值如下</p><h5 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h5><ul><li>max-age: 缓存过期时间，是一个相对时间</li><li>public: 表示客户端和代理服务器都会缓存</li><li>private: 表示只在客户端缓存</li><li>no-cache: 协商缓存标识符，表示文件会被缓存但是需要和服务器协商</li><li>no-store: 表示文件不会被缓存</li></ul><p>HTTP1.1 利用的就是 max-age:600 来强制缓存，因为是相对时间，所以不会出现 Expires 问题</p><ul><li><p>协商缓存</p><p>协商缓存是利用 Last-Modified&#x2F;if-Modified-Since,Etag&#x2F;if-None-Match 这两对请求、响应头。</p><h5 id="Last-Modified-if-Modified-Since"><a href="#Last-Modified-if-Modified-Since" class="headerlink" title="Last-Modified&#x2F;if-Modified-Since"></a>Last-Modified&#x2F;if-Modified-Since</h5><ul><li>浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个 if-Modified-Since，记录被改动的时间</li><li>浏览器第二次发送请求的时候会带上一个 Last-Modified 请求头，时间就是 if-Modified-Since 返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回 304 从缓存里面获取文件</li></ul><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag&#x2F;If-None-Match"></a>Etag&#x2F;If-None-Match</h5><p>由于 Last-Modified 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以 HTTP1.1 又引入了 Etag 字段。这个字段是根据文件内容生成一个标记符比如 “W&#x2F;“5f9583bd-10a8””，然后再和 If-None-Match 进行对比就能更准确的知道文件有没有被改动过</p></li></ul><h4 id="缓存在哪里"><a href="#缓存在哪里" class="headerlink" title="缓存在哪里"></a>缓存在哪里</h4><p>知道了缓存方式和实现，再来说一下缓存存在哪个地方，我们打开掘金可以看到如下的信息 。缓存的来源有两个地方 from dist cache,from memeory cache <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea768e22b4ba4f37ad62c8e11cf9b31b~tplv-k3u1fbpfcp-watermark.image"></p><h5 id="form-memory-cache"><a href="#form-memory-cache" class="headerlink" title="form memory cache"></a>form memory cache</h5><p>这个是缓存在内存里面，优点是快速，但是具有时效性，当关闭 tab 时候缓存就会失效。</p><h5 id="from-dist-cache"><a href="#from-dist-cache" class="headerlink" title="from dist cache"></a>from dist cache</h5><p>这个是缓存在磁盘里面，虽然慢但是还是比请求快，优点是缓存可以一直被保留，即使关闭 tab 页，也会一直存在</p><h5 id="何时缓存在-memory-合适缓存在-dist？"><a href="#何时缓存在-memory-合适缓存在-dist？" class="headerlink" title="何时缓存在 memory, 合适缓存在 dist？"></a>何时缓存在 memory, 合适缓存在 dist？</h5><p>这个问题网上很少找的到标准答案，大家一致的说法是 js, 图片文件浏览器会自动保存在 memory 中，css 文件因为不常修改保存在 dist 里面，我们可以打开掘金网站，很大一部分文件都是按照这个规则来的，但是也有少数 js 文件也是缓存在 dist 里面。所以他的存放机制到底是什么样了？我带着这个疑问查了好多文章，虽然最后没有确切找到答案，但是一个知乎的回答可以给我们提供思路，下面引用一个知乎回答者一段话</p><ul><li><p>第一个现象 (以图片为例)：访问 -&gt; 200 -&gt; 退出浏览器再进来 -&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache)。总结: 会不会是 chrome 很聪明的判断既然已经从 disk 拿来了， 第二次就内存拿吧 快。（笑哭)</p></li><li><p>第二个现象 (以图片为例)：只要图片是 base64 我看都是 from memroy cache。 总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。 用的时候直接拿</p></li><li><p>第三个现象 (以 js css 为例)：个人在做静态测试的发现，大型的 js css 文件都是直接 disk cache。结: chrome 会不会说 我去 你这么大太占地方了。 你就去硬盘里呆着吧。 慢就慢点吧。</p></li><li><p>第四个现象：隐私模式下，几乎都是 from memroy cache。总结: 隐私模式 是吧。 我不能暴露你东西，还是放到内存吧。 你关，我死。</p></li></ul><p>上面几点是虽然很幽默，但是却可以从中找到一部分答案，但是我觉得另一个知乎回答我更赞同</p><blockquote><p>浏览器运行的时候也是由几个进程协作的，所以操作系统为了节省内存，会把一部分内存里的资源交换回磁盘的交换区，当然交换是有策略的，比如最常用的就是 LRU。</p></blockquote><p>什么时候存 dist，什么时候存 memoey 都是在浏览器控制下的，memory 不够了可能就会考虑去存 dist 了，所以经过上面所说我自己总结结果如下</p><ul><li>大一点的文件会缓存在 dist 里面，因为内存也是有限的，磁盘的空间更大</li><li>小一点文件 js, 图片存的是 memory</li><li>css 文件一般存在 dist</li><li>特殊情况 memory 大小是有限制的，浏览器也会根据自己的内置算法，把一部分 js 文件存到 dist 里面</li></ul><h3 id="问题-5：https-和-http-的区别"><a href="#问题-5：https-和-http-的区别" class="headerlink" title="问题 5：https 和 http 的区别"></a>问题 5：https 和 http 的区别</h3><p>说到 https 和 http 的区别，可以说一下 https 服务器和客户端连接的差异，以及 https 特定的加密算法协商，甚至可能还要说到对称加密，非对称加密和证书等，篇幅很长，请看我之前单独写的一篇 <a href="https://juejin.im/post/6855969722246037518">https 详解</a>，里面讲的非常详细。</p><h2 id="请求优化"><a href="#请求优化" class="headerlink" title="请求优化"></a>请求优化</h2><p>讲请求优化的之前先来总结下上面说到的 js, css 文件顺序优化，为了让渲染更快，我们需要把 js 放到尾部，css 放到头部，然后还要注意在书写 js 的时候尽量减少重排，重绘。书写 html,css 的时候尽量简洁，不要冗余，目的是为了更快的构建 DOM 树和 CSSOM 树。好了下面我们在来说说请求优化，请求优化可以从请求数量和请求时间两方面入手</p><h3 id="减少请求数量"><a href="#减少请求数量" class="headerlink" title="减少请求数量"></a>减少请求数量</h3><ul><li>将小图片打包成 base64</li><li>利用雪碧图融合多个小图片</li><li>利用缓存上面已经说到过</li></ul><h3 id="减少请求时间"><a href="#减少请求时间" class="headerlink" title="减少请求时间"></a>减少请求时间</h3><ul><li>将 js，css，html 等文件能压缩的尽量压缩，减少文件大小，加快下载速度</li><li>利用 webpack 打包根据路由进行懒加载，不要初始就加载全部，那样文件会很大</li><li>能升级到高版本的 http 就升级到高版本（这个回答是套话），为什么高版本能提高速度具体看上面我说的那篇 https 文章</li><li>建立内部 CDN 能更快速的获取文件</li></ul><h1 id="webpack-优化"><a href="#webpack-优化" class="headerlink" title="webpack 优化"></a>webpack 优化</h1><p>介绍了渲染优化，现在来看看 webpack 优化，自己平常写 demo 给团队做培训的时候都是自己手写 webpack 配置，虽然也就几十行，但每次都能让我巩固 webpack 的基本配置，下面直接说一下 webpack 优化手段有哪些</p><h2 id="基础配置优化"><a href="#基础配置优化" class="headerlink" title="基础配置优化"></a>基础配置优化</h2><ul><li>extensions</li></ul><p>这个配置是属于 resolve 里面的，经常用来对文件后缀进行扩展, 写法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.ts&#x27;</span>, <span class="hljs-string">&#x27;.tsx&#x27;</span>, <span class="hljs-string">&#x27;.js&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>这个配置表示 webpack 会根据 extensions 去寻找文件后缀名，所以如果我们的项目主要用 ts 写的话，那我们就可以. tsx 和. ts 写前面，目的是为了让 webpack 能够快速解析</p><ul><li>alias</li></ul><p>这个配置也是属于 resolve 里面的，是用来映射路劲，能减少打包时间的主要原因是能够让 webpack 快速的解析文件路径，找到对应的文件，配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">resolve</span>: &#123;<br>  <span class="hljs-attr">alias</span>: &#123;<br>    <span class="hljs-title class_">Components</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./src/components&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>noParse</li></ul><p>noParse 表示不需要解析的文件，有的文件可能是来自第三方的文件，被 providePlugin 引入作为 windows 上的变量来使用，这样的文件相对比较大，并且已经是被打包过的，所以把这种文件排除在外是很有必要的，配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>  <span class="hljs-attr">noParse</span>: [<span class="hljs-regexp">/proj4.js/</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exclude</li></ul><p>某些 loader 会有这样一个属性，目的是指定 loader 作用的范围，exclude 表示排除某些文件不需要 babel-loader 处理，loader 的作用范围小了，打包速度自然就快了，用 babel-loader 举一个简单例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>    <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>    <span class="hljs-attr">exclude</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;node_modules&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>devtool</li></ul><p>这个配置是一个调试项，不同的配置展示效果不一样，打包大小和打包速度也不一样，比如开发环境下 cheap-source-map 肯定比 source-map 快，至于为什么，强烈推荐自己之前写的这一篇讲解 devtool 的文章：<a href="https://juejin.im/post/6887750775368499207">webpack devtools 篇</a>讲的非常详细。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;cheap-source-map&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>.eslintignore</p><p>这个虽不是 webpack 配置但是对打包速度优化还是很有用的，在我的实践中 eslint 检查对打包的速度影响很大，但是很多情况我们不能没有这个 eslint 检查，eslint 检查如果仅仅在 vs 里面开启的话，可能不怎么保险。</p><p>因为有可能你 vs 中的 eslint 插件突然关闭了或者某些原因 vs 不能检查了，只能靠 webpack 构建去帮你拦住错误代码的提交，即使这样还不能确保万无一失，因为你可能某一次提交代码很急没有启动服务，直接盲改提交上去了。这个时候只能通过最后一道屏障给你保护，就是在 CI 的时候。比如我们也会是在 jenkins 构建的时候帮你进行 eslint 检查，三道屏障确保了我们最终出的镜像是不会有问题的。</p><p>所以 eslint 是很重要的，不能删掉，在不能删掉的情况下怎么让检查的时间更少了，我们就可以通过忽略文件，让不必要的文件禁止 eslint, 只对需要的文件 eslint 可以很大程度提高打包速度</p><h2 id="loader-plugins-优化"><a href="#loader-plugins-优化" class="headerlink" title="loader,plugins 优化"></a>loader,plugins 优化</h2><p>上述说了几个基础配置优化，应该还有其他的基础配置，今后遇到了再继续添加，现在在来讲讲利用某些 loader,plugins 来提高打包速度的例子</p><ul><li>cache-loader</li></ul><p>这个 loader 就是在第一次打包的时候会缓存打包的结果，在第二次打包的时候就会直接读取缓存的内容，从而提高打包效率。但是也需要合理利用，我们要记住一点你加的每一个 loader，plugins 都会带来额外的打包时间。这个额外时间比他带来的减少时间多，那么一味的增加这个 loader 就没意义，所以 cache-loader 最好用在耗时比较大的 loader 上，配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        <span class="hljs-string">&#x27;cache-loader&#x27;</span>,<br>        <span class="hljs-string">&#x27;vue-loader&#x27;</span><br>      ],<br>      <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./src&#x27;</span>)<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>webpack-parallel-uglify-plugin, uglifyjs-webpack-plugin, terser-webpack-plugin</li></ul><p>在上面的渲染优化中我们已经知道，文件越小渲染的速度是越快的。所以我们在配置 webpack 时候经常会用到压缩，但是压缩也是需要消耗时间的，所以我们我们经常会用到上面三个插件之一来开启并行压缩，减少压缩时间，我们用 webpack4 推荐使用的 terse-webpack-plugin 做例子来说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">optimization</span>: &#123;<br>  <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">cache</span>: <span class="hljs-literal">true</span><br>      &#125;)<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>happypack, parallel-webpack, thread-loader</li></ul><p>这几个 loader&#x2F;plugin 和上面一样也是开启并行的，只不过是开启并行构建。由于 happypack 的作者说自己的兴趣已经不再 js 上了，所以已经没有维护了，并推荐如果使用的是 webpack4 的话，就去使用 thread-loader。基本配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          &#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;thread-loader&quot;</span>,<br>            <span class="hljs-attr">options</span>: threadLoaderOptions<br>          &#125;,<br>          <span class="hljs-string">&quot;babel-loader&quot;</span>,<br>        ],<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>      &#125;<br></code></pre></td></tr></table></figure><ul><li>DllPlugin,webpack.DllReferencePlugin</li></ul><p>上面说的几个并行插件理论上是可以增加构建速度，网上很多文章都是这么说的，但是我在实际的过程中使用，发现有时候不仅没提升反而还降低了打包速度，网速查阅给的理由是可能你的电脑核数本来就低，或者当时你 CPU 运行已经很高了，再去开启多进程导致构建速度降低。</p><p>上面说的几个并行插件可能在某些情况下达不到你想要的效果，然而在我们团队优化 webpack 性能经验来看，这次所说的两个插件是很明显并且每次都能提高打包速度的。原理就是先把第三方依赖先打包一次生成一个 js 文件，然后真正打包项目代码时候，会根据映射文件直接从打包出来的 js 文件获取所需要的对象，而不用再去打包第三方文件。只不过这种情况打包配置稍微麻烦点，需要写一个 webpack.dll.js。大致如下</p><p>webpack.dll.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">library</span>: [<span class="hljs-string">&quot;vue&quot;</span>, <span class="hljs-string">&quot;moment&quot;</span>]<br>    &#125;,<br><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;json-dll&#x27;</span>),<br>        <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;[name]&#x27;</span><br>    &#125;,<br><br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllPlugin</span>(&#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;./json-dll/library.json&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[name].json&#x27;</span><br>        &#125;)<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>webpack.dev.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AddAssetHtmlWebpack</span>(&#123;<br>     <span class="hljs-attr">filepath</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./json-dll/library.dll.js&#x27;</span>)<br>  &#125;),<br><br> <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>(&#123;<br>      <span class="hljs-attr">manifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./json-dll/library.json&quot;</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure><h2 id="其他优化配置"><a href="#其他优化配置" class="headerlink" title="其他优化配置"></a>其他优化配置</h2><p>这些插件就简单的介绍下，在我的个人项目中已经使用过，自我感觉还可以，具体使用可以查阅 npm 或者 github</p><ul><li>webpack-bundle-analyzer</li></ul><p>这个插件可以用可视化帮我们分析打包体积，从而来采用合适的优化方式去改进我们的 webpack 配置</p><ul><li>speed-measure-webpack-plugin</li></ul><p>这个插件可以告诉我们打包时候每一个 loader 或者 plugin 花费了多少时间，从而对耗时比较长的 plugin 和 loader 做优化</p><ul><li>friendly-errors-webpack-plugin</li></ul><p>这个插件可以帮我们优化打包日志，我们打包时候经常看到很长一个日志信息，有的时候是不需要的，也不会去看所以可以用这个插件来简化</p><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><p>这是最后一部分代码优化了，这里的代码性能优化我只说我在工作中感受到的，至于其他的比较小的优化点比如 createDocumentFragment 使用可以查查其他文章</p><blockquote><p>能不操作 dom 不要操作 dom，哪怕有时候需要改设计</p></blockquote><p>很多情况下我们都能用 css 还原设计稿，但是有些时候单单从 css 没法还原，尤其组件还不是你写的时候，比如我们团队用的就是 antd, 有时候的产品设计单从 css 上没法实现，只能动用 js，删除，增加节点在配合样式才能完成。</p><p>由于我们又是一个做大数据的公司，这个时候就会出现性能问题，最开始写代码时候，产品说什么就是什么，说什么我都会想办法搞出来，不管用什么方法。后来到客户现场大数据请况下，性能缺点立马暴露的出来。</p><p>所以代码优化的原则之一我认为是能不写的代码就不写，当然这是要从性能角度出发，通过性能分析给产品说出理由，并且最好还能提供更好的解决方案，这个才是我们需要考虑的。</p><blockquote><p>如果用的是 react 一定用写 shouldComponentUpdate 这个生命周期函数，不然打印的时候你会发现，你自己都迷糊为什么执行了这么多遍</p></blockquote><blockquote><p>将复杂的比对，变成简单比对</p></blockquote><p>这句话是什么意思了？我们就拿 shouldComponentUpdate 举例子，用这个函数没问题，但是可以做的更好，我们在工作中经常这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextPrpops</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(nextPrpops.<span class="hljs-property">data</span>) !== <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">data</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是一个分页表格，data 是每一页数据，数据改变了重新渲染，在小数据场景下这本身是没有问题。但是如果在大数据的场景下可能会有问题，可能有人有疑问，既然做了分页怎么还会有大数据了，因为我们的产品是做大数据分析日志的，一页十条日志，有的日志可能非常的长，也就是说就算是 10 条数据比对起来也是很耗时，所以当时想法能不能找到其他的替代变量来表示数据变了？比如下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextPrpops</span>) &#123;<br>  <span class="hljs-keyword">return</span> nextPrpops.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>].<span class="hljs-property">id</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">data</span>[<span class="hljs-number">0</span>].<span class="hljs-property">id</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一条的 id 不一样就表示数据变化了行不行，显然在某种情况下是存在的，也有人会说可能会出现 id 一样，那如果换成下面这种了?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextPrpops</span>) &#123;<br>  <span class="hljs-keyword">return</span> nextPrpops.<span class="hljs-property">current</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">current</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将 data 的比对转换成了 current 的比对，因为页数变了，数据基本都是变了，对于我们自己日志的展示来说基本不存在两页数据是一模一样的，如果有那可能是后台问题。然后在好好思考这个问题，即使存在了两页数据一摸一样，顶多就是这个表格不重新渲染，但是两页数据一摸一样不重新渲染是不是也没有问题，因为数据是一样的。或者如果你还是不放心，那下面这种会不会好点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>  data,<br>  <span class="hljs-attr">requestId</span>: <span class="hljs-title function_">guid</span>()<br>&#125;)<br><br><span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextPrpops</span>) &#123;<br>  <span class="hljs-keyword">return</span> nextPrpops.<span class="hljs-property">requestId</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">requestId</span><br>&#125;<br></code></pre></td></tr></table></figure><p>给一个 requestId 跟宗 data，后面就只比对 requestId。上面的写法可能都有问题，但是主要是想说的是我们在写代码时候可以想想是不是可以 “将复杂的比对，变成简单比对”</p><blockquote><p>学习数据结构和算法，一定会在你的工作中派上用场</p></blockquote><p>我们经常会听到学习数据结构和算法没有什么大的用处，因为工作基本用不上。这句话我之前觉得没错，现在看来错的很严重。我们所学的每一样技能，都会在将来的人生中派上用场。之前写完代码就丢了不去优化所以我觉得算法没意义，又难又容易忘记。但现在要求自己做完需求，开启 mock，打开 perfermance 进行大数据量的测试，看着那些标红的火焰图和肉眼可见的卡顿，就明白了算法和数据结构的重要性，因为此时你只能从它身上获取优化，平时你很排斥它，到优化的时候你是那么想拥有它。我拿自己之前写的代码举例，由于公司代码是保密的我就把变量换一下，伪代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">&#123;id&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> selectedIds.<span class="hljs-title function_">includes</span>(id);<br>&#125;)<br></code></pre></td></tr></table></figure><p>就是这样几行代码，逻辑就是筛选出 data 里面已经被勾选的数据。基本上很多人都可能这么写，因为我看我们团队里面都是这么写的。产品当时已经限制 data 最多 200 数据，所以写完完全没压力，性能没影响。但是秉着对性能优化的原则（主要是被现场环境搞怕了~~~），我开启了 mock 服务，将数据调到了 2 万条再去测试，代码弊端就暴露出来了，界面进入卡顿，重新选择的时候也会卡顿。然后就开始了优化，当时具体的思路如下</p><p>按照现在的代码来看，这是一个两层循环的暴力搜索时间复杂度为 O(n^2)。所以想着能不能降一下复杂度至少是 O(nlogn)，看了一下代码只能从 selectedIds.includes(id) 这句入手，于是想着可不可以用二分，但是立马被否定因为二分是需要有序的，我这数组都是字符串怎么二分。</p><p>安静了一下之后，回想起看过的算法课程和书籍以及做的算法题，改变暴力搜索的方法基本都是</p><p>1：上指针</p><p>2： 数组升维</p><p>3：利用 hash 表</p><p>前两者被我否定了因为我觉得还没那么复杂，于是利用 hash 表思想解决这个问题，因为 js 里面有一个天然的 hash 表结构就是对象。我们知道 hash 表的查询是 O(1) 的，所以我将代码改写如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ids = &#123;&#125;;<br>selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> ids[id] = <span class="hljs-number">1</span>);<br><br>data.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">&#123;id&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> !!ids[id];<br>&#125;)<br></code></pre></td></tr></table></figure><p>将从 selectedIds 查询变成从 ids 查询，这样时间复杂度就从 O(n^2) 变成了 O(n) 了，这段代码增加了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ids = &#123;&#125;;<br>selectedIds.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> ids[id] = <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>其实增加了一个 selectedIds 遍历也是一个 O(n) 的复杂度，总来说复杂度是 O(2n), 但是从时间复杂度长期期望来看还是一个 O(n) 的时间复杂度，只不过额外增加了一个对象，所以这也是一个典型的空间换时间的例子，但是也不要担心，ids 用完之后垃圾回收机制会把他回收的。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实这篇文章写出来还是对自己帮助很大，让自己系统的梳理了一下自己理解的前端优化，希望对你们也有帮助。<br>原文地址 <a href="https://juejin.im/post/6888848660591968264?utm_source=gold_browser_extension">juejin.im</a></p>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Animation</title>
    <link href="/2020/10/30/Animation/"/>
    <url>/2020/10/30/Animation/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 web 应用中，前端同学在实现动画效果时往往常用的几种方案：</p><ol><li>css3 transition &#x2F; animation - 实现过渡动画</li><li>setInterval &#x2F; setTimeout - 通过设置一个间隔时间来不断的改变图像的位置</li><li>requestAnimationFrame - 通过一个回调函数来改变图像位置，由系统来决定这个回调函数的执行时机，比定时修改的性能更好，不存在失帧现象<span id="more"></span>在大多数需求中，css3 的 <code>transition / animation</code> 都能满足我们的需求，并且相对于 js 实现，可以大大提升我们的开发效率，降低开发成本。</li></ol><p>本篇文章将着重对 <code>animation</code> 的使用做个总结，如果你的工作中动画需求较多，相信本篇文章能够让你有所收获：</p><ul><li>Animation 常用动画属性</li><li>Animation 实现不间断播报</li><li>Animation 实现回弹效果</li><li>Animation 实现直播点赞效果 ❤️</li><li>Animation 与 Svg 又会擦出怎样的火花呢？🔥<ol><li>Loading 组件</li><li>进度条组件</li></ol></li><li>Animation steps() 运用 ⏰<ol><li>实现打字效果</li><li>绘制帧动画</li></ol></li></ul><h2 id="Animation-常用动画属性"><a href="#Animation-常用动画属性" class="headerlink" title="Animation 常用动画属性"></a>Animation 常用动画属性</h2><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b7d4949a6f4359b1ca1e4c41ffde52~tplv-k3u1fbpfcp-zoom-1.image"></p><p>介绍完 animation 常用属性，为了将这些属性更好地理解与运用，下面将手把手实现一些 DEMO 具体讲述</p><h2 id="Animation-实现不间断播报"><a href="#Animation-实现不间断播报" class="headerlink" title="Animation 实现不间断播报"></a>Animation 实现不间断播报</h2><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a7915f454904b8288715829d6fa74d8~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/wvMGEaY">实现不间断播报 DEMO</a></p><p>通过修改内容在父元素中的 y 轴的位置来实现广播效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> scroll &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, -$height);<br>  &#125;<br>&#125;<br><br><span class="hljs-selector-class">.ul</span> &#123;<br>  <span class="hljs-attribute">animation-name</span>: scroll;<br>  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">5s</span>;<br>  <span class="hljs-attribute">animation-timing-function</span>: linear;<br>  <span class="hljs-attribute">animation-iteration-count</span>: infinite;<br>  <span class="hljs-comment">/* animation: scroll 5s linear infinite; 动画属性简写 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此处为了保存广播滚动效果的连贯性，防止滚动到最后一帧时没有内容，<strong>需要多添加一条重复数据进行填充</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;li&quot;</span>&gt;</span>小刘同学加入了凹凸实验室<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;li&quot;</span>&gt;</span>小邓同学加入了凹凸实验室<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;li&quot;</span>&gt;</span>小李同学加入了凹凸实验室<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;li&quot;</span>&gt;</span>小王同学加入了凹凸实验室<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!--   插入用于填充的数据数据 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;li&quot;</span>&gt;</span>小刘同学加入了凹凸实验室<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Animation-实现回弹效果"><a href="#Animation-实现回弹效果" class="headerlink" title="Animation 实现回弹效果"></a>Animation 实现回弹效果</h2><p>通过将过渡动画拆分为多个阶段，每个阶段的 top 属性停留在不同的位置来实现</p><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fdd4e788d28429f88e821c6849bc849~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/NWxNMpm">实现回弹效果 DEMO</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 规定动画，改变top,opacity */</span><br><span class="hljs-keyword">@keyframes</span> animate &#123;<br>  <span class="hljs-number">0%</span> &#123;<br>    <span class="hljs-attribute">top</span>: -<span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-number">25%</span> &#123;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">60</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-number">50%</span> &#123;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">48%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-number">75%</span> &#123;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">52%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了让过渡效果更自然，这里通过 <code>cubic-bezier()</code> 函数定义一个贝塞尔曲线来控制动画播放速度</p><p>过渡动画执行完后，为了将让元素应用动画最后一帧的属性值，我们需要使用 <code>animation-fill-mode: forwards</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.popup</span> &#123;<br>  <span class="hljs-attribute">animation-name</span>: animate;<br>  <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">0.5s</span>;<br>  <span class="hljs-attribute">animation-timing-function</span>: <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.21</span>, <span class="hljs-number">0.85</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">animation-iteration-count</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">animation-fill-mode</span>: forwards;<br>  <span class="hljs-comment">/* animation: animate 0.5s cubic-bezier(0.21, 0.85, 1, 1) 1 forwards; 动画属性简写 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Animation-实现点赞效果-Online-Code"><a href="#Animation-实现点赞效果-Online-Code" class="headerlink" title="Animation 实现点赞效果 Online Code"></a>Animation 实现点赞效果 <a href="https://codepen.io/awesomedevin/pen/dyGXEar">Online Code</a></h2><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17be14f86344551890ac906d003e79d~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/dyGXEar">实现点赞效果 DEMO</a></p><p>相信大多数同学都知道点赞效果，本文章会实现一个简易版的点赞效果，主要讲述一下实现思路：</p><ol><li>为了让气泡可以向上偏移，我们需要先实现一个 y 轴方向上移动的 @keyframes 动画</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 规定动画，改变y轴偏移距离*/</span><br><span class="hljs-keyword">@keyframes</span> animation-y &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>   <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, <span class="hljs-number">100px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-number">50%</span>&#123;<br>   <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">100px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">300px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>为了让气泡向上偏移时显得不太单调，我们可以再实现一个 x 轴方向上移动的 @keyframes 动画</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 规定动画，改变x轴偏移距离 */</span><br><span class="hljs-keyword">@keyframes</span> animation-x &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0px</span>;<br>  &#125;<br>  <span class="hljs-number">25%</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">25px</span>;<br>  &#125;<br>  <span class="hljs-number">75%</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">25px</span>;<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">0px</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我理解：</p><ul><li>虽然是<code>修改 margin</code> 来改变 x 轴偏移距离，但实际上与<code>修改 transform</code>没有太大的性能差异</li><li>因为通过 <code>@keyframes animation-y</code> 中的 <code>transform</code> 已经新建了一个<code>渲染层 ( PaintLayers )</code></li><li><code>animation</code> 属性 可以让该渲染层提升至 <code>合成层(Compositing Layers)</code> 拥有单独的<code>图形层 ( GraphicsLayer )</code>，即开启了硬件加速 ，不会影响其他渲染层的 <code>paint、layout</code></li><li>对于<code>合成层(Compositing Layers)</code>相关知识不是很了解的同学，可以阅读一下这篇文章<a href="/notes/2020/10/13/css3-optimization/">从浏览器渲染层面解析 css3 动效优化原理</a></li><li>如下图所示：</li></ul><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c45e9a2298476e8e771e658f9cc049~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如笔者这里理解有误，还请读者大佬指出，感激不尽~</p><ol start="3"><li>给气泡应用上我们所实现的两个 @keyframes 动画</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.bubble &#123;<br>  <span class="hljs-built_in">animation</span>: <span class="hljs-built_in">animation</span>-x 3s -2s <span class="hljs-built_in">linear</span> infinite,<span class="hljs-built_in">animation</span>-y 4s <span class="hljs-number">0s</span> <span class="hljs-built_in">linear</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*  给 bubble 开启了硬件加速 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>在点赞事件中，通过 js 操作动态添加 &#x2F; 移除气泡元素</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">like</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> likeDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>  likeDom.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;bubble&#x27;</span>; <span class="hljs-comment">// 添加样式</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(likeDom);  <span class="hljs-comment">// 添加元素</span><br>  <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(likeDom);  <span class="hljs-comment">// 移除元素</span><br>  &#125;, <span class="hljs-number">4000</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Animation-与-Svg-绘制-loading-进度条-组件-🔥-Online-Code"><a href="#Animation-与-Svg-绘制-loading-进度条-组件-🔥-Online-Code" class="headerlink" title="Animation 与 Svg 绘制 loading &#x2F; 进度条 组件 🔥 Online Code"></a>Animation 与 Svg 绘制 loading &#x2F; 进度条 组件 🔥 <a href="https://codepen.io/awesomedevin/pen/zYromBB">Online Code</a></h2><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a4b87811a4649778ffb037251966c72~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/zYromBB">Animation 与 Svg 绘制 loading &#x2F; 进度条 组件 🔥 DEMO</a></p><ol><li>首先，我们使用 svg 绘制一个圆周长为<code>2 * 25 * PI = 157</code> 的圆</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">with</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 100 100&quot;</span>  &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;25&quot;</span>  <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;transparent&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#0079f5&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circie</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85a594bc93884e59a3bf1d353fd888f9~tplv-k3u1fbpfcp-zoom-1.image"></p><ol start="2"><li>将实线圆绘制成虚线圆，这里需要用 <code>stoke-dasharray:50, 50 (可简写为50)</code> 属性来绘制虚线, <a href="https://www.cnblogs.com/daisygogogo/p/11044353.html">stoke-dasharray 参考资料</a></li></ol><ul><li>它的值是一个数列，数与数之间用逗号或者空白隔开，指定<code>短划线(50px)</code>和<code>缺口(50px)</code>的长度。</li><li>由于<code>50(短划线) + 50(缺口) + 50(段划线) = 150, 150 &lt; 157</code>，无法绘制出完整的圆，所以会导致右边存在<code>缺口(7px)</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">with</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;200&#x27;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 100 100&quot;</span>  &gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;25&quot;</span>  <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;transparent&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">stroke-dasharray</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#0079f5&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">circie</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd7c32a33d3744fbb91f6802724a2c7e~tplv-k3u1fbpfcp-zoom-1.image"></p><ol start="3"><li><code>stroke-dashoffset</code> 属性可以使圆的短划线和缺口产生偏移，添加 @keyframes 动画后能够实现从无到有的效果，<a href="https://www.cnblogs.com/daisygogogo/p/11044353.html">stoke-dashoffset 参考资料</a></li></ol><ul><li>设置 <code>stroke-dasharray=&quot;157 157</code>“, 指定 <code>短划线(157px)</code> 和 <code>缺口(157px)</code> 的长度。</li><li>添加 @keyframes 动画 <code>修改stroke-dashoffset值</code>, 值为<code>正数</code>时<code>逆时针偏移</code>🔄,， 值为<code>负数</code>时，<code>顺时针偏移</code>🔃</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> loading &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>    <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">stroke-dashoffset</span>: -<span class="hljs-number">157</span>; <span class="hljs-comment">/* 线条顺时针偏移 */</span><br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">circle</span>&#123;<br>    <span class="hljs-attribute">animation</span>: loading <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> ease-out infinite;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c134b9e11a4dbaa79fd98caa61ccfd~tplv-k3u1fbpfcp-zoom-1.image"></p><ol start="4"><li>修改短划线和缺口值</li></ol><ul><li>为了让 loading 组件线条可见，我们需要一个<code>50px</code>的短划线, 设置 <code>stroke-dasharray=&quot;50&quot;</code></li><li>为了让短划线发生偏移后可以完全消失，<code>缺口需要大于或等于圆周长157</code>，设置 <code>stroke-dasharray=&quot;50 157&quot;</code></li><li>添加 @keyframes 动画, 为了让<code>动画结束时仍处理动画开始位置</code>，需要<code>修改 stroke-dashoffset:-207(短划线+缺口长度)</code></li><li>进度条也是类似原理，帮助理解 <code>stroke-dashoffset</code> 属性，具体实现请查看<a href="https://codepen.io/awesomedevin/pen/zYromBB">示例</a></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> loading &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>    <span class="hljs-attribute">stroke-dashoffset</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-number">100%</span>&#123;<br>    <span class="hljs-attribute">stroke-dashoffset</span>: -<span class="hljs-number">207</span>; <span class="hljs-comment">/* 保证动画结束时仍处理动画开始位置 */</span><br>  &#125;<br>&#125;<br><span class="hljs-selector-tag">circle</span>&#123;<br>    <span class="hljs-attribute">animation</span>: loading <span class="hljs-number">1s</span> <span class="hljs-number">0s</span> ease-out infinite;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Animation-steps-运用"><a href="#Animation-steps-运用" class="headerlink" title="Animation steps() 运用"></a>Animation steps() 运用</h2><p><code>steps()</code> 是 <code>animation-timing-function</code> 的属性值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">animation-timing-function</span> : <span class="hljs-built_in">steps</span>(number[, end | start])<br><br></code></pre></td></tr></table></figure><ul><li>steps 函数指定了一个阶跃函数，它接受<code>两个参数</code></li><li><code>第一个参数接受一个整数值</code>，表示两个关键帧之间分几步完成</li><li><code>第二个参数有两个值 start or end</code>。默认值为 end</li><li>step-start 等同于 step(1, start)。step-end 等同于 step(1, end)</li></ul><p>steps 适用于关键帧动画，第一个参数将<code>两个关键帧</code>细分为<code>N帧</code>，第二个参数决定从一帧到另一帧的中间间隔是用<code>开始帧</code>还是<code>结束帧</code>来进行填充。</p><p>看下图可以发现:</p><ul><li><code>steps(N, start)</code>将动画分为<code>N段</code>，动画在每一段的<code>起点</code>发生阶跃 (即图中的空心圆 → 实心圆), 动画结束时停留在了第 N 帧</li><li><code>steps(N, end)</code>将动画分为<code>N段</code>，动画在每一段的<code>终点</code>发生阶跃 (即图中的空心圆 → 实心圆), 动画结束时第 N 帧已经被跳过 (即图中的空心圆 → 实心圆)，停留在了 N+1 帧。</li></ul><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae38ac1efb24dfabaf0e22bc11b2c7d~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="实践出真知！"><a href="#实践出真知！" class="headerlink" title="实践出真知！"></a>实践出真知！</h2><h3 id="Animation-实现打字效果"><a href="#Animation-实现打字效果" class="headerlink" title="Animation 实现打字效果"></a>Animation 实现打字效果</h3><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1018ce312fff4eaca9978a7f10f6e9ae~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/xxZEjjO">Animation 实现打字效果 DEMO</a></p><ul><li>此处用英文字母 (I’m an O2man.) 举例，一共有<code>13</code>个字符。[经测试，多数中文字体每个字符宽高都相等]</li><li><code>steps(13)</code>可以将 @keyframes 动画分为<code>13阶段</code>运行, 且<code>每一阶段运行距离相等</code>。</li></ul><p>效果如下：</p><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/247010637ea5447e90f4cd5fe340c442~tplv-k3u1fbpfcp-zoom-1.image"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 改变容器宽度 */</span><br><span class="hljs-keyword">@keyframes</span> animate-x &#123;<br>  <span class="hljs-number">0%</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">125px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid transparent;<br>    <span class="hljs-attribute">animation</span>: animate-x <span class="hljs-number">3s</span> <span class="hljs-number">0s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">13</span>) <span class="hljs-number">1</span> forwards;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>可以发现仅仅这样还不够，动画运行过程中出现了字符被截断的情况, 为了保证每个阶段运行后能准确无误地显示当前所处阶段的字符，我们还需要保证<code>每个字符的width与动画每一阶段运行的距离相等</code></li><li>设置<code>Monaco</code>字体属性，用以保证<code>每个字符的 width 相同</code>，具体像素受<code>fontSize</code>属性影响，示例中的字体宽度约为 9.6px，<code>9.6px * 13(段数) = 124.8px (125px)</code>，所以当我们设置容器宽度为 125px，即可的达成目的：<code>每个字符的 width 与动画每一阶段运行的距离相等(约为 9.6px )</code>。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-comment">/* 设置 Monaco 字体属性，字体大小为16px，用以保证每个字符的 width 相同，width 约为9.6p */</span><br>    <span class="hljs-attribute">font-family</span>: Monaco;<br>    <span class="hljs-comment">/* 9.6px * 13 = 124.8px (125px) */</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">125px</span> ;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid transparent;<br>    <span class="hljs-comment">/* 同时应用动画 animate-x、cursor-x */</span><br>    <span class="hljs-attribute">animation</span>: animate-x <span class="hljs-number">3s</span> <span class="hljs-number">0s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">13</span>) <span class="hljs-number">1</span> forwards,cursor-x <span class="hljs-number">0.4s</span> <span class="hljs-number">0s</span> linear infinite;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Animation-实现帧动画-⏰"><a href="#Animation-实现帧动画-⏰" class="headerlink" title="Animation 实现帧动画 ⏰"></a>Animation 实现帧动画 ⏰</h3><p><img src="http://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1da5d73e624a0cbbc84b04e661cc93~tplv-k3u1fbpfcp-zoom-1.image"></p><p><a href="https://codepen.io/awesomedevin/pen/JjGRMgN">Animation 实现帧动画 ⏰ DEMO</a></p><ul><li>这里我们拿到了一张<code>47帧</code>的<a href="https://img11.360buyimg.com/ling/jfs/t1/142743/11/2314/166268/5f046114Efb97efac/b327092864ed1f04.png">雪碧图（css spirit）</a>, 设置背景图</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">260px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">url</span>) no-repeat;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>添加 @keyframes <code>修改 background-position</code>，让背景图移动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> animate &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>        <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">100%</span>;<br>    &#125;<br>&#125;<br><span class="hljs-selector-class">.main</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">260px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">url</span>) no-repeat;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">animation</span>: animate <span class="hljs-number">2s</span> <span class="hljs-number">1s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">47</span>) infinite alternate;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>同时, css 还提供了<code>animation-play-state</code>用于控制动画是否暂停</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span>+<span class="hljs-selector-class">.main</span>&#123;<br>    <span class="hljs-attribute">animation-play-state</span>: paused;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>文章篇幅较长，感谢大家的阅读，希望各位看客能够有所收获~ ~ ~</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.w3school.com.cn/cssref/index.asp">Animation 常用动画属性</a> <a href="https://www.w3school.com.cn/cssref/index.asp">CSS 参考手册</a> <a href="https://segmentfault.com/a/1190000007042048">steps() 参考资料</a> <a href="https://www.cnblogs.com/daisygogogo/p/11044353.html">SVG 学习之 stroke-dasharray 和 stroke-dashoffset 详解</a><br><a href="https://laixiazheteng.com/article/page/id/0gU2Wefas7hn">理解 CSS3 Animation 中的 steps()</a><br><a href="https://segmentfault.com/a/1190000007042048">【译】css 动画里的 steps() 用法详解</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change">CSS Will Change</a><br>原文地址 <a href="https://juejin.im/post/6889226357851553805?utm_source=gold_browser_extension">juejin.im</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入理解洋葱模型中间件机制</title>
    <link href="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本文来由，希望可以剖析中间件的组合原理，从而帮助大家更加理解洋葱模型。<br> <span id="more"></span></p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/1.jpeg" alt="image"></p><p>话不多说，正文如下。</p><p>这一段代码来源于 redux 里导出的 compose 函数。我做了一些修改。主要是给匿名函数添加了名称，比如 reducer 和 nextWrapper，主要原因是匿名函数（anonymous）不便于调试。所以 《You-Dont-Know-JS》 的作者 Kyle Simpson 大叔就对箭头函数持保留意见，认为不该乱用，不过跑题了，扯回。</p><p>先贴代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) &#123;<br>  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> arg;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextWrapper</span>(<span class="hljs-params">...args</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args));<br>    &#125;;<br>  &#125;);<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>接下来全文将基于此函数剖析。</p><p>接下来将提供几个简单 redux 中间件，同样，我避免了箭头函数的使用，理由同上。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">next</span>(<span class="hljs-params">action</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[next]&quot;</span>, action);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fooMiddleware</span>(<span class="hljs-params">next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[fooMiddleware] trigger&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">next_from_foo</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[fooMiddleware] before next&quot;</span>);<br>    <span class="hljs-title function_">next</span>(action);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[fooMiddleware] after next&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">barMiddleware</span>(<span class="hljs-params">next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[barMiddleware] trigger&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">next_from_bar</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[barMiddleware] before next&quot;</span>);<br>    <span class="hljs-title function_">next</span>(action);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[barMiddleware] after next&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bazMiddleware</span>(<span class="hljs-params">next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[bazMiddleware] trigger&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">next_from_baz</span>(<span class="hljs-params">action</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[bazMiddleware] before next&quot;</span>);<br>    <span class="hljs-title function_">next</span>(action);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[bazMiddleware] after next&quot;</span>);<br>  &#125;;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>此时如果将以上 foo bar baz 三个中间件组合运行如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chain = <span class="hljs-title function_">compose</span>(fooMiddleware, barMiddleware, bazMiddleware);<br><span class="hljs-keyword">const</span> nextChain = <span class="hljs-title function_">chain</span>(next);<br><span class="hljs-title function_">nextChain</span>(<span class="hljs-string">&quot;&#123;data&#125;&quot;</span>);<br> <br></code></pre></td></tr></table></figure><p>以上将会在控制台输出什么？</p><p>大家可以思考一下。</p><p>…</p><p>熟悉中间件运行顺序的同学可能很快得出答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">[bazMiddleware] trigger<br>[barMiddleware] trigger<br>[fooMiddleware] trigger<br>[fooMiddleware] before next<br>[barMiddleware] before next<br>[bazMiddleware] before next<br>[next] &#123;data&#125;<br>[bazMiddleware] after next<br>[barMiddleware] after next<br>[fooMiddleware] after next<br> <br></code></pre></td></tr></table></figure><p>写不出正确答案的同学也无须灰心。这篇文章的目的，正是帮助大家更好理解这一套机制原理。</p><p>这种洋葱模型，也即是中间件的能力之强大众所周知，现在在 Web 社区发挥极大作用的 Redux、Express、Koa，开发者利用其中的洋葱模型，构建无数强大又有趣的 Web 应用和 Node 应用。更不用提基于这三个衍生出来的 Dva、Egg 等。 所以其实需要理解的是这套实现机制原理，如果光是记住中间件执行顺序，未免太过无趣了，现在让我们逐层逐层解构以上代码来探索洋葱模型吧。</p><p>到这里，正文正式开始！</p><p>以上代码的灵魂之处在于 Array.prototype.reduce()，不了解此函数的同学强烈建议去 MDN 遛跶一圈 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">MDN | Array.prototype.reduce()</a>。</p><p>reduce 函数是函数式编程的一个重要概念，可用于实现函数组合（compose）</p><h2 id="组合中间件机制"><a href="#组合中间件机制" class="headerlink" title="组合中间件机制"></a>组合中间件机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chain = <span class="hljs-title function_">compose</span>(fooMiddleware, barMiddleware, bazMiddleware);<br> <br></code></pre></td></tr></table></figure><p>以上 compose 传入了 fooMiddleware、barMiddleware、bazMiddleware 三个中间件进行组合，内部执行步骤可以分解为以下两步。</p><ol><li>第一步输入参数：a -&gt; fooMiddleware，b -&gt; barMiddleware</li></ol><p>执行 reduce 第一次组合，得到返回输出：<code>function nextWrapper#1(...args) &#123; return fooMiddleware(barMiddleware(...args)) &#125;</code></p><ol start="2"><li>第二步输入参数：a -&gt; function nextWrapper#1(…args) { return fooMiddleware(barMiddleware(…args)) }，b -&gt; bazMiddleware</li></ol><p>执行 reduce 第二次组合，得到返回输出：<code>function nextWrapper#2(...args) &#123; return nextWrapper#1(bazMiddleware(...args)) &#125;</code>。</p><p>所以 chain 就等于最终返回出来的 nextWrapper。</p><p>（这里用了 #1，#2 用来指代不同组合的 nextWrapper，实际上并没有这样的语法，须知）</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/2.jpeg" alt="image"></p><h2 id="应用中间件机制"><a href="#应用中间件机制" class="headerlink" title="应用中间件机制"></a>应用中间件机制</h2><p>然而此时请留意，所有中间件并没有执行，到目前为止最终通过高阶函数 nextWrapper 返回了出来而已。</p><p>因为直到以下这一句，传入 next 函数作为参数，才开始真正的触发了 nextWrapper，开始迭代执行所有组合过的中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nextChain = <span class="hljs-title function_">chain</span>(next);<br> <br></code></pre></td></tr></table></figure><p>我们在上面得知了 chain 最终是形如 (…args) &#x3D;&gt; fooMiddleware(barMiddleware(bazMiddleware(…args))) 的函数。因此当传入 next 函数时，内部执行步骤可以分为下述几步：</p><ol><li><p>第一步，执行 chain 函数（也即是 nextWrapper#2），从 compose 的函数组合从内至外，next 参数首先交由 bazMiddleware 函数执行，打印日志后，返回了函数 next_from_baz。</p></li><li><p>第二步，next_from_baz 立即传入 nextWrapper#1，返回了 fooMiddleware(barMiddleware(…args))。 因此，barMiddleware 函数接收的期望 next 参数，其实并不是我们一开始的 next 函数了，而是 bazMiddleware 函数执行后返回的 next_from_baz。barMiddleware 收到 next 参数开始执行，打印日志后，返回了 next_from_bar 函数。</p></li><li><p>第三步，同理，fooMiddleware 函数接收的期望 next 参数是 barMiddleware 函数执行后返回的 next_from_bar。fooMiddleware 收到 next 参数开始执行，打印日志并返回了 next_from_foo 函数。</p></li></ol><p>所以此时我们此时可知，运行完 chain 函数后，实际上 nextChain 函数就是 next_from_foo 函数。</p><p>再用示意图详细描述即为：</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/3.jpg" alt="image"></p><p>此时经过以上步骤，控制台输出了下述日志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[bazMiddleware] trigger<br>[barMiddleware] trigger<br>[fooMiddleware] trigger<br> <br></code></pre></td></tr></table></figure><p>这里的 next_from_baz，next_from_bar，next_from_foo 其实就是一层层的对传入的参数函数 next 包裹。官方说法称之为 Monkeypatching。</p><p>我们很清晰的知道，next_from_foo 包裹了 next_from_bar，next_from_bar 又包裹了 next_from_baz，next_from_baz 则包裹了 next。</p><p>如果直接写 Monkeypatching 如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> prevNext = next;<br>next = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// @todo</span><br>  <span class="hljs-title function_">prevNext</span>(...args);<br>  <span class="hljs-comment">// @todo</span><br>&#125;;<br> <br></code></pre></td></tr></table></figure><p>但这样如果需要 patch 很多功能，我们需要将上述代码重复许多遍。的确不是很 DRY。</p><blockquote><p>Monkeypatching 本质上是一种 hack。“将任意的方法替换成你想要的”。</p></blockquote><p>关于 Monkeypatching 和 redux 中间件的介绍，十分推荐阅读官网文档 <a href="https://www.redux.org.cn/docs/advanced/Middleware.html">Redux Docs | Middleware</a>。</p><p>到这里我想出个考题，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add5</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">div2</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sub3</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x - <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> chain = [add5, div2, sub3].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args)));<br> <br></code></pre></td></tr></table></figure><p>请问，chain(1) 输出值？</p><p>执行顺序为 sub3 -&gt; div2 -&gt; add5。 (1 - 3) &#x2F; 2 + 5 &#x3D; 4。答案是 4。</p><p>那么再问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chain = [add5, div2, sub3].<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">b</span>(<span class="hljs-title function_">a</span>(...args)));<br> <br></code></pre></td></tr></table></figure><p>此时 chain(1) 输出值？还是 4。</p><p>再看如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chain = [add5, div2, sub3].<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">b</span>(<span class="hljs-title function_">a</span>(...args)));<br> <br></code></pre></td></tr></table></figure><p>此时 chain(1) 输出值？仍然是 4。</p><p>如果你对上述示例都能很清晰的运算出答案，那么你应该对上文中 chain(next) 的理解 ok，那么请继续往下看。</p><h2 id="洋葱模型机制"><a href="#洋葱模型机制" class="headerlink" title="洋葱模型机制"></a>洋葱模型机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">nextChain</span>(<span class="hljs-string">&quot;&#123;data&#125;&quot;</span>);<br> <br></code></pre></td></tr></table></figure><p>终于重头戏来了，nextChain 函数来之不易，但毫无疑问，它的能力是十分强大的。（你看，其实在 redux 中，这个 nextChain 函数其实就是 redux 中的 dispatch 函数。）</p><p>文章截止目前为止，我们得知了 nextChain 函数即为 next_from_foo 函数。</p><p>因此下述的执行顺序我将用函数堆栈图给大家示意。</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/4.jpg" alt="image"></p><p>依次执行，每当执行到 next 函数时，新的 next 函数入栈，循环往复，直到 next_from_baz 为止。函数入栈的过程，就相当于进行完了洋葱模型从外到里的进入过程。</p><p>控制台输出日志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">[fooMiddleware] before next<br>[barMiddleware] before next<br>[bazMiddleware] before next<br> <br></code></pre></td></tr></table></figure><p>函数入栈直到最终的 next 函数，我们知道，next 函数并没有任何函数了，也就是说到达了终点。</p><p>接下来就是逐层出栈。示意图如下</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/5.jpg" alt="image"></p><p>控制台输出日志：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[next] &#123;data&#125;<br>[bazMiddleware] after next<br>[barMiddleware] after next<br>[fooMiddleware] after next<br> <br></code></pre></td></tr></table></figure><p>函数出栈的过程，就相当于洋葱模型从里到外的出去过程。</p><p>上述是函数堆栈的执行顺序。而下述示意图是我整理后帮助大家理解的线性执行顺序。每当执行到 next(action) 的时候函数入栈，原 next 函数暂时停止执行，执行新的 next 函数，正如下图弯曲箭头所指。</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/6.jpg" alt="image"></p><p>上图，代码从上至下运行，实际上就是调用栈的一个程序控制流程。所以理论上无论有多少个函数嵌套，都可以等同理解。</p><p>我们修改一开始的洋葱模型，示例如下：</p><p><img src="/2020/10/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/7.jpg" alt="image"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>redux 的中间件也就是比上述示例的中间件多了一层高阶函数用以获取框架内部的 store。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">reduxMiddleware</span> = store =&gt; <span class="hljs-function"><span class="hljs-params">next</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-title function_">next</span>(action);<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br> <br></code></pre></td></tr></table></figure><p>而 koa 的中间件多了 ctx 上下文参数，和支持异步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br> <br></code></pre></td></tr></table></figure><p>你能想到大致如何实现了么？是不是有点拨开云雾见太阳的感觉了？</p><p>如果有，本文发挥了它的作用和价值，笔者将会不甚荣幸。如果没有，那笔者的表达能力还是有待加强。</p><p>原文地址 <a href="https://juejin.im/post/6844904025767280648">juejin.im</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端状态管理</title>
    <link href="/2020/10/26/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2020/10/26/%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>随着 <strong>React</strong> 和 <strong>Vue</strong> 等异步框架的广泛运用，前端状态管理器逐渐成为前端开发比不可少话题。形如 <strong>React</strong> 有倍受欢迎的 <strong>Redux</strong>，再如 <strong>Vue</strong> 标配的状态管理器 <strong>Vuex</strong>，都是业内相对成熟的状态管理器，那么我们接下来就用原生 javascript 来实现一个状态管理器。</p><p>主要包含两个方面：第一是<strong>发布订阅</strong>，第二是<strong>状态管理</strong>。</p><span id="more"></span><h3 id="发布订阅-PubSub"><a href="#发布订阅-PubSub" class="headerlink" title="发布订阅 PubSub"></a>发布订阅 <strong>PubSub</strong></h3><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><p>首先我们先创建一个 <strong>PubSub</strong> 类函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 收集事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现-Publish"><a href="#实现-Publish" class="headerlink" title="实现 Publish"></a>实现 Publish</h4><p>接着我们来实现一个发布函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  ...<br>  <span class="hljs-comment">// 发布</span><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     \* 校验是否存在事件</span><br><span class="hljs-comment">     \* 默认返回一个空数组</span><br><span class="hljs-comment">     \*/</span><br>    <span class="hljs-keyword">if</span> (!self.<span class="hljs-property">events</span>.<span class="hljs-title function_">hasOwnProperty</span>(event)) &#123;<br>      <span class="hljs-keyword">return</span> \[\];<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历执行事件队列里的回调函数</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-property">events</span>\[event\].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  &#125;<br>  ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="实现-Subscribe"><a href="#实现-Subscribe" class="headerlink" title="实现 Subscribe"></a>实现 Subscribe</h4><p>实现完发布函数 <strong>publish</strong>，接着我们来实现订阅函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>...<br>    <span class="hljs-comment">// 订阅</span><br>    <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>      <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>      <br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">       \* 校验是否存在事件</span><br><span class="hljs-comment">       \* 默认给一个空数组</span><br><span class="hljs-comment">       \*/</span><br>      <span class="hljs-keyword">if</span> (!self.<span class="hljs-property">events</span>.<span class="hljs-title function_">hasOwnProperty</span>(event)) &#123;<br>        self.<span class="hljs-property">events</span>\[event\] = \[\];<br>      &#125;<br>  <br>      <span class="hljs-comment">// 将事件推入回调队列</span><br>      <span class="hljs-keyword">return</span> self.<span class="hljs-property">events</span>\[event\].<span class="hljs-title function_">push</span>(callback);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PubSub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 收集事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 订阅</span><br>  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     \* 校验是否存在事件</span><br><span class="hljs-comment">     \* 默认给一个空数组</span><br><span class="hljs-comment">     \*/</span><br>    <span class="hljs-keyword">if</span> (!self.<span class="hljs-property">events</span>.<span class="hljs-title function_">hasOwnProperty</span>(event)) &#123;<br>      self.<span class="hljs-property">events</span>\[event\] = \[\];<br>    &#125;<br><br>    <span class="hljs-comment">// 将事件推入回调队列</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-property">events</span>\[event\].<span class="hljs-title function_">push</span>(callback);<br>  &#125;<br><br>  <span class="hljs-comment">// 发布</span><br>  <span class="hljs-title function_">publish</span>(<span class="hljs-params">event, data = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 校验是否存在事件</span><br><span class="hljs-comment">     * 默认返回一个空数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!self.<span class="hljs-property">events</span>.<span class="hljs-title function_">hasOwnProperty</span>(event)) &#123;<br>      <span class="hljs-keyword">return</span> \[\];<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历执行事件队列里的回调函数</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-property">events</span>\[event\].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(data));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态管理-Store"><a href="#状态管理-Store" class="headerlink" title="状态管理 Store"></a>状态管理 <strong>Store</strong></h3><h4 id="创建类-1"><a href="#创建类-1" class="headerlink" title="创建类"></a>创建类</h4><p>首先我们创建一个 <strong>Store</strong> 类函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br><span class="hljs-comment">// 传入params对象</span><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">params</span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>        self.<span class="hljs-property">actions</span> = &#123;&#125;; <span class="hljs-comment">// 异步任务对象</span><br>        self.<span class="hljs-property">mutations</span> = &#123;&#125;; <span class="hljs-comment">// 同步任务对象</span><br>        self.<span class="hljs-property">state</span> = &#123;&#125;; <span class="hljs-comment">// 全局状态对象</span><br>        self.<span class="hljs-property">plugins</span> = \[\]; <span class="hljs-comment">// 插件</span><br>        self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;resting&quot;</span>; <span class="hljs-comment">// 初始状态</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         \* 初始化设置actions对象</span><br><span class="hljs-comment">         \* 该对象主要处理异步事件</span><br><span class="hljs-comment">         \*/</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;actions&quot;</span>)) &#123;<br>          self.<span class="hljs-property">actions</span> = params.<span class="hljs-property">actions</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         \* 初始化设置mutations对象</span><br><span class="hljs-comment">         \* 该对象主要处理同步事件</span><br><span class="hljs-comment">         \*/</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;mutations&quot;</span>)) &#123;<br>          self.<span class="hljs-property">mutations</span> = params.<span class="hljs-property">mutations</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插件</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;plugins&quot;</span>)) &#123;<br>          self.<span class="hljs-property">plugins</span> = params.<span class="hljs-property">plugins</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         \* 代理监听state</span><br><span class="hljs-comment">         \*/</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(params.<span class="hljs-property">state</span> || &#123;&#125;, &#123;<br>          <span class="hljs-title function_">set</span>(<span class="hljs-params">state, key, value</span>) &#123;<br>          <span class="hljs-comment">// 代理设置state对象并赋值</span><br>            state\[key\] = value;<br><br>            <span class="hljs-comment">// 更改状态</span><br>            self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;resting&quot;</span>;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;,<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现-commit"><a href="#实现-commit" class="headerlink" title="实现 commit"></a>实现 commit</h4><p>接着我们来实现核心函数 <strong>commit</strong>，该函数主要处理对象更改，调用 <strong>mutations</strong> 对象内的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>...<br>    commit = <span class="hljs-function">(<span class="hljs-params">mutationKey, payload</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-comment">// 校验是否存在函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self.<span class="hljs-property">mutations</span>\[mutationKey\] !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Mutation <span class="hljs-subst">$&#123;mutationKey&#125;</span> dose not exist`</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>  <br>      <span class="hljs-comment">// 变更状态</span><br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;mutation&quot;</span>;<br>      <br>      <span class="hljs-comment">// 执行对应函数</span><br>      self.<span class="hljs-property">mutations</span>\[mutationKey\](self.<span class="hljs-property">state</span>, payload);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现-dispatch"><a href="#实现-dispatch" class="headerlink" title="实现 dispatch"></a>实现 dispatch</h4><p>实现完 <strong>commit</strong>，我们再来实现 <strong>dispatch</strong>，这个函数主要处理异步问题，传入 <strong>commit</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>...<br>    dispatch = <span class="hljs-function">(<span class="hljs-params">actionKey, payload</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>      <br>      <span class="hljs-comment">// 校验是否存在函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self.<span class="hljs-property">actions</span>\[actionKey\] !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Action <span class="hljs-subst">$&#123;actionKey&#125;</span> dose not exist`</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>  <br>      <span class="hljs-comment">// 变更状态</span><br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;action&quot;</span>;<br>      <br>      <span class="hljs-comment">// 执行对应函数，并传入commit</span><br>      self.<span class="hljs-property">actions</span>\[actionKey\](&#123; <span class="hljs-attr">commit</span>: self.<span class="hljs-property">commit</span> &#125;, payload);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br><span class="hljs-comment">// 传入params对象</span><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">params</span>) &#123;<br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>        self.<span class="hljs-property">actions</span> = &#123;&#125;; <span class="hljs-comment">// 异步任务对象</span><br>        self.<span class="hljs-property">mutations</span> = &#123;&#125;; <span class="hljs-comment">// 同步任务对象</span><br>        self.<span class="hljs-property">state</span> = &#123;&#125;; <span class="hljs-comment">// 全局状态对象</span><br>        self.<span class="hljs-property">plugins</span> = \[\]; <span class="hljs-comment">// 插件</span><br>        self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;resting&quot;</span>; <span class="hljs-comment">// 初始状态</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化设置actions对象</span><br><span class="hljs-comment">         * 该对象主要处理异步事件</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;actions&quot;</span>)) &#123;<br>          self.<span class="hljs-property">actions</span> = params.<span class="hljs-property">actions</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化设置mutations对象</span><br><span class="hljs-comment">         * 该对象主要处理同步事件</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;mutations&quot;</span>)) &#123;<br>          self.<span class="hljs-property">mutations</span> = params.<span class="hljs-property">mutations</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插件</span><br>        <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;plugins&quot;</span>)) &#123;<br>          self.<span class="hljs-property">plugins</span> = params.<span class="hljs-property">plugins</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* </span><br><span class="hljs-comment">         * 代理监听state</span><br><span class="hljs-comment">         */</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(params.<span class="hljs-property">state</span> || &#123;&#125;, &#123;<br>          <span class="hljs-title function_">set</span>(<span class="hljs-params">state, key, value</span>) &#123;<br>          <span class="hljs-comment">// 代理设置state对象并赋值</span><br>            state\[key\] = value;<br><br>            <span class="hljs-comment">// 更改状态</span><br>            self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;resting&quot;</span>;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;,<br>        &#125;);<br>   &#125;<br><br>  dispatch = <span class="hljs-function">(<span class="hljs-params">actionKey, payload</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>      <br>      <span class="hljs-comment">// 校验是否存在函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self.<span class="hljs-property">actions</span>\[actionKey\] !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Action <span class="hljs-subst">$&#123;actionKey&#125;</span> dose not exist`</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>  <br>      <span class="hljs-comment">// 变更状态</span><br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;action&quot;</span>;<br>      <br>      <span class="hljs-comment">// 执行对应函数，并传入commit</span><br>      self.<span class="hljs-property">actions</span>\[actionKey\](&#123; <span class="hljs-attr">commit</span>: self.<span class="hljs-property">commit</span> &#125;, payload);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  commit = <span class="hljs-function">(<span class="hljs-params">mutationKey, payload</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-comment">// 校验是否存在函数</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> self.<span class="hljs-property">mutations</span>\[mutationKey\] !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Mutation <span class="hljs-subst">$&#123;mutationKey&#125;</span> dose not exist`</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>  <br>      <span class="hljs-comment">// 变更状态</span><br>      self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;mutation&quot;</span>;<br>      <br>      <span class="hljs-comment">// 执行对应函数</span><br>      self.<span class="hljs-property">mutations</span>\[mutationKey\](self.<span class="hljs-property">state</span>, payload);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PubSub-和-Store-结合"><a href="#PubSub-和-Store-结合" class="headerlink" title="PubSub 和 Store 结合"></a>PubSub 和 Store 结合</h3><h4 id="引入-PubSub-库"><a href="#引入-PubSub-库" class="headerlink" title="引入 PubSub 库"></a>引入 PubSub 库</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SubPub</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../lib/pubsub&quot;</span>);<br>    <br>    <span class="hljs-comment">// 在state的代理中监测到数据改变，发布相对应事件</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">params</span>) &#123;<br>        <span class="hljs-comment">// 实例化发布订阅</span><br>        self.<span class="hljs-property">events</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubPub</span>()<br>        <br>        ...<br>            <span class="hljs-comment">/* </span><br><span class="hljs-comment">             * 代理监听state</span><br><span class="hljs-comment">             */</span><br>            self.<span class="hljs-property">state</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(params.<span class="hljs-property">state</span> || &#123;&#125;, &#123;<br>              <span class="hljs-title function_">set</span>(<span class="hljs-params">state, key, value</span>) &#123;<br>                <span class="hljs-comment">// 代理设置state对象并赋值</span><br>                state\[key\] = value;<br>                <br>                <span class="hljs-comment">// 添加发布事件</span><br>                self.<span class="hljs-property">events</span>.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&quot;stateChange&quot;</span>, self.<span class="hljs-property">state</span>);<br><br>                <span class="hljs-comment">// 更改状态</span><br>                self.<span class="hljs-property">status</span> = <span class="hljs-string">&quot;resting&quot;</span>;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>              &#125;,<br>            &#125;);<br>            ...<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Store</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>(&#123;<br><span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;,<br><span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-attr">init</span>: <span class="hljs-function">(<span class="hljs-params">state, payload</span>) =&gt;</span> &#123;<br>        state.<span class="hljs-property">text</span> = payload<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-attr">init</span>: <span class="hljs-function">(<span class="hljs-params">&#123;commit&#125;,payload</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;init&#x27;</span>, payload)<br>            &#125;,<span class="hljs-number">200</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: \[<br>    <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;plugins&#x27;</span>)<br>        &#125;<br>    \]<br>&#125;)<br><br><span class="hljs-comment">// 执行同步事件</span><br><span class="hljs-title class_">Store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;init&#x27;</span>, <span class="hljs-string">&#x27;hello init&#x27;</span>)<br><br><span class="hljs-comment">// 执行异步事件</span><br><span class="hljs-title class_">Store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;init&#x27;</span>, <span class="hljs-string">&#x27;hello async init&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是基础版的全局状态管理器，包含基本的同步和异步处理，插件，发布订阅功能，当然还有些细节需要完善。有问题欢迎在评论中指出，谢谢。</p><p> 原文地址 [juejin.im](<a href="https://juejin.im/post/6887538204266725384?utm%5C_source=gold%5C_browser%5C_extension">https://juejin.im/post/6887538204266725384?utm\_source=gold\_browser\_extension</a>)</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2020/09/18/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2020/09/18/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>现在让我们深入了解 Flexbox 的缩放 – 以及如何利用它来构建漂亮的自适应布局。</p><span id="more"></span><h3 id="属性-1-Flex-Basis"><a href="#属性-1-Flex-Basis" class="headerlink" title="属性 #1: Flex-Basis"></a>属性 #1: Flex-Basis</h3><p>在上一篇文章中，我们主要了解了适用于容器元素的属性。这一次，我们专门介绍如何控制子元素 (flex 项) 的大小。</p><p>我想，我们这次介绍的第一个属性是 Flexbox 教程中最不好解释的属性之一。</p><p>但 – 不要担心。 它实际上很简单。</p><p><code>flex-basis</code> 控制一个子元素 (flex 项) 的默认大小，但是它可以被其他的 Flexbox 属性影响（稍后详细介绍）。</p><p>在下面的 GIF 中，你会发现它可以与 <code>width</code> 属性互换（等价）：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IM2.gif" alt="image"></p><p>然而，flex-basis 和 width 有什么不同呢？<code>flex-basis</code> 对应于 flex 轴线而言的：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IM3.png" alt="image"></p><p>flex-basis 影响元素在主轴 (main axis) 上的大小。</p><p>让我们看看当保持 flex-basis 不变的情况下，改变主轴方向，会发生什么。</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IM4.gif" alt="image"></p><p>注意，我们必须从手动将 <code>height</code> 切换到设置 <code>width</code> 属性。 因此，<code>flex-basis</code> 是根据 <code>flex-direction</code> 的不同来确定 <code>width</code> 或 <code>height</code> 的。</p><h3 id="属性-2-Flex-Grow（拉伸）"><a href="#属性-2-Flex-Grow（拉伸）" class="headerlink" title="属性 #2: Flex Grow（拉伸）"></a>属性 #2: Flex Grow（拉伸）</h3><p>现在我们要更复杂一点了。</p><p>首先，让我们将所有的矩形子元素 (flex 项) 设置为相同的<code>width</code>，120px：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IM5.png" alt="image"></p><p>现在，涉及到名为 <code>flex-grow</code> 的属性，其默认值为 <code>0</code> 。这意味着矩形子元素 (flex 项) 不允许自动占据容器中剩余的空间。</p><p>这意味着什么呢？好吧，让我们尝试把为每个矩形子元素 (flex 项) 的<code>flex-grow</code>设置为<code>1</code>：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG6.png" alt="image"></p><p>所有矩形子元素 (flex 项) 共同占据了整个容器的宽度，它们之间的间隔也都是均匀分布。<code>flex-grow</code> 值覆盖了 <code>width</code> 值。</p><p>然而，关于 <code>flex-grow</code> 令人困惑的是其值实际上意味着什么呢？<code>flex-grow: 1</code>是什么意思呢？</p><p>嗯，如果设置每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 属性值为 <code>999</code> ，让我们来看一下效果：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG7.png" alt="image"></p><p>正如你所看到的，完全一样。</p><p>这是因为 <code>flex-grow</code> 不是绝对值 – 它是一个相对值。</p><p>对于每个矩形子元素 (flex 项) 来说，重要的不是其 <code>flex-grow</code> 值有多大，而是这个值与其他矩形子元素 (flex 项) 的 <code>flex-grow</code> 值相比较，相对值有多大。</p><p>如果我们将每个矩形子元素 (flex 项) 设置为<code>flex-grow: 1</code>，然后调整第 3 个矩形子元素的<code>flex-grow</code>值，那么我们可以看到改变，如图：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG8.gif" alt="image"></p><p>要真正理解这里到底发生了什么，让我们快速过一边简单的数学知识。</p><p>每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 初始值都是 <code>1</code>。如果我们将每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 相加起来，总和为 <code>6</code>。因此容器的总宽度被平均分成了 6 份。每个矩形子元素 (flex 项) 增长到填充容器可用空间的 1&#x2F;6。</p><p>当我们将第 3 个矩形子元素的 <code>flex-grow</code> 设置为 <code>2</code> 时，容器现在被分成了 7 等份，因为所有 <code>flex-grow</code> 属性是：1 + 1 + 2 + 1 + 1 + 1。</p><p>第 3 个矩形子元素占了整个容器空间的 2&#x2F;7，其他的占了 1&#x2F;7。</p><p>同理，当设置第 3 个矩形子元素的 <code>flex-grow: 3</code> 的时候，整个容器宽度被分成了 8 等份（1 + 1 + 3 + 1 + 1 + 1），第 3 个矩形子元素占了 3&#x2F;8，其他的占了 1&#x2F;8。</p><p>以此类推。</p><p><code>flex-grow</code> 只和比例相关，如果我们设置第 3 个矩形子元素 <code>flex-grow: 12</code>，其余每个方块的 <code>flex-grow: 4</code>；跟第三个设置成 3，其他的设置成 1 得到同样的效果，见下图：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG9.png" alt="image"></p><p>重要的是每个矩形子元素的 <code>flex-grow</code> 与其他矩形子元素成比例的。</p><p>最后一点，请记住，就像 <code>flex-basis</code> 一样，<code>flex-grow</code> 只适用于主轴 (main axis)。我们的矩形子元素只会影响宽度，除非我们将 <code>flex-direction</code>设置为<code>column</code>。</p><h3 id="属性-3-Flex-Shrink（收缩）"><a href="#属性-3-Flex-Shrink（收缩）" class="headerlink" title="属性 #3: Flex Shrink（收缩）"></a>属性 #3: Flex Shrink（收缩）</h3><p><code>flex-shrink</code> 正好和 <code>flex-grow</code> 相反，它是决定矩形子元素允许收缩多少的。</p><p>它的主要用途是指定哪些 flex 项 要缩小，哪些 flex 项 不要缩小。默认情况下，每个矩形子元素 (flex 项) 都为 <code>1</code> – 这意味着每个矩形子元素将随着容器收缩而收缩。</p><p>让我们看看实际情况。 在下面的 GIF 中，每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 为<code>1</code>，所以他们填充满了整个容器，并且<code>flex-shrink</code> 为 <code>1</code>，所以他们被允许收缩。</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG10.gif" alt="image"></p><p>现在让我们将第 3 个矩形子元素的 <code>flex-shrink</code> 设置为 <code>0</code> 。它是禁止收缩，所以它会随着容器拉伸而拉伸，但是当容器收缩的时候，当其宽度收缩至设置的 120px 时，它不再允许收缩。</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG11.gif" alt="image"></p><p><code>flex-shrink</code> 的默认值是 <code>1</code> – 这意味着你的元素默认允许收缩，除非你告诉他们不允许收缩！</p><p>同样， <code>flex-shrink</code> 约为比例。如果一个矩形子元素的 <code>flex-shrink</code> 为 <code>6</code>，并且其余<code>flex-shrink</code> 为 <code>2</code>，那么这个矩形子元素随着容器空间的收缩，将以 3 倍于其他矩形子元素的速度缩小。</p><p>注意这里的措辞：3x（3 倍）<code>flex-shrink</code>的矩形子元素将缩小 3 倍。这并不是收缩 1&#x2F;3 的宽度。</p><p>稍后，我们将深入了解元素是如何收缩和拉伸的。但首先，让我们了解最后一个属性，把这些东西都串起来。</p><h3 id="属性-4-Flex"><a href="#属性-4-Flex" class="headerlink" title="属性 #4: Flex"></a>属性 #4: Flex</h3><p><code>flex</code> 是 <code>flex-grow</code>，<code>flex-shrink</code> 和 <code>flex-basis</code> 的缩写 – 所有这些都放在一起。</p><p>它的默认值是<code>0</code>（grow），<code>1</code>（shrink）和 <code>auto</code>（basis）。</p><p>我们把上一个例子简化成只有两个矩形子元素 (flex 项)。</p><p>下面是它们的属性：</p><p>CSS 代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#one</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#two</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个矩形子元素 (flex 项) 具有着相同的 <code>flex-basis</code>。这意味着如果它们有足够的空间（容器的空间是 600px 加上 <code>margin</code> 和 <code>padding</code> ），它们的宽度都是 300px 。</p><p>但随着容器的拉伸，第 1 个矩形子元素 (flex 项)（具有更高的 <code>flex-grow</code> ）将以两倍于第 2 个矩形子元素的速度增长。 随着容器的收缩，第 2 个矩形子元素（具有更高的柔性收缩）将会以两倍于第 1 个矩形子元素的的速度收缩。</p><p>实际效果如下图：</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG12.gif" alt="image"></p><h4 id="flex-项如何收缩和拉伸"><a href="#flex-项如何收缩和拉伸" class="headerlink" title="flex 项如何收缩和拉伸"></a>flex 项如何收缩和拉伸</h4><p>这里有什么可能会混淆：当第 1 个矩形子元素拉伸时，并没有拉伸到第 2 个矩形子元素的两倍大小。同样，当第 2 个矩形子元素缩小时，它不缩小到第 1 个矩形子元素的一半大小 – 即使<code>flex-shrink</code>(理解为收缩比率) 为<code>2</code>比<code>1</code>。</p><p>这两个属性并不是说它们的大小比例是 <code>2:1</code> 或者 <code>1:2</code>，而是说它们的收缩或拉伸速度的比率。</p><h4 id="简单的数学计算"><a href="#简单的数学计算" class="headerlink" title="简单的数学计算"></a>简单的数学计算</h4><p>容器的初始大小为 640px 。在容器的每一边占用 20px 的 <code>padding</code> ，剩下的空间足够让两个矩形子元素满足 <code>flex-basis</code> 等于 300px。</p><p>当容器设置为 430px 时，空间收缩了 210px 。(注：两个矩形子元素的 <code>flex-shrink</code> 加起来为 <code>3</code> ，那么， ) 第 1 个矩形子元素的 <code>flex-shrink</code> 为 <code>1</code>, 也就是收缩了 70px 。 第 2 个矩形子元素的 <code>flex-shrink</code> 为 <code>1</code> 也就是收缩了 140px 。</p><p>当容器收缩到 340px 时，空间收缩了 300px。第 1 个矩形子元素的收缩了 100px，第 2 个矩形子元素的收缩了 200px 。</p><p>容器收缩的空间根据它们各自的 <code>flex-shrink</code> 收缩率（2:1）的比率来分割。</p><p>这对于 <code>flex-grow</code> 也是同样的。 当容器拉伸到 940px 时，也就是说空间拉伸 300px ，第 1 个矩形子元素被拉伸 200px ，，第 2 个矩形子元素被拉伸 100px 。</p><p>当涉及到 flex 属性时，其实它们说的都是比例。</p><p><img src="/2020/09/18/flex%E5%B8%83%E5%B1%80/IMG13.gif" alt="image"></p><p>在上面的 GIF 中，您可以看到宽度是如何根据比率进行调整的，增量（Δ）显示与 <code>flex-basis</code> 相比的差异。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>作为最后的总结：<code>flex-basis</code> 是控制元素在发生缩放之前，沿着主轴方向的大小。<code>flex-grow</code> 指的是在元素拉伸时，和兄弟元素之间相比的拉伸比例。而 <code>flex-shrink</code> 指的是在元素收缩时，和兄弟元素之间相比的收缩比例。</p><p>我们还有更多的 Flexbox 属性要介绍 – 在接下来的几周里请密切关注。</p><p>非常感谢阅读！ 如果你有一些特定的概念（ Flexbox 或其他），你想看到在类似的文章中解释，请留言。</p><p>原文地址：<a href="https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.9hknw1qpd">https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.9hknw1qpd</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>node框架简单对比</title>
    <link href="/2020/08/10/node%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <url>/2020/08/10/node%E6%A1%86%E6%9E%B6%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近一直想学点什么，想来想去，决定学习下node的实际作为后台应用的使用吧，狠狠心买了个云服务器o(╥﹏╥)o。  </p><p>但是目前nodejs的框架很多，都是很优秀，那么该选择哪种好一些呢？</p><span id="more"></span><h2 id="Express-js"><a href="#Express-js" class="headerlink" title="Express.js"></a>Express.js</h2><p>Express 是 node 环境中非常流行的Web服务端框架，有很大比例的 Node Web应用 采用了 Express。</p><p> Node.JS 诞生之初，最早出现的一款框架，现在仍然很流行，作者是TJ。</p><p> 支持0.1.0以上的node，有非常多的插件提供给用户使用。<br> <a href="https://github.com/expressjs/express">github</a></p><h2 id="Koa-js"><a href="#Koa-js" class="headerlink" title="Koa.js"></a>Koa.js</h2><p>TJ在Express.js之后推出的新的框架，相比Express.js更为精简。 </p><p>Koa 是一个比Express更精简，使用node新特性的中间件框架。其提供的是一个架子，而几乎所有的功能都需要由第三方中间件完成，比如koa-router, koa-view等。（我的理解就是需要什么，去下载什么就好）  </p><p>最开始使用generator进行异步的编写，后来在Koa2中使用了新的ES规范的await和async的形式进行开发。</p><p><a href="https://github.com/koajs/koa">github</a></p><h2 id="Egg-js"><a href="#Egg-js" class="headerlink" title="Egg.js"></a>Egg.js</h2><blockquote><p>Egg.js 为企业级框架和应用而生，我们希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。(官网的说明)</p></blockquote><p>Egg.js 是基于 Koa.js，解决了上述问题，将社区最佳实践整合进了 Koa.js，另取名叫 Egg.js，并且将多进程启动，开发时的热更新等问题一并解决了。这对开发者很友好，开箱即用。  </p><p><a href="https://github.com/eggjs/egg">github</a></p><h2 id="MidwayJS"><a href="#MidwayJS" class="headerlink" title="MidwayJS"></a>MidwayJS</h2><p>实际上就是Egg的TS支持版本。</p><p>淘宝团队在 Egg.js 基础上，引入了 TypeScript 支持。</p><p><a href="https://github.com/midwayjs/pandora">github</a></p><h2 id="Nest-js"><a href="#Nest-js" class="headerlink" title="Nest.js"></a>Nest.js</h2><p>基于 Express.js 的全功能框架 Nest.js</p><p>生态不错也比较推荐。</p>]]></content>
    
    
    <categories>
      
      <category>node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue开发技巧（一）</title>
    <link href="/2020/07/22/vue%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/07/22/vue%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><h3 id="学会使用-attrs-与-listeners，二次包装组件就靠它了"><a href="#学会使用-attrs-与-listeners，二次包装组件就靠它了" class="headerlink" title="学会使用$attrs 与 $listeners，二次包装组件就靠它了"></a>学会使用<code>$attrs</code> 与 <code>$listeners</code>，二次包装组件就靠它了</h3></blockquote><span id="more"></span><p>前几天产品经理给我甩过来一份管理系统的设计原型，我打开看了看，虽然内心是拒绝的，但是为了活着，还是要做的。小编看了看原型，发现系统中的大部分弹框右下角都是确定和取消两个按钮。如果使用 element-ui 提供的<code>Dialog</code>，那么每一个弹框都要手动加按钮，不但代码量增多，而且后面如果按钮 UI，需求发生变化，改动量也比较大。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729c9983361f8d6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>如果可以将<code>Dialog</code>进行二次封装，将按钮封装到组件内部，就可以不用重复去写了。说干就干。</p><h4 id="定义基本弹框代码"><a href="#定义基本弹框代码" class="headerlink" title="定义基本弹框代码"></a>定义基本弹框代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visibleDialog&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--内容区域的默认插槽--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--使用弹框的footer插槽添加按钮--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--对外继续暴露footer插槽，有个别弹框按钮需要自定义--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> &gt;</span><br>        <span class="hljs-comment">&lt;!--将取消与确定按钮集成到内部--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$_handleCancel&quot;</span>&gt;</span>取 消<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$_handleConfirm&quot;</span>&gt;</span><br>            确 定<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 对外暴露visible属性，用于显示隐藏弹框</span></span><br><span class="language-javascript">    <span class="hljs-attr">visible</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 通过计算属性，对.sync进行转换，外部也可以直接使用visible.sync</span></span><br><span class="language-javascript">    <span class="hljs-attr">visibleDialog</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">visible</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;update:visible&quot;</span>,val);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 对外抛出cancel事件</span></span><br><span class="language-javascript">    $_handleCancel() &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;cancel&quot;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-comment">// 对外抛出 confirm事件</span></span><br><span class="language-javascript">    $_handleConfirm() &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;confirm&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>通过上面的代码，我们已经将按钮封装到组件内部了，效果如下图所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--外部使用方式 confirm cancel 是自定义的事件 opened是包装el-dialog的事件，通过$listeners传入到el-dialog里面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">custom-dialog</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visibleDialog&quot;</span> @<span class="hljs-attr">opened</span>=<span class="hljs-string">&quot;$_handleOpened&quot;</span> @<span class="hljs-attr">confirm</span>=<span class="hljs-string">&quot;$_handleConfirm&quot;</span> @<span class="hljs-attr">cancel</span>=<span class="hljs-string">&quot;$_handleCancel&quot;</span>&gt;</span>这是一段内容<span class="hljs-tag">&lt;/<span class="hljs-name">custom-dialog</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729ca8606fb94de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>但上面的代码存在一个问题，无法将<code>Dialog</code>自身的属性和事件暴露到外部（虽然可以通过<code>props</code>及<code>$emit</code>一个一个添加，但是很麻烦）, 这时候就可以使用<code>$attrs</code>与<code>$listeners</code></p><h4 id="使用-attrs与-listeners"><a href="#使用-attrs与-listeners" class="headerlink" title="使用$attrs与$listeners"></a>使用<code>$attrs</code>与<code>$listeners</code></h4><blockquote><p><code>$attrs</code>: 当组件在调用时传入的属性没有在<code>props</code>里面定义时，传入的属性将被绑定到<code>$attrs</code>属性内（<code>class</code>与<code>style</code>除外，他们会挂载到组件最外层元素上）。并可通过<code>v-bind=&quot;$attrs&quot;</code>传入到内部组件中</p></blockquote><blockquote><p><code>$listeners</code>: 当组件被调用时，外部监听的这个组件的所有事件都可以通过<code>$listeners</code>获取到。并可通过<code>v-on=&quot;$listeners&quot;</code>传入到内部组件中。</p></blockquote><p>修改弹框代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!---使用了v-bind与v-on监听属性与事件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visibleDialog&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他代码不变--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">//默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) </span></span><br><span class="language-javascript">    <span class="hljs-comment">//将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。</span></span><br><span class="language-javascript">    <span class="hljs-comment">//通过设置 inheritAttrs 到 false，这些默认行为将会被去掉</span></span><br><span class="language-javascript">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript"> &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!---外部使用方式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">custom-dialog</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visibleDialog&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;测试弹框&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">opened</span>=<span class="hljs-string">&quot;$_handleOpened&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  这是一段内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">custom-dialog</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>对于<code>$attrs</code>，我们也可以使用<code>$props</code>来代替, 实现代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-dialog</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visibleDialog&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$props&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--其他代码不变--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Dialog</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 将Dialog的props通过扩展运算符展开到props属性里面</span></span><br><span class="language-javascript">    ...<span class="hljs-title class_">Dialog</span>.<span class="hljs-property">props</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>但上面的代码存在一定的缺陷，有些组件存在非<code>props</code>的属性，比如对于一些封装的表单组件，我们可能需要给组件传入原生属性，但实际原生属性并没有在组件的<code>props</code>上面定义，这时候，如果通过上面的方式去包装组件，那么这些原生组件将无法传递到内部组件里面。</p><p>感谢 @陌上兮月的提醒</p><blockquote><h3 id="使用require-context实现前端工程自动化"><a href="#使用require-context实现前端工程自动化" class="headerlink" title="使用require.context实现前端工程自动化"></a>使用<code>require.context</code>实现前端工程自动化</h3></blockquote><p><code>require.context</code>是一个<code>webpack</code>提供的 Api, 通过执行<code>require.context</code>函数获取一个特定的上下文, 主要是用于实现自动化导入模块。</p><p>什么时候用？ 当一个 js 里面需要手动引入过多的其他文件夹里面的文件时，就可以使用。</p><p>在 Vue 项目开发过程中，我们可能会遇到这些可能会用到<code>require.context</code>的场景</p><ol><li>当我们路由页面比较多的时候，可能会将路由文件拆分成多个，然后再通过<code>import</code>引入到<code>index.js</code>路由主入口文件中</li><li>当使用 svg symbol 时候，需要将所有的 svg 图片导入到系统中（建议使用 svg-sprite-loader）</li><li>开发了一系列基础组件，然后把所有组件都导入到<code>index.js</code>中，然后再放入一个数组中，通过遍历数组将所有组件进行安装。</li></ol><p>对于上述的几个场景，如果我们需要导入的文件比较少的情况下，通过<code>import</code>一个一个去导入还可以接受，但对于量比较大的情况，就变成了纯体力活，而且每次修改增加都需要在主入口文件内进行调整。这时候我们就可以通过<code>require.context</code>去简化这个过程。</p><p>现在以上述第三条为例, 来说明<code>require.context</code>的用法</p><h4 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h4><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a8f846a8e5b05?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>组件通过常规方式安装</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a8dbf913be740?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="require-context基本语法"><a href="#require-context基本语法" class="headerlink" title="require.context基本语法"></a><code>require.context</code>基本语法</h4><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a900bd9c4737a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="通过require-context安装Vue组件"><a href="#通过require-context安装Vue组件" class="headerlink" title="通过require.context安装Vue组件"></a>通过<code>require.context</code>安装<code>Vue</code>组件</h4><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a907e5f763528?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><h3 id="自定义v-model-原来这么简单"><a href="#自定义v-model-原来这么简单" class="headerlink" title="自定义v-model, 原来这么简单"></a>自定义<code>v-model</code>, 原来这么简单</h3></blockquote><p>在用 Vue 开发前端时，不论使用原生还是封装好的 UI 库，对于表单组件，一般都会使用到<code>v-model</code>。虽然<code>v-model</code>是一个语法糖，但是吃到嘴里挺甜的啊。学会自定义<code>v-model</code>，还是很有必要的。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>一个组件上的<code>v-model</code>默认是通过在组件上面定义一个名为<code>value</code>的 props, 同时对外暴露一个名为<code>input</code>的事件。</p><p>源码：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a1c3637bed854?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>使用方式：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a1c469f10e131?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="自定义属性与事件"><a href="#自定义属性与事件" class="headerlink" title="自定义属性与事件"></a>自定义属性与事件</h4><p>通常情况下，使用<code>value</code>属性与<code>input</code>事件没有问题，但是有时候有些组件会将<code>value</code>属性或<code>input</code>事件用于不同的目的，比如对于单选框、复选框等类型的表单组件的<code>value</code>属性就有其他用处，参考（<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;…</a>）。或者希望属性名称或事件名称与实际行为更贴切，比如<code>active</code>,<code>checked</code>等属性名。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/11/172a1d912a292ee2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><h3 id="使用-sync-更优雅的实现数据双向绑定"><a href="#使用-sync-更优雅的实现数据双向绑定" class="headerlink" title="使用.sync, 更优雅的实现数据双向绑定"></a>使用<code>.sync</code>, 更优雅的实现数据双向绑定</h3></blockquote><p>在<code>Vue</code>中，<code>props</code>属性是单向数据传输的, 父级的 prop 的更新会向下流动到子组件中，但是反过来不行。可是有些情况，我们需要对 prop 进行 “双向绑定”。上文中，我们提到了使用<code>v-model</code>实现双向绑定。但有时候我们希望一个组件可以实现多个数据的 “双向绑定”，而<code>v-model</code>一个组件只能有一个 (Vue3.0 可以有多个)，这时候就需要使用到<code>.sync</code>。</p><h4 id="sync与v-model的异同"><a href="#sync与v-model的异同" class="headerlink" title=".sync与v-model的异同"></a><code>.sync</code>与<code>v-model</code>的异同</h4><p>相同点：</p><ul><li>两者的本质都是语法糖，目的都是实现组件与外部数据的双向绑定</li><li>两个都是通过属性 + 事件来实现的</li></ul><p>不同点 (个人观点，如有不对，麻烦下方评论指出，谢谢)：</p><ul><li>一个组件只能定义一个<code>v-model</code>, 但可以定义多个<code>.sync</code></li><li><code>v-model</code>与<code>.sync</code>对于的事件名称不同，<code>v-model</code>默认事件为<code>input</code>, 可以通过配置<code>model</code>来修改，<code>.sync</code>事件名称固定为<code>update:属性名</code></li></ul><h4 id="自定义-sync"><a href="#自定义-sync" class="headerlink" title="自定义.sync"></a>自定义<code>.sync</code></h4><p>在开发业务时，有时候需要使用一个遮罩层来阻止用户的行为（更多会使用遮罩层 + loading 动画），下面通过自定义<code>.sync</code>来实现一个遮罩层</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a70e9a027bdc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--调用方式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">custom-overlay</span> <span class="hljs-attr">:visible.sync</span>=<span class="hljs-string">&quot;visible&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">visible</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><blockquote><h3 id="动态组件，让页面渲染更灵活"><a href="#动态组件，让页面渲染更灵活" class="headerlink" title="动态组件，让页面渲染更灵活"></a>动态组件，让页面渲染更灵活</h3></blockquote><p>前两天产品经理来了新的需求了，告诉我，需要根据用户的权限不同，页面上要显示不同的内容，然后我就哼哧哼哧的将不同权限对应的组件写了出来，然后再通过<code>v-if</code>来判断要显示哪个组件，就有了下面的代码</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/12/172a9129b675bca4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>但是看到上面代码的那一长串<code>v-if</code>,<code>v-else-if</code>, 我感觉我的代码洁癖症要犯了，不行，这样<code>code review</code>过不了关，我连自己这一关都过不了，这时候就改动态组件发挥作用了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;roleComponent&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;roleComponent&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AdminInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin-info&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BookkeeperInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bookkeeper-info&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HrInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hr-info&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UserInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user-info&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">AdminInfo</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">BookkeeperInfo</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">HrInfo</span>,</span><br><span class="language-javascript">    <span class="hljs-title class_">UserInfo</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">roleComponents</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">admin</span>: <span class="hljs-title class_">AdminInfo</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">bookkeeper</span>: <span class="hljs-title class_">BookkeeperInfo</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">hr</span>: <span class="hljs-title class_">HrInfo</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">user</span>: <span class="hljs-title class_">UserInfo</span></span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;user&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">roleComponent</span>: <span class="hljs-literal">undefined</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> &#123; role, roleComponents &#125; = <span class="hljs-variable language_">this</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">roleComponent</span> = roleComponents[role]</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><blockquote><h3 id="mixins，更高效的实现组件内容的复用"><a href="#mixins，更高效的实现组件内容的复用" class="headerlink" title="mixins，更高效的实现组件内容的复用"></a><code>mixins</code>，更高效的实现组件内容的复用</h3></blockquote><p><code>mixins</code>是<code>Vue</code>提供的一种混合机制，用来更高效的实现组件内容的复用。怎么去理解混入呢，我觉得和<code>Object.assign</code>，但实际与<code>Object.assign</code>又有所不同。</p><h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><p>在开发 echarts 图表组件时，需要在窗口尺寸发生变化时，重置图表的大小，此时如果在每个组件里面都去实现一段监听代码，代码重复太多了，此时就可以使用混入来解决这个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 混入代码 resize-mixins.js</span><br><span class="hljs-keyword">import</span> &#123; debounce &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><br><span class="hljs-keyword">const</span> resizeChartMethod = <span class="hljs-string">&#x27;$__resizeChartMethod&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在组件内部将图表init的引用映射到chart属性上</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">chart</span>: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-variable language_">this</span>[resizeChartMethod])<br>  &#125;,<br>  <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;reisze&#x27;</span>, <span class="hljs-variable language_">this</span>[resizeChartMethod])<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-comment">// 通过lodash的防抖函数来控制resize的频率</span><br>    [resizeChartMethod]: <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span>.<span class="hljs-title function_">resize</span>()<br>      &#125;<br>    &#125;, <span class="hljs-number">100</span>)<br>  &#125;<br>&#125;<br><br>复制代码<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--图表组件代码--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chart&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> echartMixins <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./echarts-mixins&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-comment">// mixins属性用于导入混入，是一个数组，数组可以传入多个混入对象</span></span><br><span class="language-javascript">  <span class="hljs-attr">mixins</span>: [echartMixins],</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">chart</span>: <span class="hljs-literal">null</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span> = echarts.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="不同位置的混入规则"><a href="#不同位置的混入规则" class="headerlink" title="不同位置的混入规则"></a>不同位置的混入规则</h4><p>在<code>Vue</code>中，一个混入对象可以包含任意组件选项，但是对于不同的组件选项，会有不同的合并策略。</p><ol><li><p><code>data</code> 对于<code>data</code>, 在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主，如上例中的<code>chart</code>属性</p></li><li><p>生命周期钩子函数</p></li></ol><p>对于生命周期钩子函数，混入时会将同名钩子函数加入到一个数组中，然后在调用时依次执行。混入对象里面的钩子函数会优先于组件的钩子函数执行。如果一个组件混入了多个对象，对于混入对象里面的同名钩子函数，将按照数组顺序依次执行，如下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mixin1 = &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第一个输出的&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> mixin2 = &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第二个输出的&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">mixins</span>: [mixin1, mixin2],<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是第三个输出的&#x27;</span>)<br>  &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><ol start="3"><li>其他选项 对于值为对象的选项，如<code>methods</code>,<code>components</code>,<code>filter</code>,<code>directives</code>,<code>props</code>等等，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li></ol><h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p>混入也可以进行全局注册。一旦使用全局混入，那么混入的选项将在所有的组件内生效，如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将埋点方法通过全局混入添加到每个组件内部</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 建议将埋点方法绑定到Vue的原型链上面，如： Vue.prototype.$track = () =&gt; &#123;&#125;</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-title function_">track</span>(<span class="hljs-params">message</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message)<br>    &#125;<br>  &#125;<br>&#125;)<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，</strong></p><p>原文地址 <a href="https://juejin.im/post/5eddbaee5188254344768fdc">juejin.im</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue兄弟组件间传数据的方法-事件</title>
    <link href="/2020/07/20/vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2020/07/20/vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="vm-on-event-callback-vue-API"><a href="#vm-on-event-callback-vue-API" class="headerlink" title="vm.$on(event, callback)vue API"></a>vm.$on(event, callback)<a href="https://cn.vuejs.org/v2/api/#vm-on">vue API</a></h2><span id="more"></span><p><strong>用法：</strong> 监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$on(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)<br>&#125;)<br>vm.$emit(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>)<br><span class="hljs-comment">// =&gt; &quot;hi&quot;</span><br></code></pre></td></tr></table></figure><h2 id="vm-once-event-callback-vue-API"><a href="#vm-once-event-callback-vue-API" class="headerlink" title="vm.$once(event, callback) vue API"></a>vm.$once(event, callback) <a href="https://cn.vuejs.org/v2/api/#vm-once">vue API</a></h2><p><strong>用法：</strong> 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p><h2 id="vm-off-event-callback-vue-API"><a href="#vm-off-event-callback-vue-API" class="headerlink" title="vm.$off([event, callback] ) vue API"></a>vm.$off([event, callback] ) <a href="https://cn.vuejs.org/v2/api/#vm-off">vue API</a></h2><p><strong>用法：</strong></p><ul><li>移除自定义事件监听器。<ol><li><p>如果没有提供参数，则移除所有的事件监听器；</p></li><li><p>如果只提供了事件，则移除该事件所有的监听器；</p></li><li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p></li></ol></li></ul><h2 id="vm-emit-eventName-…args-vue-API"><a href="#vm-emit-eventName-…args-vue-API" class="headerlink" title="vm.$emit(eventName, […args] ) vue API"></a>vm.$emit(eventName, […args] ) <a href="https://cn.vuejs.org/v2/api/#vm-emit">vue API</a></h2><p><strong>用法：</strong> 触发当前实例上的事件。附加参数都会传给监听器回调。<br>示例：只配合一个事件名使用 $emit：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-button</span> <span class="hljs-attr">v-on:welcome</span>=<span class="hljs-string">&quot;sayHi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>Vue.component(&#x27;welcome-button&#x27;, &#123;<br>  template: `<br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;welcome&#x27;)&quot;</span>&gt;</span><br>      Click me to be welcomed<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  `<br>&#125;)<br>new Vue(&#123;<br>  el: &#x27;#emit-example-simple&#x27;,<br>  methods: &#123;<br>    sayHi: function () &#123;<br>      alert(&#x27;Hi!&#x27;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>配合额外的参数使用 <code>$emit</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 添加事件侦听器  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">magic-eight-ball</span> <span class="hljs-attr">v-on:give-advice</span>=<span class="hljs-string">&quot;showAdvice&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">magic-eight-ball</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>Vue.component(&#x27;magic-eight-ball&#x27;, &#123;<br>  data: function () &#123;<br>    return &#123;<br>      possibleAdvice: [&#x27;Yes&#x27;, &#x27;No&#x27;, &#x27;Maybe&#x27;]<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    giveAdvice: function () &#123;<br>    //根据数组长度 随机取数<br>      var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)<br>      //触发示例事件  从数组中随机取一元素传参<br>      this.$emit(&#x27;give-advice&#x27;, this.possibleAdvice[randomAdviceIndex])<br>    &#125;<br>  &#125;,<br>  template: `<br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;giveAdvice&quot;</span>&gt;</span><br>      Click me for advice<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  `<br>&#125;)<br><br>new Vue(&#123;<br>  el: &#x27;#emit-example-argument&#x27;,<br>  methods: &#123;<br>    showAdvice: function (advice) &#123;<br>      alert(advice)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="兄弟组件传数据"><a href="#兄弟组件传数据" class="headerlink" title="兄弟组件传数据"></a>兄弟组件传数据</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>兄弟组件数据交互<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle&#x27;</span>&gt;</span>销毁事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aaa</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aaa</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bbb</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bbb</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 提供事件中心</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> hub=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 组件  aaa</span></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>,&#123;</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript"><span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;这里是a&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">txt</span>:<span class="hljs-string">&#x27;我是a被给到兄弟的数据~~~&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">test</span>:<span class="hljs-string">&#x27;这里的数据会变化的！！！&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">&quot;&lt;div&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;p&gt;&#123;&#123;test&#125;&#125;&lt;/p&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;button @click=&#x27;changes&#x27;&gt;数据给b&lt;/button&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;&quot;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">changes</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">hub.$emit(<span class="hljs-string">&#x27;aaaData&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">txt</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">mounted</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">hub.$on(<span class="hljs-string">&#x27;bbbData&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>=val;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"><span class="hljs-comment">// 组件  bbb</span></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;bbb&#x27;</span>,&#123;</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript"><span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;这里是b&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">txt</span>:<span class="hljs-string">&#x27;我是b给到a兄弟下的数据&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">test</span>:<span class="hljs-string">&#x27;这里的数据会变化的！！！&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">template</span>:<span class="hljs-string">&quot;&lt;div&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;p&gt;&#123;&#123;test&#125;&#125;&lt;/p&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;button @click=&#x27;changes&#x27;&gt;数据给a&lt;/button&gt;\</span></span><br><span class="hljs-string"><span class="language-javascript">&lt;/div&gt;&quot;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">changes</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">hub.$emit(<span class="hljs-string">&#x27;bbbData&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">txt</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">hub.$on(<span class="hljs-string">&#x27;aaaData&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>=val;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"><span class="hljs-comment">// 实例化 Vue</span></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-comment">//移除自定义事件监听器。</span></span><br><span class="language-javascript"><span class="hljs-title function_">handle</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">hub.$off(<span class="hljs-string">&#x27;aaaData&#x27;</span>);</span><br><span class="language-javascript">hub.$off(<span class="hljs-string">&#x27;bbbData&#x27;</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue的Render函数</title>
    <link href="/2020/07/12/Vue%E7%9A%84Render%E5%87%BD%E6%95%B0/"/>
    <url>/2020/07/12/Vue%E7%9A%84Render%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前几天想学学-Vue-中怎么编写可复用的组件，提到要对-Vue-的render函数有所了解。可仔细一想，对于-Vue-的render函数自己只是看了官方的一些介绍，并未深入一点去了解这方面的知识。为了更好的学习后续的知识，又折回来了解-Vue-中的render函数，这一切主要都是为了后续能更好的学习-Vue-的知识。回忆-Vue-的一些基本概念"><a href="#前几天想学学-Vue-中怎么编写可复用的组件，提到要对-Vue-的render函数有所了解。可仔细一想，对于-Vue-的render函数自己只是看了官方的一些介绍，并未深入一点去了解这方面的知识。为了更好的学习后续的知识，又折回来了解-Vue-中的render函数，这一切主要都是为了后续能更好的学习-Vue-的知识。回忆-Vue-的一些基本概念" class="headerlink" title="前几天想学学 Vue 中怎么编写可复用的组件，提到要对 Vue 的render函数有所了解。可仔细一想，对于 Vue 的render函数自己只是看了官方的一些介绍，并未深入一点去了解这方面的知识。为了更好的学习后续的知识，又折回来了解 Vue 中的render函数，这一切主要都是为了后续能更好的学习 Vue 的知识。回忆 Vue 的一些基本概念"></a>前几天想学学 Vue 中怎么编写可复用的组件，提到要对 Vue 的<code>render</code>函数有所了解。可仔细一想，对于 Vue 的<code>render</code>函数自己只是看了官方的一些介绍，并未深入一点去了解这方面的知识。为了更好的学习后续的知识，又折回来了解 Vue 中的<code>render</code>函数，这一切主要都是为了后续能更好的学习 Vue 的知识。<br><span id="more"></span><br>回忆 Vue 的一些基本概念</h2><p>今天我们学习的目的是了解和学习 Vue 的<code>render</code>函数。如果想要更好的学习 Vue 的<code>render</code>函数相关的知识，我们有必要重温一下 Vue 中的一些基本概念。那么先上一张图，这张图从宏观上展现了 Vue 整体流程：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-32832d6b08b108c4.jpg"></p><p>image</p><p>从上图中，不难发现一个 Vue 的应用程序是如何运行起来的，模板通过编译生成 AST，再由 AST 生成 Vue 的<code>render</code>函数（渲染函数），渲染函数结合数据生成 Virtual DOM 树，Diff 和 Patch 后生成新的 UI。从这张图中，可以接触到 Vue 的一些主要概念：</p><ul><li><strong>模板</strong>：Vue 的模板基于纯 HTML，基于 Vue 的模板语法，我们可以比较方便地声明数据和 UI 的关系。</li><li><strong>AST</strong>：AST 是 <strong>Abstract Syntax Tree</strong> 的简称，Vue 使用 HTML 的 Parser 将 HTML 模板解析为 AST，并且对 AST 进行一些优化的标记处理，提取最大的静态树，方便 Virtual DOM 时直接跳过 Diff。</li><li><strong>渲染函数</strong>：渲染函数是用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制 （这部分是我们今天主要要了解和学习的部分）。</li><li><strong>Virtual DOM</strong>：虚拟 DOM 树，Vue 的 Virtual DOM Patching 算法是基于 <strong><a href="https://github.com/snabbdom/snabbdom">Snabbdom</a></strong> 的实现，并在些基础上作了很多的调整和改进。</li><li><strong>Watcher</strong>：每个 Vue 组件都有一个对应的<code>watcher</code>，这个<code>watcher</code>将会在组件<code>render</code>的时候收集组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染。你根本不需要写<code>shouldComponentUpdate</code>，Vue 会自动优化并更新要更新的 UI。</li></ul><p>上图中，<code>render</code>函数可以作为一道分割线，<code>render</code>函数的左边可以称之为<strong>编译期</strong>，将 Vue 的模板转换为<strong>渲染函数</strong>。<code>render</code>函数的右边是 Vue 的运行时，主要是基于渲染函数生成 Virtual DOM 树，Diff 和 Patch。</p><h2 id="渲染函数的基础"><a href="#渲染函数的基础" class="headerlink" title="渲染函数的基础"></a>渲染函数的基础</h2><p>Vue 推荐在绝大多数情况下使用<code>template</code>来创建你的 HTML。然而在一些场景中，需要使用 JavaScript 的编程能力和创建 HTML，这就是**<code>render</code>函数**，它比<code>template</code>更接近编译器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> &gt;</span><br>        Hello world!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 HTML 层，我们决定这样定义组件接口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">anchored-heading</span> <span class="hljs-attr">:level</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">anchored-heading</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们开始写一个通过<code>level</code>的<code>prop</code>动态生成<code>heading</code>标签的组件，你可能很快想到这样实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script type=<span class="hljs-string">&quot;text/x-template&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;level === 1&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;level === 2&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;level === 3&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;level === 4&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;level === 5&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h6</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;level === 6&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></span><br>&lt;/script&gt;<br><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;anchored-heading&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#anchored-heading-template&#x27;</span>,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">level</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在这种场景中使用 <code>template</code> 并不是最好的选择：首先代码冗长，为了在不同级别的标题中插入锚点元素，我们需要重复地使用 <code>&lt;slot&gt;&lt;/slot&gt;</code>。</p><p>虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 <code>render</code> 函数重写上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;anchored-heading&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br>            <span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>,   <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <br>        )<br>    &#125;,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">level</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 <code>slot</code> 属性向组件中传递内容时，比如 <code>anchored-heading</code> 中的 <code>Hello world!</code>，这些子元素被存储在组件实例中的 <code>$slots.default</code>中。</p><h2 id="节点、树以及虚拟-DOM"><a href="#节点、树以及虚拟-DOM" class="headerlink" title="节点、树以及虚拟 DOM"></a>节点、树以及虚拟 DOM</h2><p>对 Vue 的一些概念和渲染函数的基础有一定的了解之后，我们需要对一些浏览器的工作原理有一些了解，这样对我们学习<code>render</code>函数是很重要的。比如下面的这段 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    Some text content<br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当浏览器读到这些代码时，它会建立一个 **<a href="https://javascript.info/dom-nodes">DOM 节点树</a>**来保持追踪，如果你会画一张家谱树来追踪家庭成员的发展一样。</p><p>HTML 的 DOM 节点树如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-53f54999b1bc18e9.png"></p><p>image</p><p>每个元素都是一个节点。每片文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。</p><p>高效的更新所有这些节点会是比较困难的，不过所幸你不必再手动完成这个工作了。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：</p><p>或者一个渲染函数里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">blogTitle</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这两种情况下，Vue 都会自动保持页面的更新，即便 <code>blogTitle</code> 发生了改变。</p><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><p>在 Vue 2.0 中，渲染层的实现做了根本性改动，那就是引入了虚拟 DOM。</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-4eb2a73597a2a9aa.png"></p><p>image</p><p>Vue 的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个<strong>虚拟 DOM 的树</strong>。</p><p>当我们有了这个虚拟的树之后，再交给一个 <strong>Patch 函数</strong>，负责把这些虚拟 DOM 真正施加到真实的 DOM 上。在这个过程中，Vue 有自身的响应式系统来侦测在渲染过程中所依赖到的数据来源。在渲染过程中，侦测到数据来源之后就可以精确感知数据源的变动。到时候就可以根据需要重新进行渲染。当重新进行渲染之后，会生成一个新的树，将新的树与旧的树进行对比，就可以最终得出应施加到真实 DOM 上的改动。最后再通过 Patch 函数施加改动。</p><p>简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在应该状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-4c7f8bdf4b804bd9.png"></p><p>image</p><p>Vue 支持我们通过<code>data</code>参数传递一个 JavaScript 对象做为组件数据，然后 Vue 将遍历此对象属性，使用 <a href="https://www.w3cplus.com/vue/vue-two-way-binding-object-defineproperty.html"><code>Object.defineProperty</code>方法</a>设置描述对象，通过存取器函数可以追踪该属性的变更，Vue 创建了一层<code>Watcher</code>层，在组件渲染的过程中把属性记录为依赖，之后当依赖项的<code>setter</code>被调用时，会通知<code>Watcher</code>重新计算，从而使它关联的组件得以更新, 如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-e5ab233db6c73c31.png"></p><p>image</p><p>有关于 Vue 的响应式相关的内容，可以阅读下列文章：</p><ul><li><a href="https://www.w3cplus.com/vue/understanding-vue-js-reactivity-depth-object-defineproperty.html">深入理解 Vue.js 响应式原理</a></li><li><a href="https://www.w3cplus.com/vue/vue-two-way-binding-object-defineproperty.html">Vue 双向绑定的实现原理<code>Object.defineproperty</code></a></li><li><a href="https://www.w3cplus.com/vue/vue-two-way-binding.html">Vue 的双向绑定原理及实现</a></li><li><a href="https://www.w3cplus.com/vue/vue-reactivity.html">Vue 中的响应式</a></li><li><a href="https://www.w3cplus.com/vue/reactive.html">从 JavaScript 属性描述器剖析 Vue.js 响应式视图</a></li></ul><p>对于 Vue 自带的响应式系统，并不是咱们今天要聊的东西。我们还是回到 Vue 的虚拟 DOM 中来。对于虚拟 DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了<code>模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</code>的一个过程</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-54ee24bdb630fb55.png"></p><p>image</p><p>其实 Vue 中的虚拟 DOM 还是很复杂的，我也是一知半解，如果你想深入的了解，可以阅读 @JoeRay61 的《<a href="https://segmentfault.com/a/1190000008291645">Vue 原理解析之 Virtual DOM</a>》一文。</p><p>通过前面的学习，我们初步了解到 Vue 通过建立一个<strong>虚拟 DOM</strong> 对真实 DOM 发生的变化保持追踪。比如下面这行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">blogTitle</span>)<br></code></pre></td></tr></table></figure><p><code>createElement</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 <code>createNodeDescription</code>，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为 “虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM” 是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p><p>Vue 组件树建立起来的整个 VNode 树是唯一的。这意味着，下面的**<code>render</code>函数是无效**的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>    <span class="hljs-keyword">var</span> myParagraphVNode = <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [<br>        <br>        myParagraphVNode, myParagraphVNode<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你真的需要重复很多次的元素 &#x2F; 组件，你可以使用工厂函数来实现。例如，下面这个例子 <code>render</code> 函数完美有效地渲染了 <code>20</code> 个重复的段落：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>,<br>        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">length</span>: <span class="hljs-number">20</span> &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>)<br>        &#125;)<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vue-的渲染机制"><a href="#Vue-的渲染机制" class="headerlink" title="Vue 的渲染机制"></a>Vue 的渲染机制</h2><p><img src="http://upload-images.jianshu.io/upload_images/13429147-b34d3ed28b6eccb6.png"></p><p>image</p><p>上图展示的是独立构建时的一个渲染流程图。</p><p>继续使用上面用到的模板到真实 DOM 过程的一个图：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-3466e87621454e79.png"></p><p>image</p><p>这里会涉及到 Vue 的另外两个概念：</p><ul><li><strong>独立构建</strong>：包含模板编译器，渲染过程<code>HTML字符串 → render函数 → VNode → 真实DOM节点</code></li><li><strong>运行时构建</strong>：不包含模板编译器，渲染过程<code>render函数 → VNode → 真实DOM节点</code></li></ul><p>运行时构建的包，会比独立构建少一个模板编译器。在<code>$mount</code>函数上也不同。而<code>$mount</code>方法又是整个渲染过程的起始点。用一张流程图来说明：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-7f193c6cb2e36da0.png"></p><p>image</p><p>由此图可以看到，在渲染过程中，提供了三种渲染模式，自定义<code>render</code>函数、<code>template</code>、<code>el</code>均可以渲染页面，也就是对应我们使用 Vue 时，三种写法：</p><h3 id="自定义render函数"><a href="#自定义render函数" class="headerlink" title="自定义render函数"></a>自定义<code>render函数</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;anchored-heading&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span> (<br>            <span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">level</span>,   <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <br>        )<br>    &#125;,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">level</span>: &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="template写法"><a href="#template写法" class="headerlink" title="template写法"></a><code>template</code>写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;`</span>,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="el写法"><a href="#el写法" class="headerlink" title="el写法"></a><code>el</code>写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这三种渲染模式最终都是要得到<code>render</code>函数。只不过用户自定义的<code>render</code>函数省去了程序分析的过程，等同于处理过的<code>render</code>函数，而普通的<code>template</code>或者<code>el</code>只是字符串，需要解析成 AST，再将 AST 转化为<code>render</code>函数。</p><blockquote><p><strong>记住一点，无论哪种方法，都要得到<code>render</code>函数。</strong></p></blockquote><p>我们在使用过程中具体要使用哪种调用方式，要根据具体的需求来。</p><p>如果是比较简单的逻辑，使用<code>template</code>和<code>el</code>比较好，因为这两种都属于声明式渲染，对用户理解比较容易，但灵活性比较差，因为最终生成的<code>render</code>函数是由程序通过 AST 解析优化得到的; 而使用自定义<code>render</code>函数相当于人已经将逻辑翻译给程序，能够胜任复杂的逻辑，灵活性高，但对于用户的理解相对差点。</p><h2 id="理解createElement"><a href="#理解createElement" class="headerlink" title="理解createElement"></a>理解<code>createElement</code></h2><p>在使用<code>render</code>函数，其中还有另一个需要掌握的部分，那就是<code>createElement</code>。接下来我们需要熟悉的是如何在<code>createElement</code>函数中生成模板。那么我们分两个部分来对<code>createElement</code>进行理解。</p><h3 id="createElement参数"><a href="#createElement参数" class="headerlink" title="createElement参数"></a><code>createElement</code>参数</h3><p><code>createElement</code>可以是接受多个参数：</p><h4 id="第一个参数：-String-Object-Function"><a href="#第一个参数：-String-Object-Function" class="headerlink" title="第一个参数：{String | Object | Function}"></a>第一个参数：<code>&#123;String | Object | Function&#125;</code></h4><p>第一个参数对于<code>createElement</code>而言是一个必须的参数，这个参数可以是字符串<code>string</code>、是一个对象<code>object</code>，也可以是一个函数<code>function</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-element</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的示例，给<code>createElement</code>传了一个<code>String</code>参数<code>&#39;div&#39;</code>，即传了一个 HTML 标签字符。最后会有一个<code>div</code>元素渲染出来：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-eb35f142664bda0c.png"></p><p>image</p><p>接着把上例中的<code>String</code>换成一个<code>Object</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(&#123;<br>            <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;Hello Vue!&lt;/div&gt;`</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上例传了一个<code>&#123;template: &#39;&lt;div&gt;Hello Vue!&lt;/div&gt;&#39;&#125;</code>对象。此时<code>custom-element</code>组件渲染出来的结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-cafcbeeddcfda7e4.png"></p><p>image</p><p>除此之外，还可以传一个<code>Function</code>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">var</span> eleFun = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;Hello Vue!&lt;/div&gt;`</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-title function_">eleFun</span>())<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最终得到的结果和上图是一样的。这里传了一个<code>eleFun()</code>函数给<code>createElement</code>，而这个函数返回的是一个对象。</p><h4 id="第二个参数-Object"><a href="#第二个参数-Object" class="headerlink" title="第二个参数:{Object}"></a>第二个参数:<code>&#123;Object&#125;</code></h4><p><code>createElement</code>是一个可选参数，这个参数是一个<code>Object</code>。来看一个小示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-element</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br><br>        <br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;<br>            <span class="hljs-string">&#x27;class&#x27;</span>: &#123;<br>                <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span><br>            &#125;,<br>            <span class="hljs-attr">style</span>: &#123;<br>                <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>                <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;14px&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">attrs</span>: &#123;<br>                <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;boo&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">domProps</span>: &#123;<br>                <span class="hljs-attr">innerHTML</span>: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>最终生成的 DOM，将会带一些属性和内容的<code>div</code>元素，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-bef18523b2d62e16.png"></p><p>image</p><h4 id="第三个参数：-String-Array"><a href="#第三个参数：-String-Array" class="headerlink" title="第三个参数：{String | Array}"></a>第三个参数：{String | Array}</h4><p><code>createElement</code>还有第三个参数，这个参数是可选的，可以给其传一个<code>String</code>或<code>Array</code>。比如下面这个小示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-element</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<br>            <span class="hljs-string">&#x27;div&#x27;</span>, <br>            &#123;<br>                <span class="hljs-attr">class</span>: &#123;<br>                    <span class="hljs-attr">title</span>: <span class="hljs-literal">true</span><br>                &#125;,<br>                <span class="hljs-attr">style</span>: &#123;<br>                    <span class="hljs-attr">border</span>: <span class="hljs-string">&#x27;1px solid&#x27;</span>,<br>                    <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;10px&#x27;</span><br>                &#125;<br>            &#125;, <br>            [<br>                <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;Hello Vue!&#x27;</span>),<br>                <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;开始学习Vue!&#x27;</span>)<br>            ] <br>        )<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>最终的效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-1c69ce736a29a3c1.png"></p><p>image</p><p>其实从上面这几个小例来看，不难发现，以往我们使用<code>Vue.component()</code>创建组件的方式，都可以用<code>render</code>函数配合<code>createElement</code>来完成。你也会发现，使用<code>Vue.component()</code>和<code>render</code>各有所长，正如文章开头的一个示例代码，就不适合<code>Vue.component()</code>的<code>template</code>，而使用<code>render</code>更方便。</p><p>接下来看一个小示例，看看<code>template</code>和<code>render</code>方式怎么创建相同效果的一个组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-element</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div :class=&quot;&#123;show: show&#125;&quot; @click=&quot;handleClick&quot;&gt;Hello Vue!&lt;/div&gt;`</span>,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Clicked!&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上面<code>Vue.component()</code>中的代码换成<code>render</code>函数之后，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-element&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123;<br>            <span class="hljs-attr">class</span>: &#123;<br>                <span class="hljs-attr">show</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span><br>            &#125;,<br>            <span class="hljs-attr">attrs</span>: &#123;<br>                <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;box&#x27;</span><br>            &#125;,<br>            <span class="hljs-attr">on</span>: &#123;<br>                <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span><br>            &#125;<br>        &#125;, <span class="hljs-string">&#x27;Hello Vue!&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-attr">handleClick</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Clicked!&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后声明一个 Vue 实例，并挂载到<code>id</code>为<code>#app</code>的一个元素上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="createElement解析过程"><a href="#createElement解析过程" class="headerlink" title="createElement解析过程"></a><code>createElement</code>解析过程</h3><p>简单的来看一下<code>createElement</code>解析的过程，这部分需要对 JS 有一些功底。不然看起来有点蛋疼：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SIMPLE_NORMALIZE</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ALWAYS_NORMALIZE</span> = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span> (<span class="hljs-params">context, tag, data, children, normalizationType, alwaysNormalize</span>) &#123;<br><br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(data) || <span class="hljs-title function_">isPrimitive</span>(data)) &#123;<br>        normalizationType = children<br>        children = data<br>        data = <span class="hljs-literal">undefined</span><br>    &#125;<br><br>    <br>    <br>    <span class="hljs-keyword">if</span> (alwaysNormalize) normalizationType = <span class="hljs-variable constant_">ALWAYS_NORMALIZE</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_createElement</span>(context, tag, data, children, normalizationType)<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_createElement</span> (<span class="hljs-params">context, tag, data, children, normalizationType</span>) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (data &amp;&amp; data.<span class="hljs-property">__ob__</span>) &#123;<br>            process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; <span class="hljs-title function_">warn</span>(<br>            <span class="hljs-string">`Avoid using observed data object as vnode data: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +<br>            <span class="hljs-string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,<br>            context<br>            )<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createEmptyVNode</span>()<br>        &#125;<br><br>        <br>        <br>        <br>        <span class="hljs-keyword">if</span> (!tag) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createEmptyVNode</span>()<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children) &amp;&amp; <span class="hljs-keyword">typeof</span> children[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            data = data || &#123;&#125;<br>            data.<span class="hljs-property">scopedSlots</span> = &#123; <span class="hljs-attr">default</span>: children[<span class="hljs-number">0</span>] &#125;<br>            children.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>        &#125;<br><br>        <br>        <span class="hljs-keyword">if</span> (normalizationType === <span class="hljs-variable constant_">ALWAYS_NORMALIZE</span>) &#123;<br>            children = <span class="hljs-title function_">normalizeChildren</span>(children)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (normalizationType === <span class="hljs-variable constant_">SIMPLE_NORMALIZE</span>) &#123;<br>            children = <span class="hljs-title function_">simpleNormalizeChildren</span>(children)<br>        &#125;<br>        <span class="hljs-keyword">let</span> vnode, ns<br><br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> tag === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-title class_">Ctor</span><br>            <br>            ns = config.<span class="hljs-title function_">getTagNamespace</span>(tag)<br><br>            <br>            <span class="hljs-keyword">if</span> (config.<span class="hljs-title function_">isReservedTag</span>(tag)) &#123;<br>                <br>                vnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<br>                    config.<span class="hljs-title function_">parsePlatformTagName</span>(tag), data, children,<br>                    <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, context<br>                )<br><br>                <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">Ctor</span> = <span class="hljs-title function_">resolveAsset</span>(context.<span class="hljs-property">$options</span>, <span class="hljs-string">&#x27;components&#x27;</span>, tag))) &#123;<br>                <br>                vnode = <span class="hljs-title function_">createComponent</span>(<span class="hljs-title class_">Ctor</span>, data, context, children, tag)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <br>                vnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>(<br>                    tag, data, children,<br>                    <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, context<br>                )<br>            &#125;<br><br>        <br>        <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vnode = <span class="hljs-title function_">createComponent</span>(tag, data, context, children)<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">if</span> (vnode) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (ns) <span class="hljs-title function_">applyNS</span>(vnode, ns)<br>            <span class="hljs-keyword">return</span> vnode<br>        <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createEmptyVNode</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的梳理了一个流程图，可以参考下</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-e0558045f83150dd.png"></p><p>image</p><blockquote><p>这部分代码和流程图来自于 @JoeRay61 的《<a href="https://segmentfault.com/a/1190000008291645">Vue 原理解析之 Virtual DOM</a>》一文。</p></blockquote><h2 id="使用-JavaScript-代替模板功能"><a href="#使用-JavaScript-代替模板功能" class="headerlink" title="使用 JavaScript 代替模板功能"></a>使用 JavaScript 代替模板功能</h2><p>在使用 Vue 模板的时候，我们可以在模板中灵活的使用 <a href="https://www.w3cplus.com/vue/v-if-vs-v-show.html"><code>v-if</code></a>、<a href="https://www.w3cplus.com/vue/v-for.html"><code>v-for</code></a>、<a href="https://www.w3cplus.com/vue/v-model.html"><code>v-model</code></a>和 <a href="https://www.w3cplus.com/vue/vue-slot.html"><code>&lt;slot&gt;</code></a>之类的。但在<code>render</code>函数中是没有提供专用的 API。如果在<code>render</code>使用这些，需要使用原生的 JavaScript 来实现。</p><h3 id="v-if和v-for"><a href="#v-if和v-for" class="headerlink" title="v-if和v-for"></a><code>v-if</code>和<code>v-for</code></h3><p>在<code>render</code>函数中可以使用<code>if/else</code>和<code>map</code>来实现<code>template</code>中的<code>v-if</code>和<code>v-for</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;items.length&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>No items found.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>换成<code>render</code>函数，可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;item-list&#x27;</span>,&#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;items&#x27;</span>],<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;ul&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;item&#x27;</span>)<br>            &#125;))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;No items found.&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;)<br><br>&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">item-list</span> <span class="hljs-attr">:items</span>=<span class="hljs-string">&quot;items&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">item-list</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">items</span>: [<span class="hljs-string">&#x27;大漠&#x27;</span>, <span class="hljs-string">&#x27;W3cplus&#x27;</span>, <span class="hljs-string">&#x27;blog&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>得到的效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-b4d9489c6fd49ab6.gif"></p><p>image</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h3><p><code>render</code>函数中也没有与<code>v-model</code>相应的 API，如果要实现<code>v-model</code>类似的功能，同样需要使用原生 JavaScript 来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">:</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;val =&gt; name = val&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;el-input&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;input&#x27;</span>, &#123;<br>            <span class="hljs-attr">domProps</span>: &#123;<br>                <span class="hljs-attr">value</span>: self.<span class="hljs-property">name</span><br>            &#125;,<br>            <span class="hljs-attr">on</span>: &#123;<br>                <span class="hljs-attr">input</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>                    self.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-title function_">data</span> () &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;大漠&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>刷新你的浏览器，可以看到效果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/13429147-a59263e3580b34ee.png"></p><p>image</p><p>这就是深入底层要付出的，尽管麻烦了一些，但相对于 <code>v-model</code> 来说，你可以更灵活地控制。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>你可以从<code>this.$slots</code>获取 VNodes 列表中的静态内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以从<code>this.$scopedSlots</code>中获得能用作函数的作用域插槽，这个函数返回 VNodes:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;message&#x27;</span>],<br><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$scopedSlots</span>.<span class="hljs-title function_">default</span>(&#123;<br>            <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span><br>        &#125;)<br>    ])<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据中的<code>scopedSlots</code>域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">custom-ele</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-ele</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;custom-ele&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [<br>            <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;child&#x27;</span>, &#123;<br>                <span class="hljs-attr">scopedSlots</span>: &#123;<br>                    <span class="hljs-attr">default</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">props</span>) &#123;<br>                        <span class="hljs-keyword">return</span> [<br>                            <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-string">&#x27;From Parent Component&#x27;</span>),<br>                            <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>, props.<span class="hljs-property">text</span>)<br>                        ]<br>                    &#125;<br>                &#125;<br>            &#125;)<br>        ])<br>    &#125;<br>&#125;)<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child&#x27;</span>, &#123;<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;strong&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$scopedSlots</span>.<span class="hljs-title function_">default</span>(&#123;<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;This is Child Component&#x27;</span><br>        &#125;))<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>如果写习惯了<code>template</code>，然后要用<code>render</code>函数来写，一定会感觉好痛苦，特别是面对复杂的组件的时候。不过我们在 Vue 中使用 JSX 可以让我们回到更接近于模板的语法上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AnchoredHeading</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AnchoredHeading.vue&#x27;</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#demo&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">h</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AnchoredHeading</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&#123;1&#125;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> world!</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">AnchoredHeading</span>&gt;</span></span><br>        )<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 <code>h</code> 失去作用，在应用中会触发报错。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回过头来看，Vue 中的渲染核心关键的几步流程还是非常清晰的：</p><ul><li><code>new Vue</code>，执行初始化</li><li>挂载<code>$mount</code>方法，通过自定义<code>render</code>方法、<code>template</code>、<code>el</code>等生成<code>render</code>函数</li><li>通过<code>Watcher</code>监听数据的变化</li><li>当数据发生变化时，<code>render</code>函数执行生成 VNode 对象</li><li>通过<code>patch</code>方法，对比新旧 VNode 对象，通过 DOM Diff 算法，添加、修改、删除真正的 DOM 元素</li></ul><p>至此，整个<code>new Vue</code>的渲染过程完毕。</p><p>而这篇文章，主要把精力集中在<code>render</code>函数这一部分。学习了怎么用<code>render</code>函数来创建组件，以及了解了其中<code>createElement</code>。</p><p>最后要说的是，上文虽然以学习<code>render</code>函数，但文中涉及了 Vue 不少的知识点，也有点零乱。初学者自己根据自己获取所要的知识点。由于本人也是初涉 Vue 相关的知识点，如果文章中有不对之处，烦请路过的大神拍正。</p><p>原文地址 <a href="https://www.jianshu.com/p/7508d2a114d3">www.jianshu.com</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>element源码解析之checkbox</title>
    <link href="/2020/07/01/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bcheckbox/"/>
    <url>/2020/07/01/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bcheckbox/</url>
    
    <content type="html"><![CDATA[<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElCheckbox</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./src/checkbox&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElCheckboxGroup</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./src/checkbox-group.vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) &#123;<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">ElCheckboxGroup</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">ElCheckboxGroup</span>);<br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-title class_">ElCheckbox</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">ElCheckbox</span>);<br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123;<br>  <span class="hljs-title class_">ElCheckbox</span>,<br>  <span class="hljs-title class_">ElCheckboxGroup</span><br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><hr><h2 id="Checkbox-group"><a href="#Checkbox-group" class="headerlink" title="Checkbox-group"></a>Checkbox-group</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>checkbox-group</code>的<code>html</code>代码十分简单，就是一个<code>div.el-checkbox-group</code>包裹着一个<code>slot</code>，没有什么好说的，但是它在<code>script</code>里面做了许多处理。</p><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>监听<code>value</code>的变化，然后会触发一个<code>change</code>事件，并且根据<code>mixin</code>中的<code>emitter</code>增加的<code>dispatch</code>来向父组件派发事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-title function_">value</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;change&#x27;</span>, value);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;ElFormItem&#x27;</span>, <span class="hljs-string">&#x27;el.form.change&#x27;</span>, [value]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>具体的讲解将在<code>mixin篇</code>进行讲解，简单的说是模拟<code>vue 1.0</code>中的<code>$dispatch</code>，来将事件一直向上传递。</p><h2 id="Checkbox"><a href="#Checkbox" class="headerlink" title="Checkbox"></a>Checkbox</h2><p>我们还是先分析其生命周期。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>创建的时候根据<code>checked</code>这一<code>prop</code>来决定是否调用<code>addToStore</code>方法，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">methods: &#123;<br>  addToStore() &#123;<br>    <span class="hljs-keyword">if</span> (<br>      Array.isArray(<span class="hljs-keyword">this</span>.model) &amp;&amp;<br>      <span class="hljs-keyword">this</span>.model.indexOf(<span class="hljs-keyword">this</span>.label) === -<span class="hljs-number">1</span><br>    ) &#123;  <br>      <span class="hljs-keyword">this</span>.model.push(<span class="hljs-keyword">this</span>.label);<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>      <span class="hljs-keyword">this</span>.model = <span class="hljs-keyword">this</span>.trueLabel || <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>checkbox</code>组件一共有三种<code>label</code>，这里先列一下官方的说明，具体使用在接下来的分析中会提及：</p><ol><li><code>label</code>，选中状态的值（只有在<code>checkbox-group</code>或者绑定对象类型为<code>array</code>时有效），它的值是<code>string</code>；</li><li><code>true-label</code>，选中时的值，它的值是<code>string</code>或者<code>number</code>；</li><li><code>false-label</code>，没有选中时的值，它的值是<code>string</code>或者<code>number</code>。</li></ol><p>而<code>model</code>是一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">isGroup</span><br>        ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> !== <span class="hljs-literal">undefined</span>  <br>        ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfModel</span>;  <br>    &#125;,<br><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>) &#123;  <br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isGroup</span>) &#123;  <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;ElCheckboxGroup&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, [val]);  <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> !== <span class="hljs-literal">undefined</span>) &#123;  <br>        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, val);  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfModel</span> = val;  <br>      &#125;<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>其中<code>value</code>是一个<code>prop</code>，而<code>selfModel</code>是一个<code>data</code>上的属性，<code>store</code>是一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">store</span>(<span class="hljs-params"></span>) &#123;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_checkboxGroup</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">_checkboxGroup</span>.<span class="hljs-property">value</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>isGroup</code>是另一个计算属性，它将一直向父级查找到<code>el-checkbox-group</code>，如果有则返回<code>true</code>，否则返回<code>false</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">isGroup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>;<br>    <span class="hljs-keyword">while</span> (parent) &#123;<br>      <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">$options</span>.<span class="hljs-property">componentName</span> !== <span class="hljs-string">&#x27;ElCheckboxGroup&#x27;</span>) &#123;<br>        parent = parent.<span class="hljs-property">$parent</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_checkboxGroup</span> = parent;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>多选最外面是一个<code>label</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后是两个<code>span</code>，一个是<code>input</code>部分，另一个是<code>label</code>部分。</p><h2 id="el-checkbox-input"><a href="#el-checkbox-input" class="headerlink" title="el-checkbox__input"></a>el-checkbox__input</h2><p><code>el-checkbox__input</code>最外层也是一个<code>span</code>，并在上面设置了动态的<code>class</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-disabled&#x27;: disabled,  // 这是prop，控制是否可用</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-checked&#x27;: isChecked,  // 这是一个计算属性</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-indeterminate&#x27;: indeterminate,  // 这是prop，用来控制样式</span></span><br><span class="hljs-string"><span class="hljs-tag">    &#x27;is-focus&#x27;: focus  // 这是data属性，用来控制是否聚焦</span></span><br><span class="hljs-string"><span class="hljs-tag">  &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中<code>isChecked</code>的设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">isChecked</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (&#123;&#125;.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>) === <span class="hljs-string">&#x27;[object Boolean]&#x27;</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>;  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>)) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">label</span>) &gt; -<span class="hljs-number">1</span>;  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> !== <span class="hljs-literal">undefined</span>) &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">trueLabel</span>;  <br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="el-checkbox-inner"><a href="#el-checkbox-inner" class="headerlink" title="el-checkbox__inner"></a>el-checkbox__inner</h3><p>然后是用来表示前面对勾的<code>span</code>，它 主要通过<code>css</code>来控制对勾的显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>然后是传统的<code>input</code>，它的<code>type</code>是<code>checkbox</code>，但是这个<code>input</code>并不会显示，而且会根据传递的<code>prop</code>有两种不同的<code>input</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;trueLabel || falseLabel&quot;</span></span><br><span class="hljs-tag"> </span><br><span class="hljs-tag">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:true-value</span>=<span class="hljs-string">&quot;trueLabel&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:false-value</span>=<span class="hljs-string">&quot;falseLabel&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;model&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;$emit(&#x27;change&#x27;, $event)&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">focus</span>=<span class="hljs-string">&quot;focus = true&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">blur</span>=<span class="hljs-string">&quot;focus = false&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-else</span></span><br><span class="hljs-tag"> </span><br><span class="hljs-tag">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;disabled&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;label&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;model&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;$emit(&#x27;change&#x27;, $event)&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">focus</span>=<span class="hljs-string">&quot;focus = true&quot;</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">blur</span>=<span class="hljs-string">&quot;focus = false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它们不同的地方是，前者使用了<code>trueLabel</code>和<code>falseLabel</code>，后者使用了<code>label</code>它们都通过<code>v-model</code>绑定了<code>model</code>，在<code>change</code>的时候都会派发<code>change</code>事件，聚焦的时候会设置<code>focus</code>为<code>true</code>，</p><h2 id="el-checkbox-label"><a href="#el-checkbox-label" class="headerlink" title="el-checkbox__label"></a>el-checkbox__label</h2><p>标签部分可以通过匿名<code>slot</code>或者<code>label</code>进行设置，前者具有优先权。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$slots.default || label&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!$slots.default&quot;</span>&gt;</span>&#123;&#123;label&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：这里明显看出来，这和之前不是同一个人写的，这里值得注意的是<code>slot</code>内部的内容，在没有传入<code>slot</code>才会显示，因此不同特别做一个处理，也可能是有其他我没有考虑到的原因，如果以后发现了，会回来修正。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>element</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>element源码解析之emitter.js</title>
    <link href="/2020/06/29/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bemitter-js/"/>
    <url>/2020/06/29/element%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8Bemitter-js/</url>
    
    <content type="html"><![CDATA[<p>打开 emitter.js，发现该 js 是提供方法给其他组件做混入使用的。他对外有 dispatch 和 broadcast 两个接口，从命名和参数等方面，这两个方法应该大致是用来处理一些各层级之间事件的，也就是通信。我们先来看下 dispatch 方法。</p><span id="more"></span><h3 id="一、dispatch"><a href="#一、dispatch" class="headerlink" title="一、dispatch"></a>一、dispatch</h3><p>dispatch 方法有三个参数，</p><ul><li>componentName，表示组件名称，用于匹配正确到正确的组件名。</li><li>eventName，事件名，需要触发的事件</li><li>params，参数，触发时带入的参数</li></ul><p>前两行，用于查找到当前元素的父组件，如果没有就使用根节点，并取父组件的组件名用于后期匹配。</p><p>紧接着的是一个 while 循环，用于循环父组件，直到找到或者到达根元素，匹配不到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;<br>    parent = parent.<span class="hljs-property">$parent</span>;<br> <br>    <span class="hljs-keyword">if</span> (parent) &#123;<br>        name = parent.<span class="hljs-property">$options</span>.<span class="hljs-property">componentName</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环过程中不断记录组件名，用于判断是否找到。</p><p>最后一部分是，当有匹配到的父组件时，就去触发父组件的对应的事件函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (parent) &#123;<br>    parent.<span class="hljs-property">$emit</span>.<span class="hljs-title function_">apply</span>(parent,[eventName].<span class="hljs-title function_">concat</span>(params));<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看下 broadcast 函数。</p><h3 id="二、broadcast"><a href="#二、broadcast" class="headerlink" title="二、broadcast"></a>二、broadcast</h3><p>将 emitter 内部定义的一个 broadcast 函数利用 call 改变 this 指向。</p><p>broadcast 内直接对子组件进行遍历，当匹配到对应的组件名时，则去触发对应子组件的对应事件。如果没有，则递归继续查找子组件。</p><p>注：我们会发现每条向下传播的线路只要触发了一次对应的事件，就不会再向下传递了。</p><h3 id="三、源码"><a href="#三、源码" class="headerlink" title="三、源码"></a>三、源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">componentName, eventName, params</span>) &#123;<br>  <span class="hljs-comment">// 开始遍历子组件</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">var</span> name = child.<span class="hljs-property">$options</span>.<span class="hljs-property">componentName</span>;<br>    <span class="hljs-comment">// 匹配子组件的name</span><br>    <span class="hljs-keyword">if</span> (name === componentName) &#123;<br>      <span class="hljs-comment">// 匹配到时，子组件触发对应的事件</span><br>      <span class="hljs-comment">// 匹配到一个就over了，该子元素的子元素就忽略了</span><br>      child.<span class="hljs-property">$emit</span>.<span class="hljs-title function_">apply</span>(child, [eventName].<span class="hljs-title function_">concat</span>(params));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 继续查找该子组件的子元素</span><br>      broadcast.<span class="hljs-title function_">apply</span>(child, [componentName, eventName].<span class="hljs-title function_">concat</span>([params]));<br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">componentName, eventName, params</span>) &#123;<br>      <span class="hljs-keyword">var</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>;<br>      <span class="hljs-keyword">var</span> name = parent.<span class="hljs-property">$options</span>.<span class="hljs-property">componentName</span>;<br>      <span class="hljs-comment">// 遍历父组件，查找并匹配name，直到找到对应的父组件或无</span><br>      <span class="hljs-keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;<br>        parent = parent.<span class="hljs-property">$parent</span>;<br><br>        <span class="hljs-keyword">if</span> (parent) &#123;<br>          <span class="hljs-comment">// 匹配到，则修改name，用于判断并推出循环</span><br>          name = parent.<span class="hljs-property">$options</span>.<span class="hljs-property">componentName</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (parent) &#123;<br>        <span class="hljs-comment">// 有对应的父组件，则去触发对应的事件</span><br>        parent.<span class="hljs-property">$emit</span>.<span class="hljs-title function_">apply</span>(parent, [eventName].<span class="hljs-title function_">concat</span>(params));<br>      &#125;<br>    &#125;,<br>    <span class="hljs-title function_">broadcast</span>(<span class="hljs-params">componentName, eventName, params</span>) &#123;<br>      <span class="hljs-comment">// 调用broadcast函数，需要纠正this，因为broadcast函数的this并不指向调用者</span><br>      broadcast.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, componentName, eventName, params);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>带注释的源码：<a href="https://github.com/2fps/demo/blob/master/view/2019/00/element-ui%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/emitter.js">emitter.js</a>。</p><p>element-ui 中的事件传播就是这样的了，让我想到了 angular 中的 $broadcast 和 $emit 事件。</p><p> 原文地址 <a href="https://www.jb51.cc/webfrontend/454354.html">www.jb51.cc</a></p>]]></content>
    
    
    <categories>
      
      <category>element</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>for循环全家桶</title>
    <link href="/2020/06/15/for%E5%BE%AA%E7%8E%AF%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2020/06/15/for%E5%BE%AA%E7%8E%AF%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<p>抵达战场的 5 方势力分别是<code>for</code> , <code>foreach</code> , <code>map</code> , <code>for...in</code> , <code>for...of</code></p><h2 id="自我介绍环节"><a href="#自我介绍环节" class="headerlink" title="自我介绍环节"></a>自我介绍环节</h2><span id="more"></span><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>我是遍历界最早出现的一方诸侯，在座的各位需称我一声爷爷。我能满足开发人员的绝大多数的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)          <span class="hljs-comment">// 索引，数组下标</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])     <span class="hljs-comment">// 数组下标所对应的元素</span><br>&#125;<br><br><span class="hljs-comment">// 遍历对象</span><br><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, keys=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(profile); i &lt; keys.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys[i])            <span class="hljs-comment">// 对象的键值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(profile[keys[i]])   <span class="hljs-comment">// 对象的键对应的值</span><br>&#125;<br><br><span class="hljs-comment">// 遍历字符串</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; str.<span class="hljs-property">length</span> ;i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)          <span class="hljs-comment">// 索引 字符串的下标</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[i])     <span class="hljs-comment">// 字符串下标所对应的元素</span><br>&#125;<br><br><span class="hljs-comment">// 遍历DOM 节点</span><br><span class="hljs-keyword">let</span> articleParagraphs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.article &gt; p&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;articleParagraphs.<span class="hljs-property">length</span>;i++)&#123;<br>    articleParagraphs[i].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;paragraph&quot;</span>);<br>    <span class="hljs-comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>我是 ES5 版本发布的。按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。我是 for 循环的加强版。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i))<br><br><span class="hljs-comment">// logs 1</span><br><span class="hljs-comment">// logs 2</span><br><span class="hljs-comment">// logs 3</span><br><span class="hljs-comment">// 直接输出了数组的元素</span><br><br><span class="hljs-comment">//遍历对象</span><br><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<br><span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(profile);<br>keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)              <span class="hljs-comment">// 对象的键值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(profile[i])     <span class="hljs-comment">// 对象的键对应的值</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>我也是 ES5 版本发布的，我可以创建一个新数组，新数组的结果是原数组中的每个元素都调用一次提供的函数后的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> res = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i * i);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// logs [1, 4, 9, 16, 25]</span><br></code></pre></td></tr></table></figure><h3 id="for…in-枚举"><a href="#for…in-枚举" class="headerlink" title="for…in 枚举"></a>for…in 枚举</h3><p>我是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 遍历对象</span><br><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> profile)&#123;<br>    <span class="hljs-keyword">let</span> item = profile[i];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)   <span class="hljs-comment">// 对象的键值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)      <span class="hljs-comment">// 对象的键对应的值</span><br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr)&#123;<br>    <span class="hljs-keyword">let</span> item = arr[i];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)   <span class="hljs-comment">// 数组下标所对应的元素</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)      <span class="hljs-comment">// 索引，数组下标</span><br><br><span class="hljs-comment">// 遍历字符串</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> str)&#123;<br>    <span class="hljs-keyword">let</span> item = str[i];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)   <span class="hljs-comment">// 字符串下标所对应的元素</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)      <span class="hljs-comment">// 索引 字符串的下标</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="for…of-迭代"><a href="#for…of-迭代" class="headerlink" title="for…of 迭代"></a>for…of 迭代</h3><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 迭代数组数组</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)     <br>&#125;<br><span class="hljs-comment">// logs &#x27;a&#x27;</span><br><span class="hljs-comment">// logs &#x27;b&#x27;</span><br><span class="hljs-comment">// logs &#x27;c&#x27;</span><br><br><span class="hljs-comment">// 迭代字符串</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> str) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// logs &#x27;a&#x27;</span><br><span class="hljs-comment">// logs &#x27;b&#x27;</span><br><span class="hljs-comment">// logs &#x27;c&#x27;</span><br><br><span class="hljs-comment">// 迭代map</span><br><span class="hljs-keyword">let</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>]]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> iterable) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry);<br>&#125;<br><span class="hljs-comment">// logs [&quot;a&quot;, 1]</span><br><span class="hljs-comment">// logs [&quot;b&quot;, 2]</span><br><span class="hljs-comment">// logs [&quot;c&quot;, 3]</span><br><br><span class="hljs-comment">//  迭代map获取键值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> iterable) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><br><br><span class="hljs-comment">// 迭代set</span><br><span class="hljs-keyword">let</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> iterable) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// logs 1</span><br><span class="hljs-comment">// logs 2</span><br><span class="hljs-comment">// logs 3</span><br><span class="hljs-comment">// logs 4</span><br><br><span class="hljs-comment">// 迭代 DOM 节点</span><br><span class="hljs-keyword">let</span> articleParagraphs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.article &gt; p&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs) &#123;<br>    paragraph.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;paragraph&quot;</span>);<br>    <span class="hljs-comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span><br>&#125;<br><br><span class="hljs-comment">// 迭代arguments类数组对象</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> argument <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(argument);<br>  &#125;<br>&#125;)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// logs：</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><br><br><span class="hljs-comment">// 迭代类型数组</span><br><span class="hljs-keyword">let</span> typeArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">0x00</span>, <span class="hljs-number">0xff</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> typeArr) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// logs：</span><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 255</span><br></code></pre></td></tr></table></figure><p>经过第一轮的自我介绍和技能展示后，我们了解到:</p><ul><li><code>for语句</code>是最原始的循环语句。定义一个变量<code>i</code>(数字类型，表示数组的下标), 按照一定的条件，对<code>i</code>进行循环累加。条件通常为循环对象的长度，当超过长度就停止循环。因为对象无法判断长度，所以搭配<code>Object.keys()</code>使用。</li><li><code>forEach</code> ES5 提出。自称是<code>for语句</code>的加强版，可以发现它比<code>for语句</code>在写法上简单了很多。但是本质上也是数组的循环。<code>forEach</code>每个数组元素执行一次 callback 函数。也就是调用它的数组，因此，不会改变原数组。返回值是<code>undefine</code>。</li><li><code>map</code> ES5 提出。给原数组中的每个元素都按顺序调用一次 callback 函数。生成一个新数组，不修改调用它的原数组本身。返回值是新的数组。</li><li><code>for...in</code> ES5 提出。遍历对象上的可枚举属性，包括原型对象上的属性，且按任意顺序进行遍历，也就是顺序不固定。遍历数组时把数组的下标当作键值，此时的 i 是个字符串型的。它是为遍历对象属性而构建的，不建议与数组一起使用。</li><li><code>for...of</code> ES6 提出。只遍历可迭代对象的数据。</li></ul><h2 id="能力甄别"><a href="#能力甄别" class="headerlink" title="能力甄别"></a>能力甄别</h2><p>作为一个程序员，仅仅认识他们是远远不够的，在实际开发中鉴别他们各自的优缺点。因地制宜的使用他们，扬长避短。从而提高程序的整体性能才是能力之所在。</p><h3 id="关于跳出循环体"><a href="#关于跳出循环体" class="headerlink" title="关于跳出循环体"></a>关于跳出循环体</h3><p>在循环中满足一定条件就跳出循环体，或者跳过不符合条件的数据继续循环其它数据。是经常会遇到的需求。常用的语句是<code>break</code> 与 <code>continue</code>。</p><p>简单的说一下二者的区别，就当复习好了。</p><ul><li><code>break</code>语句是跳出当前循环，并执行当前循环之后的语句；</li><li><code>continue</code>语句是终止当前循环，并继续执行下一次循环;</li></ul><p><strong>注意</strong>：<code>forEach</code> 与<code>map</code> 是不支持跳出循环体的，其它三种方法均支持。</p><p><strong>原理</strong> ：查看<code>forEach</code>实现原理，就会理解这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>（callbackfn [，thisArg]&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>传入的 function 是这里的回调函数。在回调函数里面使用 break 肯定是非法的，因为 break 只能用于跳出循环，回调函数不是循环体。</p><p>在回调函数中使用 return，只是将结果返回到上级函数，也就是这个 for 循环中，并没有结束 for 循环，所以 return 也是无效的。</p><p><code>map()</code> 同理。</p><h3 id="map-链式调用"><a href="#map-链式调用" class="headerlink" title="map()链式调用"></a><code>map()</code>链式调用</h3><p><code>map()</code> 方法是可以链式调用的，这意味着它可以方便的结合其它方法一起使用。例如：<code>reduce()</code>, <code>sort()</code>, <code>filter()</code> 等。但是其它方法并不能做到这一点。<code>forEach()</code>的返回值是<code>undefined</code>，所以无法链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将元素乘以本身，再进行求和。</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> res1 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * item).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, value</span>) =&gt;</span> total + value);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res1) <span class="hljs-comment">// logs 55 undefined&quot;</span><br></code></pre></td></tr></table></figure><h3 id="for-in会遍历出原型对象上的属性"><a href="#for-in会遍历出原型对象上的属性" class="headerlink" title="for...in会遍历出原型对象上的属性"></a><code>for...in</code>会遍历出原型对象上的属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">objCustom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">arrCustom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>arr.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;hello</span><br><span class="hljs-string">for (var i in arr) &#123;</span><br><span class="hljs-string">    console.log(i);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// logs</span><br><span class="hljs-string">// 0</span><br><span class="hljs-string">// 1</span><br><span class="hljs-string">// 2</span><br><span class="hljs-string">// foo</span><br><span class="hljs-string">// arrCustom</span><br><span class="hljs-string">// objCustom</span><br></code></pre></td></tr></table></figure><p>然而在实际的开发中，我们并不需要原型对象上的属性。这种情况下我们可以使用<code>hasOwnProperty()</code> 方法，它会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">objCustom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">arrCustom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>arr.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;hello</span><br><span class="hljs-string">for (var i in arr) &#123;</span><br><span class="hljs-string">    if (arr.hasOwnProperty(i)) &#123;</span><br><span class="hljs-string">        console.log(i);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// logs</span><br><span class="hljs-string">// 0</span><br><span class="hljs-string">// 1</span><br><span class="hljs-string">// 2</span><br><span class="hljs-string">// foo</span><br><span class="hljs-string"></span><br><span class="hljs-string">// 可见数组本身的属性还是无法摆脱。此时建议使用 forEach</span><br></code></pre></td></tr></table></figure><p>对于纯对象的遍历，选择<code>for..in</code>枚举更方便；对于数组遍历，如果不需要知道索引<code>for..of</code>迭代更合适，因为还可以中断；如果需要知道索引，则<code>forEach()</code>更合适；对于其他字符串，类数组，类型数组的迭代，<code>for..of</code>更占上风更胜一筹。但是注意低版本浏览器的是配性。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>有兴趣的读者可以找一组数据自行测试，文章就直接给出结果了，并做相应的解释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> &gt; <span class="hljs-keyword">for</span>-<span class="hljs-keyword">of</span> &gt; forEach  &gt; map &gt; <span class="hljs-keyword">for</span>-<span class="hljs-keyword">in</span><br></code></pre></td></tr></table></figure><ul><li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li><li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li><li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是<code>array.forEach(function(currentValue, index, arr), thisValue)</code>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li><li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li><li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且<code>for...in</code>的 key 是<code>String</code>类型，有转换过程，开销比较大。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发中我们要结合语义话、可读性和程序性能，去选择究竟使用哪种方案。</p><p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。</p><p>如果你需要进行简单的遍历，用 forEach 或者 for of。</p><p>如果你需要对迭代器进行遍历，用 for of。</p><p>如果你需要过滤出符合条件的项，用 filterr。</p><p>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter。</p><p>总之，因地制宜，因时而变。千万不要因为过分追求性能，而忽略了语义和可读性。在实际开发中，让他们扬长避短，优势互补，让程序趋近最优才是我们要做的。</p><p>原文地址 <a href="https://juejin.im/post/5ee6e7c4f265da76e46e6bb7">https://juejin.im/post/5ee6e7c4f265da76e46e6bb7</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度</title>
    <link href="/2020/06/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/06/10/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>我们假设计算机运行一行基础代码需要执行一次运算。<br> <span id="more"></span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-title function_">aFunc</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);      <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <br>&#125;<br></code></pre></td></tr></table></figure><p>那么上面这个方法需要执行 2 次运算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">int <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;         <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);      <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法需要 (n + 1 + n + 1) &#x3D; 2n + 2 次运算。</p><p>我们把 算法需要执行的运算次数 用 输入大小 n 的函数 表示，即 T(n) 。<br>此时为了 估算算法需要的运行时间 和 简化算法分析，我们引入时间复杂度的概念。</p><p>定义：存在常数 c 和函数 f(N)，使得当 N &gt;&#x3D; c 时 T(N) &lt;&#x3D; f(N)，表示为 T(n) &#x3D; O(f(n)) 。  </p><p>当 N &gt;&#x3D; 2 的时候，f(n) &#x3D; n^2 总是大于 T(n) &#x3D; n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) &#x3D; O(f(n))。</p><p>因为 f(n) 的增长速度是大于或者等于 T(n) 的，即 T(n) &#x3D; O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。</p><p><strong>算法的时间复杂度，用来度量算法的运行时间，记作: T(n) &#x3D; O(f(n))。它表示随着 输入大小 n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。</strong></p><p>显然如果 T(n) &#x3D; n^2，那么 T(n) &#x3D; O(n^2)，T(n) &#x3D; O(n^3)，T(n) &#x3D; O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。</p><p>那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？</p><ol><li>我们知道常数项对函数的增长速度影响并不大，所以当 T(n) &#x3D; c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">比如<br>第一个 Hello, World 的例子中 <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-number">2</span>，所以我们说那个函数(算法)的时间复杂度为 O(<span class="hljs-number">1</span>)。<br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span> + <span class="hljs-number">29</span>，此时时间复杂度为 O(<span class="hljs-built_in">n</span>)。<br></code></pre></td></tr></table></figure><ol start="2"><li>我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">比如<br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span>^<span class="hljs-number">3</span> + <span class="hljs-built_in">n</span>^<span class="hljs-number">2</span> + <span class="hljs-number">29</span>，此时时间复杂度为 O(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)。<br></code></pre></td></tr></table></figure><ol start="3"><li>因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">比如<br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>) = <span class="hljs-number">3</span><span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>，此时时间复杂度为 O(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)。<br></code></pre></td></tr></table></figure><p><strong>综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大 O 推导法。</strong></p><p>由此可见，由执行次数 T(n) 得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。</p><ol><li>对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个<br>循环的时间复杂度为 O(n×m)。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;         <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 O(n × 1)，即 O(n)。</p><ol start="2"><li>对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是 a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;         <br>        <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;       <br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);      <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 O(n × n × 1)，即 O(n^2)。</p><ol start="3"><li>对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-comment">// 第一部分时间复杂度为 O(n^2)</span><br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 第二部分时间复杂度为 O(n)</span><br>    <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p><ol start="4"><li>对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 第一条路径时间复杂度为 O(n^2)</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;输入数据大于等于零\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 第二条路径时间复杂度为 O(n)</span><br>        <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;输入数据小于零\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p><p><strong>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。</strong></p><p>最后，我们来练习一下</p><p>一. 基础题<br>求该方法的时间复杂度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (int j = i; j &lt; n; j++) &#123;<br>            <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考答案：<br>当 i &#x3D; 0 时，内循环执行 n 次运算，当 i &#x3D; 1 时，内循环执行 n - 1 次运算…… 当 i &#x3D; n - 1 时，内循环执行 1 次运算。<br>所以，执行次数 T(n) &#x3D; n + (n - 1) + (n - 2)……+ 1 &#x3D; n(n + 1) &#x2F; 2 &#x3D; n^2 &#x2F; 2 + n &#x2F; 2。<br>根据上文说的 大 O 推导法 可以知道，此时时间复杂度为 O(n^2)。</p><p>二. 进阶题<br>求该方法的时间复杂度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        i *= <span class="hljs-number">2</span>;<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考答案：<br>假设循环次数为 t，则循环条件满足 2^t &lt; n。<br>可以得出，执行次数 t &#x3D; log(2)(n)，即 T(n) &#x3D; log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。</p><p>三. 再次进阶<br>求该方法的时间复杂度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">long <span class="hljs-title function_">aFunc</span>(<span class="hljs-params">int n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">aFunc</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">aFunc</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考答案：<br>显然运行次数，T(0) &#x3D; T(1) &#x3D; 1，同时 T(n) &#x3D; T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。<br>显然 T(n) &#x3D; T(n - 1) + T(n - 2) 是一个<a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a>，通过归纳证明法可以证明，当 n &gt;&#x3D; 1 时 T(n) &lt; (5&#x2F;3)^n，同时当 n &gt; 4 时 T(n) &gt;&#x3D; (3&#x2F;2)^n。<br>所以该方法的时间复杂度可以表示为 O((5&#x2F;3)^n)，简化后为 O(2^n)。<br>可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕代码</title>
    <link href="/2020/05/30/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    <url>/2020/05/30/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><span id="more"></span><h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">New</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">Fn</span>) &#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 创建空对象</span><br>  <span class="hljs-keyword">var</span> arg = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 将obj的原型链__proto__指向构造函数的原型prototype</span><br>  obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Fn</span>; <span class="hljs-comment">// 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn</span><br>  <span class="hljs-title class_">Fn</span>.<span class="hljs-title function_">apply</span>(obj, arg); <span class="hljs-comment">// 执行Fn，并将构造函数Fn执行obj</span><br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回结果</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getType</span> = data =&gt; &#123;<br>  <span class="hljs-comment">// 获取数据类型</span><br>  <span class="hljs-keyword">const</span> baseType = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span><br>    .<span class="hljs-title function_">call</span>(data)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\[object\s(.+)\]$/g</span>, <span class="hljs-string">&quot;$1&quot;</span>)<br>    .<span class="hljs-title function_">toLowerCase</span>();<br>  <span class="hljs-keyword">const</span> type = data <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Element</span> ? <span class="hljs-string">&quot;element&quot;</span> : baseType;<br>  <span class="hljs-keyword">return</span> type;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isPrimitive</span> = data =&gt; &#123;<br>  <span class="hljs-comment">// 判断是否是基本数据类型</span><br>  <span class="hljs-keyword">const</span> primitiveType = <span class="hljs-string">&quot;undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset&quot;</span>.<span class="hljs-title function_">split</span>(<br>    <span class="hljs-string">&quot;,&quot;</span><br>  ); <span class="hljs-comment">// 其实还有很多类型</span><br>  <span class="hljs-keyword">return</span> primitiveType.<span class="hljs-title function_">includes</span>(<span class="hljs-title function_">getType</span>(data));<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = data =&gt; <span class="hljs-title function_">getType</span>(data) === <span class="hljs-string">&quot;object&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isArray</span> = data =&gt; <span class="hljs-title function_">getType</span>(data) === <span class="hljs-string">&quot;array&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">deepClone</span> = data =&gt; &#123;<br>  <span class="hljs-keyword">let</span> cache = &#123;&#125;; <span class="hljs-comment">// 缓存值，防止循环引用</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">baseClone</span> = _data =&gt; &#123;<br>    <span class="hljs-keyword">let</span> res;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPrimitive</span>(_data)) &#123;<br>      <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(_data)) &#123;<br>      res = &#123; ..._data &#125;;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray</span>(_data)) &#123;<br>      res = [..._data];<br>    &#125;<br>    <span class="hljs-comment">// 判断是否有复杂类型的数据，有就递归</span><br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(res).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (res[key] &amp;&amp; <span class="hljs-title function_">getType</span>(res[key]) === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        <span class="hljs-comment">// 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题</span><br>        <span class="hljs-keyword">if</span> (cache[res[key]]) &#123;<br>          res[key] = cache[res[key]];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          cache[res[key]] = res[key];<br>          res[key] = <span class="hljs-title function_">baseClone</span>(res[key]);<br>        &#125;<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">baseClone</span>(data);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">var</span> args1 = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">var</span> bindFn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> args2 = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-keyword">var</span> that2 = <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> bindFn ? <span class="hljs-variable language_">this</span> : context; <span class="hljs-comment">// 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。</span><br>    <span class="hljs-keyword">return</span> that.<span class="hljs-title function_">apply</span>(that2, args1.<span class="hljs-title function_">concat</span>(args2));<br>  &#125;;<br>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Fn</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// 连接原型链用Fn</span><br>  <span class="hljs-comment">// 原型赋值</span><br>  <span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// bindFn的prototype指向和this的prototype一样，指向同一个原型对象</span><br>  bindFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br>  <span class="hljs-keyword">return</span> bindFn;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="手写函数柯里化"><a href="#手写函数柯里化" class="headerlink" title="手写函数柯里化"></a>手写函数柯里化</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> curry = fn =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> Error(<span class="hljs-string">&quot;No function provided&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curriedFn</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> curriedFn.apply(<span class="hljs-literal">null</span>, args.concat([].slice.call(arguments)));<br>      &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 来源于 https://github.com/bailnl/promise/blob/master/src/promise.js</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isFunction</span> = fn =&gt; <span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&quot;function&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = obj =&gt; obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">noop</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">nextTick</span> = fn =&gt; <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">promise, x</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (promise === x) &#123;<br>    <span class="hljs-title function_">reject</span>(promise, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;You cannot resolve a promise with itself&quot;</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &amp;&amp; x.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Promise</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x.<span class="hljs-property">_stauts</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = statusHandler =&gt; <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-title function_">statusHandler</span>(promise, value);<br>      x.<span class="hljs-title function_">then</span>(<span class="hljs-title function_">handler</span>(resolve), <span class="hljs-title function_">handler</span>(reject));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.<span class="hljs-property">_stauts</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>      <span class="hljs-title function_">fulfill</span>(promise, x.<span class="hljs-property">_value</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.<span class="hljs-property">_stauts</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>      <span class="hljs-title function_">reject</span>(promise, x.<span class="hljs-property">_value</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFunction</span>(x) || <span class="hljs-title function_">isObject</span>(x)) &#123;<br>    <span class="hljs-keyword">let</span> isCalled = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFunction</span>(then)) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = statusHandler =&gt; <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (!isCalled) &#123;<br>            <span class="hljs-title function_">statusHandler</span>(promise, value);<br>          &#125;<br>          isCalled = <span class="hljs-literal">true</span>;<br>        &#125;;<br>        then.<span class="hljs-title function_">call</span>(x, <span class="hljs-title function_">handler</span>(resolve), <span class="hljs-title function_">handler</span>(reject));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">fulfill</span>(promise, x);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (!isCalled) &#123;<br>        <span class="hljs-title function_">reject</span>(promise, e);<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">fulfill</span>(promise, x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">promise, reason</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (promise.<span class="hljs-property">_stauts</span> !== <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  promise.<span class="hljs-property">_stauts</span> = <span class="hljs-variable constant_">REJECTED</span>;<br>  promise.<span class="hljs-property">_value</span> = reason;<br>  <span class="hljs-title function_">invokeCallback</span>(promise);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fulfill</span> = (<span class="hljs-params">promise, value</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (promise.<span class="hljs-property">_stauts</span> !== <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  promise.<span class="hljs-property">_stauts</span> = <span class="hljs-variable constant_">FULFILLED</span>;<br>  promise.<span class="hljs-property">_value</span> = value;<br>  <span class="hljs-title function_">invokeCallback</span>(promise);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">invokeCallback</span> = promise =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (promise.<span class="hljs-property">_stauts</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span> (promise.<span class="hljs-property">_callbacks</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123;<br>        onFulfilled = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value,<br>        onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> reason;<br>        &#125;,<br>        thenPromise<br>      &#125; = promise.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">shift</span>();<br>      <span class="hljs-keyword">let</span> value;<br>      <span class="hljs-keyword">try</span> &#123;<br>        value = (promise.<span class="hljs-property">_stauts</span> === <span class="hljs-variable constant_">FULFILLED</span> ? onFulfilled : onRejected)(<br>          promise.<span class="hljs-property">_value</span><br>        );<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-title function_">reject</span>(thenPromise, e);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-title function_">resolve</span>(thenPromise, value);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(value));<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(reason));<br>  &#125;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">resolver</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<br>        <span class="hljs-string">`Class constructor Promise cannot be invoked without &#x27;new&#x27;`</span><br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isFunction</span>(resolver)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">`Promise resolver <span class="hljs-subst">$&#123;resolver&#125;</span> is not a function`</span>);<br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_stauts</span> = <span class="hljs-variable constant_">PENDING</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = [];<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">resolver</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>, value), <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">this</span>, reason));<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">this</span>, e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">const</span> thenPromise = <span class="hljs-keyword">new</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params">noop</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_callbacks</span>.<span class="hljs-title function_">concat</span>([<br>      &#123;<br>        <span class="hljs-attr">onFulfilled</span>: <span class="hljs-title function_">isFunction</span>(onFulfilled) ? onFulfilled : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">onRejected</span>: <span class="hljs-title function_">isFunction</span>(onRejected) ? onRejected : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>,<br>        thenPromise<br>      &#125;<br>    ]);<br>    <span class="hljs-title function_">invokeCallback</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> thenPromise;<br>  &#125;<br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, onRejected);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn = &#123;&#125;, wait = <span class="hljs-number">50</span>, immediate</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;, wait);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="手写节流函数"><a href="#手写节流函数" class="headerlink" title="手写节流函数"></a>手写节流函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">throttle</span> = (<span class="hljs-params">fn = &#123;&#125;, wait = <span class="hljs-number">0</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">arguments</span>;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>      prev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    &#125;<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="手写-instanceOf"><a href="#手写-instanceOf" class="headerlink" title="手写 instanceOf"></a>手写 instanceOf</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">instanceOf</span> = (<span class="hljs-params">left, right</span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> proto = left.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    proto = proto.<span class="hljs-property">__proto__</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实现call</title>
    <link href="/2020/05/21/%E5%AE%9E%E7%8E%B0call/"/>
    <url>/2020/05/21/%E5%AE%9E%E7%8E%B0call/</url>
    
    <content type="html"><![CDATA[<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><blockquote><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。<br>举个栗子：<br> <span id="more"></span></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo =&#123;<br>  <span class="hljs-attr">value</span>:<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;<br>bar.<span class="hljs-title function_">call</span>(foo);<br></code></pre></td></tr></table></figure><p><strong>需要注意两点：</strong></p><ul><li>call 改变了 this 的指向，指向到 foo；</li><li>调用了 bar 函数</li></ul><h3 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h3><p>试想当调用 call 的时候，把 foo 对象改造成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br>&#125;;<br>foo.<span class="hljs-title function_">bar</span>();<br></code></pre></td></tr></table></figure><p>这样我们就实现了 this 指向 foo；<br>但是我们给 foo 添加了一个属性才实现了这个效果，那我们用完可以删除掉这个属性。<br>模拟步骤可分为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">foo.<span class="hljs-property">fn</span> = bar<br><br>foo.<span class="hljs-title function_">fn</span>()<br><br><span class="hljs-keyword">delete</span> foo.<span class="hljs-property">fn</span><br></code></pre></td></tr></table></figure><p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property">Prototype</span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  context.<span class="hljs-title function_">fn</span>();<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call2</span>(foo);<br></code></pre></td></tr></table></figure><p>这样我们就轻松模拟了 call 指定 this 指向的功能；</p><h3 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h3><p>call 函数还能给定参数执行函数。<br>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call</span>(foo, <span class="hljs-string">&#x27;Cherry&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>注意：传入的参数并不确定，这可咋办？</p><p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p><p>比如这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>    args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args +<span class="hljs-string">&#x27;)&#x27;</span>)<br></code></pre></td></tr></table></figure><p>所以我们的第二版克服了两个大问题，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args +<span class="hljs-string">&#x27;)&#x27;</span>);<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>&#125;<br><br>bar.<span class="hljs-title function_">call2</span>(foo, <span class="hljs-string">&#x27;Cherry&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h3 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h3><p>模拟代码已经完成 80%，还有两个小点要注意：</p><p><strong>1.this 参数可以传 null，当为 null 的时候，视为指向 window</strong><br><strong>2. 函数是可以有返回值的！</strong><br>解决方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) &#123;<br>    <span class="hljs-keyword">var</span> context = context || <span class="hljs-variable language_">window</span>;<br>    context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">var</span> args = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        args.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args +<span class="hljs-string">&#x27;)&#x27;</span>);<br><br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>,<br>        <span class="hljs-attr">name</span>: name,<br>        <span class="hljs-attr">age</span>: age<br>    &#125;<br>&#125;<br><br>bar.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-title function_">call2</span>(obj, <span class="hljs-string">&#x27;Cherry&#x27;</span>, <span class="hljs-number">18</span>));<br></code></pre></td></tr></table></figure><p>到此，我们完成了 call 的模拟实现。</p><p>文章非原创，有侵权请告知，文章出处：<br><a href="https://link.jianshu.com/?t=https://github.com/mqyqingfeng/Blog/issues/11">https://github.com/mqyqingfeng/Blog/issues/11</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>call、apply、bind</title>
    <link href="/2020/05/20/call%E3%80%81apply%E3%80%81bind/"/>
    <url>/2020/05/20/call%E3%80%81apply%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h2 id="bind-是返回对应函数，便于稍后调用；apply-、call-则是立即调用-。-apply、call"><a href="#bind-是返回对应函数，便于稍后调用；apply-、call-则是立即调用-。-apply、call" class="headerlink" title="bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 apply、call"></a>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。<br> <span id="more"></span><br>apply、call</h2><p>在 javascript 中，<code>call</code> 和 <code>apply</code> 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 <code>this</code> 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fruits</span>(<span class="hljs-params"></span>) &#123;&#125;<br> <br>fruits.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>,<br>    <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My color is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">var</span> apple = <span class="hljs-keyword">new</span> fruits;<br>apple.<span class="hljs-title function_">say</span>();<br></code></pre></td></tr></table></figure><p>但是如果我们有一个对象<code>banana= &#123;color : &quot;yellow&quot;&#125;</code> , 我们不想对它重新定义 <code>say</code> 方法，那么我们可以通过 <code>call</code> 或 <code>apply</code> 用 <code>apple</code> 的 <code>say</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">banana = &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;yellow&quot;</span><br>&#125;<br>apple.<span class="hljs-property">say</span>.<span class="hljs-title function_">call</span>(banana);     <br>apple.<span class="hljs-property">say</span>.<span class="hljs-title function_">apply</span>(banana);<br></code></pre></td></tr></table></figure><p>所以，可以看出 <code>call</code> 和 <code>apply</code> 是为了动态改变 <code>this</code> 而出现的，当一个 <code>object</code> 没有某个方法（本栗子中<code>banana</code>没有<code>say</code>方法），但是其他的有（本栗子中<code>apple</code>有<code>say</code>方法），我们可以借助<code>call</code>或<code>apply</code>用其它对象的方法来操作。</p><h2 id="apply、call-区别"><a href="#apply、call-区别" class="headerlink" title="apply、call 区别"></a>apply、call 区别</h2><p>对于 <code>apply</code>、<code>call</code> 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2</span>) &#123;<br>     <br>&#125;;<br></code></pre></td></tr></table></figure><p>就可以通过如下方式来调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">func.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, arg1, arg2);<br>func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [arg1, arg2])<br></code></pre></td></tr></table></figure><p>其中 <code>this</code> 是你想指定的上下文，他可以是任何一个 JavaScript 对象 (JavaScript 中一切皆对象)，<code>call</code> 需要把参数按顺序传递进去，而 <code>apply</code> 则是把参数放在数组里。　　<br>为了巩固加深记忆，下面列举一些常用用法：</p><h2 id="apply、call-实例"><a href="#apply、call-实例" class="headerlink" title="apply、call 实例"></a>apply、call 实例</h2><p><strong>数组之间追加</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array1 = [<span class="hljs-number">12</span> , <span class="hljs-string">&quot;foo&quot;</span> , &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Joe&quot;</span>&#125; , -<span class="hljs-number">2458</span>]; <br><span class="hljs-keyword">var</span> array2 = [<span class="hljs-string">&quot;Doe&quot;</span> , <span class="hljs-number">555</span> , <span class="hljs-number">100</span>]; <br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span>.<span class="hljs-title function_">apply</span>(array1, array2); <br><span class="hljs-comment">// array1 值为  [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100]</span><br></code></pre></td></tr></table></figure><p><strong>获取数组中的最大值和最小值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span>  numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">458</span> , <span class="hljs-number">120</span> , -<span class="hljs-number">215</span> ]; <br><span class="hljs-keyword">var</span> maxInNumbers = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Math</span>, numbers),   <br>    maxInNumbers = <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Math</span>,<span class="hljs-number">5</span>, <span class="hljs-number">458</span> , <span class="hljs-number">120</span> , -<span class="hljs-number">215</span>);<br></code></pre></td></tr></table></figure><p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p><p><strong>验证是否是数组（前提是<code>toString()</code>方法没有被重写过）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">functionisArray</span>(obj)&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Array]&#x27;</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类（伪）数组使用数组方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> domNodes = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;*&quot;</span>));<br></code></pre></td></tr></table></figure><p>Javascript 中存在一种名为伪数组的对象结构。比较特别的是 <code>arguments</code> 对象，还有像调用 <code>getElementsByTagName</code> , <code>document.childNodes</code> 之类的，它们返回<code>NodeList</code>对象都属于伪数组。不能应用 Array 下的 <code>push</code> , <code>pop</code> 等方法。<br>但是我们能通过 <code>Array.prototype.slice.call</code> 转换为真正的数组的带有 <code>length</code> 属性的对象，这样 <code>domNodes</code> 就可以应用 Array 下的所有方法了。</p><p><strong>面试题</strong><br>定义一个 <code>log</code> 方法，让它可以代理 <code>console.log</code> 方法，常见的解决方法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">msg</span>)　&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;<br><span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <br><span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 <code>apply</code> 或者 <code>call</code>，注意这里传入多少个参数是不确定的，所以使用<code>apply</code>是最好的，方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">console</span>, <span class="hljs-variable language_">arguments</span>);<br>&#125;;<br><span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <br><span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>接下来的要求是给每一个 <code>log</code> 消息添加一个 “(app)” 的前辍，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br></code></pre></td></tr></table></figure><p>该怎么做比较优雅呢? 这个时候需要想到<code>arguments</code>参数是个伪数组，通过 <code>Array.prototype.slice.call</code> 转化为标准数组，再使用数组方法<code>unshift</code>，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  args.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;(app)&#x27;</span>);<br> <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">console</span>, args);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>在讨论<code>bind()</code>方法之前我们先来看一道题目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> altwrite = <span class="hljs-variable language_">document</span>.<span class="hljs-property">write</span>;<br><span class="hljs-title function_">altwrite</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果：<code>Uncaught TypeError: Illegal invocation</code><br><code>altwrite()</code>函数改变<code>this</code>的指向<code>global</code>或<code>window</code>对象，导致执行时提示非法调用异常，正确的方案就是使用<code>bind()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">altwrite.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">document</span>)(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>当然也可以使用<code>call()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">altwrite.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>绑定函数</strong></p><p><code>bind()</code>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望<code>this</code>指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用<code>bind()</code>方法能够很漂亮的解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-number">9</span>; <br><span class="hljs-keyword">var</span> mymodule = &#123;<br>  <span class="hljs-attr">num</span>: <span class="hljs-number">81</span>,<br>  <span class="hljs-attr">getNum</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>);<br>  &#125;<br>&#125;;<br><br>mymodule.<span class="hljs-title function_">getNum</span>(); <br><br><span class="hljs-keyword">var</span> getNum = mymodule.<span class="hljs-property">getNum</span>;<br><span class="hljs-title function_">getNum</span>(); <br><br><span class="hljs-keyword">var</span> boundGetNum = getNum.<span class="hljs-title function_">bind</span>(mymodule);<br><span class="hljs-title function_">boundGetNum</span>();<br></code></pre></td></tr></table></figure><p><code>bind()</code> 方法与 <code>apply</code> 和 <code>call</code> 很相似，也是可以改变函数体内 <code>this</code> 的指向。</p><p>MDN 的解释是：<code>bind()</code>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <code>bind()</code>方法的第一个参数作为 <code>this</code>，传入 <code>bind()</code> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 <code>_this</code> , <code>that</code> , <code>self</code> 等保存 <code>this</code> ，这样我们可以在改变了上下文之后继续引用到它。 像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    bar : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">eventBind</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;<br>        $(<span class="hljs-string">&#x27;.someClass&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_this.<span class="hljs-property">bar</span>);     <br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Javascript 特有的机制，上下文环境在 <code>eventBind:function()&#123; &#125;</code> 过渡到 <code>$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123; &#125;)</code> 发生了改变，上述使用变量保存 <code>this</code> 这些方式都是有用的，也没有什么问题。当然使用 <code>bind()</code> 可以更加优雅的解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    bar : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">eventBind</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        $(<span class="hljs-string">&#x27;.someClass&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>            <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>);      <br>        &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码里，<code>bind()</code> 创建了一个函数，当这个<code>click</code>事件绑定在被调用的时候，它的 <code>this</code> 关键词会被设置成被传入的值（这里指调用<code>bind()</code>时传入的参数）。因此，这里我们传入想要的上下文 <code>this</code>(其实就是 <code>foo</code> )，到 <code>bind()</code> 函数中。然后，当回调函数被执行的时候， <code>this</code> 便指向 <code>foo</code> 对象。再来一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>&#125;<br><span class="hljs-keyword">var</span> foo = &#123;<br><span class="hljs-attr">x</span>:<span class="hljs-number">3</span><br>&#125;<br><span class="hljs-title function_">bar</span>(); <br><span class="hljs-keyword">var</span> func = bar.<span class="hljs-title function_">bind</span>(foo);<br><span class="hljs-title function_">func</span>();<br></code></pre></td></tr></table></figure><p>这里我们创建了一个新的函数 <code>func</code>，当使用 <code>bind()</code> 创建一个绑定函数之后，它被执行的时候，它的 <code>this</code> 会被设置成 <code>foo</code> ， 而不是像我们调用 <code>bar()</code> 时的全局作用域。</p><p><strong>偏函数（Partial Functions）</strong></p><p><code>Partial Functions</code>也叫<code>Partial Applications</code>，这里截取一段关于偏函数的定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Partial</span> application can be described <span class="hljs-keyword">as</span> taking a <span class="hljs-keyword">function</span> that accepts some number <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>, binding values to one or more <span class="hljs-keyword">of</span> those <span class="hljs-variable language_">arguments</span>, and returning a <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span> that only accepts the remaining, un-bound <span class="hljs-variable language_">arguments</span>.<br></code></pre></td></tr></table></figure><p>这是一个很好的特性，使用<code>bind()</code>我们设定函数的预定义参数，然后调用的时候传入其他参数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">list</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> list1 = <span class="hljs-title function_">list</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <br><br><br><span class="hljs-keyword">var</span> leadingThirtysevenList = list.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">37</span>);<br><br><span class="hljs-keyword">var</span> list2 = <span class="hljs-title function_">leadingThirtysevenList</span>(); <br><span class="hljs-keyword">var</span> list3 = <span class="hljs-title function_">leadingThirtysevenList</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>和 setTimeout 一起使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bloomer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">petalCount</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">12</span>) + <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-title class_">Bloomer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bloom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">declare</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">100</span>);<br>&#125;;<br><br><span class="hljs-title class_">Bloomer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">declare</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我有 &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">petalCount</span> + <span class="hljs-string">&#x27; 朵花瓣!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> bloo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bloomer</span>();<br>bloo.<span class="hljs-title function_">bloom</span>();<br></code></pre></td></tr></table></figure><p>注意：对于事件处理函数和<code>setInterval</code>方法也可以使用上面的方法</p><p><strong>绑定函数作为构造函数</strong></p><p>绑定函数也适用于使用<code>new</code>操作符来构造目标函数的实例。当使用绑定函数来构造实例，注意：<code>this</code>会被忽略，但是传入的参数仍然可用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Point</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;<br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;,&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>p.<span class="hljs-title function_">toString</span>(); <br><br><br><span class="hljs-keyword">var</span> emptyObj = &#123;&#125;;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">YAxisPoint</span> = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">bind</span>(emptyObj, <span class="hljs-number">0</span>);<br><br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">YAxisPoint</span> = <span class="hljs-title class_">Point</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">var</span> axisPoint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">YAxisPoint</span>(<span class="hljs-number">5</span>);<br>axisPoint.<span class="hljs-title function_">toString</span>(); <br><br>axisPoint <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Point</span>; <br>axisPoint <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">YAxisPoint</span>; <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">17</span>, <span class="hljs-number">42</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">YAxisPoint</span>;<br></code></pre></td></tr></table></figure><p><strong>捷径</strong></p><p><code>bind()</code>也可以为需要特定<code>this</code>值的函数创造捷径。</p><p>例如要将一个类数组对象转换为真正的数组，可能的例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> slice = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>;<br><br><br><br>slice.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br></code></pre></td></tr></table></figure><p>如果使用<code>bind()</code>的话，情况变得更简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> unboundSlice = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>;<br><span class="hljs-keyword">var</span> slice = <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">call</span>.<span class="hljs-title function_">bind</span>(unboundSlice);<br><br><br><br><span class="hljs-title function_">slice</span>(<span class="hljs-variable language_">arguments</span>);<br></code></pre></td></tr></table></figure><p><strong>实现</strong></p><p>上面的几个小节可以看出<code>bind()</code>有很多的使用场景，但是<code>bind()</code>函数是在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。这就需要我们自己实现<code>bind()</code>函数了。</p><p>首先我们可以通过给目标函数指定作用域来简单实现<code>bind()</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  self = <span class="hljs-variable language_">this</span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context,<span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>考虑到函数柯里化的情况，我们可以构建一个更加健壮的<code>bind()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>),<br>  self = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">var</span> innerArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>      <span class="hljs-keyword">var</span> finalArgs = args.<span class="hljs-title function_">concat</span>(innerArgs);<br>      <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context,finalArgs);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这次的<code>bind()</code>方法可以绑定对象，也支持在绑定的时候传参。</p><p>继续，Javascript 的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>),<br>  F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>  self = <span class="hljs-variable language_">this</span>,<br>  bound = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">var</span> innerArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>      <span class="hljs-keyword">var</span> finalArgs = args.<span class="hljs-title function_">concat</span>(innerArgs);<br>      <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>((<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F ? <span class="hljs-variable language_">this</span> : context), finalArgs);<br>  &#125;;<br><br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = self.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>  <span class="hljs-keyword">return</span> bound;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是《JavaScript Web Application》一书中对<code>bind()</code>的实现：通过设置一个中转构造函数 F，使绑定后的函数与调用<code>bind()</code>的函数处于同一原型链上，用 new 操作符调用绑定后的函数，返回的对象也能正常使用<code>instanceof</code>，因此这是最严谨的<code>bind()</code>实现。</p><p>对于为了在浏览器中能支持<code>bind()</code>函数，只需要对上述函数稍微修改即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">oThis</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> aArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>), <br>        fToBind = <span class="hljs-variable language_">this</span>, <br>        fNOP = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>        fBound = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-keyword">return</span> fToBind.<span class="hljs-title function_">apply</span>(<br>              <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> fNOP &amp;&amp; oThis ? <span class="hljs-variable language_">this</span> : oThis || <span class="hljs-variable language_">window</span>,<br>              aArgs.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>))<br>          );<br>        &#125;;<br><br>    fNOP.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    fBound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNOP</span>();<br><br>    <span class="hljs-keyword">return</span> fBound;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>有个有趣的问题，如果连续 <code>bind()</code> 两次，亦或者是连续 <code>bind()</code> 三次那么输出的值是什么呢？像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);<br>&#125;<br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">x</span>:<span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> sed = &#123;<br>    <span class="hljs-attr">x</span>:<span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">var</span> func = bar.<span class="hljs-title function_">bind</span>(foo).<span class="hljs-title function_">bind</span>(sed);<br><span class="hljs-title function_">func</span>(); <span class="hljs-comment">//?</span><br> <br><span class="hljs-keyword">var</span> fiv = &#123;<br>    <span class="hljs-attr">x</span>:<span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">var</span> func = bar.<span class="hljs-title function_">bind</span>(foo).<span class="hljs-title function_">bind</span>(sed).<span class="hljs-title function_">bind</span>(fiv);<br><span class="hljs-title function_">func</span>(); <span class="hljs-comment">//?</span><br></code></pre></td></tr></table></figure><p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在 Javascript 中，多次 <code>bind()</code> 是无效的。更深层次的原因， <code>bind()</code> 的实现，相当于使用函数在内部包了一个 <code>call / apply</code> ，第二次 <code>bind()</code> 相当于再包住第一次 <code>bind()</code> , 故第二次以后的 <code>bind</code> 是无法生效的。</p><h2 id="apply、call、bind-比较"><a href="#apply、call、bind-比较" class="headerlink" title="apply、call、bind 比较"></a>apply、call、bind 比较</h2><p>那么 <code>apply、call、bind</code> 三者相比较，之间又有什么异同呢？何时使用 <code>apply、call</code>，何时使用 <code>bind</code> 呢。简单的一个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">81</span>,<br>&#125;;<br> <br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">getX</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">getX</span>.<span class="hljs-title function_">bind</span>(obj)());  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">getX</span>.<span class="hljs-title function_">call</span>(obj));    <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">getX</span>.<span class="hljs-title function_">apply</span>(obj));<br></code></pre></td></tr></table></figure><p>三个输出的都是 81，但是注意看使用 <code>bind()</code> 方法的，他后面多了对括号。</p><p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply&#x2F;call 则会立即执行函数。</p><p>再总结一下：</p><p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的 this 对象的指向的；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参；<br><code>bind</code> 是返回对应函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何实现一个深拷贝</title>
    <link href="/2020/05/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/05/14/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h2 id="上篇文章详细介绍了浅拷贝-Object-assign，并对其进行了模拟实现，在实现的过程中，介绍了很多基础知识。今天这篇文章我们来看看一道必会面试题，即如何实现一个深拷贝。本文会详细介绍对象、数组、循环引用、引用丢失、Symbol-和递归爆栈等情况下的深拷贝实践，欢迎阅读。-第一步：简单实现"><a href="#上篇文章详细介绍了浅拷贝-Object-assign，并对其进行了模拟实现，在实现的过程中，介绍了很多基础知识。今天这篇文章我们来看看一道必会面试题，即如何实现一个深拷贝。本文会详细介绍对象、数组、循环引用、引用丢失、Symbol-和递归爆栈等情况下的深拷贝实践，欢迎阅读。-第一步：简单实现" class="headerlink" title="上篇文章详细介绍了浅拷贝 Object.assign，并对其进行了模拟实现，在实现的过程中，介绍了很多基础知识。今天这篇文章我们来看看一道必会面试题，即如何实现一个深拷贝。本文会详细介绍对象、数组、循环引用、引用丢失、Symbol 和递归爆栈等情况下的深拷贝实践，欢迎阅读。 第一步：简单实现"></a>上篇文章详细介绍了浅拷贝 <code>Object.assign</code>，并对其进行了模拟实现，在实现的过程中，介绍了很多基础知识。今天这篇文章我们来看看一道必会面试题，即如何实现一个深拷贝。本文会详细介绍对象、数组、循环引用、引用丢失、Symbol 和递归爆栈等情况下的深拷贝实践，欢迎阅读。<br> <span id="more"></span><br>第一步：简单实现</h2><p>其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。</p><p>根据上篇文章内容，我们可以写出简单浅拷贝代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneShallow</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">var</span> target = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            target[key] = source[key];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 测试用例</span><br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;muyiy&quot;</span>,<br>    <span class="hljs-attr">book</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;You Don&#x27;t Know JS&quot;</span>,<br>        <span class="hljs-attr">price</span>: <span class="hljs-string">&quot;45&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">a1</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">a2</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">a3</span>: <span class="hljs-number">123</span><br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">cloneShallow</span>(a);<br><br>a.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;高级前端进阶&quot;</span>;<br>a.<span class="hljs-property">book</span>.<span class="hljs-property">price</span> = <span class="hljs-string">&quot;55&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">// &#123; </span><br><span class="hljs-comment">//   name: &#x27;muyiy&#x27;, </span><br><span class="hljs-comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;55&#x27; &#125;,</span><br><span class="hljs-comment">//   a1: undefined,</span><br><span class="hljs-comment">//   a2: null,</span><br><span class="hljs-comment">//   a3: 123</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码是浅拷贝实现，只要稍微改动下，加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep1</span>(<span class="hljs-params">source</span>) &#123;<br>    <span class="hljs-keyword">var</span> target = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>                target[key] = <span class="hljs-title function_">cloneDeep1</span>(source[key]); <span class="hljs-comment">// 注意这里</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[key] = source[key];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 使用上面测试用例测试一下</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">cloneDeep1</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">// &#123; </span><br><span class="hljs-comment">//   name: &#x27;muyiy&#x27;, </span><br><span class="hljs-comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;, </span><br><span class="hljs-comment">//   a1: undefined,</span><br><span class="hljs-comment">//   a2: &#123;&#125;,</span><br><span class="hljs-comment">//   a3: 123</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>一个简单的深拷贝就完成了，但是这个实现还存在很多问题。</p><ul><li><p>1、没有对传入参数进行校验，传入 <code>null</code> 时应该返回 <code>null</code> 而不是 <code>&#123;&#125;</code></p></li><li><p>2、对于对象的判断逻辑不严谨，因为 <code>typeof null === &#39;object&#39;</code></p></li><li><p>3、没有考虑数组的兼容</p></li></ul><h2 id="第二步：拷贝数组"><a href="#第二步：拷贝数组" class="headerlink" title="第二步：拷贝数组"></a>第二步：拷贝数组</h2><p>我们来看下对于对象的判断，之前在【进阶 3-3 期】有过介绍，判断方案如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Object]&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是用在这里并不合适，因为我们要保留数组这种情况，所以这里使用 <code>typeof</code> 来处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125; <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">//&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">//&quot;function&quot; (特殊情况)</span><br></code></pre></td></tr></table></figure><p>改动过后的 isObject 判断逻辑如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isObject</span>(<span class="hljs-params">obj</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以兼容数组的写法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep2</span>(<span class="hljs-params">source</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <span class="hljs-comment">// 非对象返回自身</span><br>      <br>    <span class="hljs-keyword">var</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>                target[key] = <span class="hljs-title function_">cloneDeep2</span>(source[key]); <span class="hljs-comment">// 注意这里</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[key] = source[key];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 使用上面测试用例测试一下</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">cloneDeep2</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">// &#123; </span><br><span class="hljs-comment">//   name: &#x27;muyiy&#x27;, </span><br><span class="hljs-comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;,</span><br><span class="hljs-comment">//   a1: undefined,</span><br><span class="hljs-comment">//   a2: null,</span><br><span class="hljs-comment">//   a3: 123</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h2 id="第三步：循环引用"><a href="#第三步：循环引用" class="headerlink" title="第三步：循环引用"></a>第三步：循环引用</h2><p>我们知道 <code>JSON</code> 无法深拷贝循环引用，遇到这种情况会抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-comment">// 此处 a 是文章开始的测试用例</span><br>a.<span class="hljs-property">circleRef</span> = a;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a));<br><span class="hljs-comment">// TypeError: Converting circular structure to JSON</span><br></code></pre></td></tr></table></figure><h3 id="1、使用哈希表"><a href="#1、使用哈希表" class="headerlink" title="1、使用哈希表"></a>1、使用哈希表</h3><p>解决方案很简单，其实就是循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep3</span>(<span class="hljs-params">source, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(source); <span class="hljs-comment">// 新增代码，查哈希表</span><br>      <br>    <span class="hljs-keyword">var</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;;<br>    hash.<span class="hljs-title function_">set</span>(source, target); <span class="hljs-comment">// 新增代码，哈希表设值</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>                target[key] = <span class="hljs-title function_">cloneDeep3</span>(source[key], hash); <span class="hljs-comment">// 新增代码，传入哈希表</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[key] = source[key];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下，看看效果如何。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-comment">// 此处 a 是文章开始的测试用例</span><br>a.<span class="hljs-property">circleRef</span> = a;<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">cloneDeep3</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// name: &quot;muyiy&quot;,</span><br><span class="hljs-comment">// a1: undefined,</span><br><span class="hljs-comment">//a2: null,</span><br><span class="hljs-comment">// a3: 123,</span><br><span class="hljs-comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span><br><span class="hljs-comment">// circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>完美！</p><h3 id="2、使用数组"><a href="#2、使用数组" class="headerlink" title="2、使用数组"></a>2、使用数组</h3><p>这里使用了 <code>ES6</code> 中的 <code>WeakMap</code> 来处理，那在 <code>ES5</code> 下应该如何处理呢？</p><p>也很简单，使用数组来处理就好啦，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep3</span>(<span class="hljs-params">source, uniqueList</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <br>    <span class="hljs-keyword">if</span> (!uniqueList) uniqueList = []; <span class="hljs-comment">// 新增代码，初始化数组</span><br>      <br>    <span class="hljs-keyword">var</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// ============= 新增代码</span><br>    <span class="hljs-comment">// 数据已经存在，返回保存的数据</span><br>    <span class="hljs-keyword">var</span> uniqueData = <span class="hljs-title function_">find</span>(uniqueList, source);<br>    <span class="hljs-keyword">if</span> (uniqueData) &#123;<br>        <span class="hljs-keyword">return</span> uniqueData.<span class="hljs-property">target</span>;<br>    &#125;;<br>        <br>    <span class="hljs-comment">// 数据不存在，保存源数据，以及对应的引用</span><br>    uniqueList.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">source</span>: source,<br>        <span class="hljs-attr">target</span>: target<br>    &#125;);<br>    <span class="hljs-comment">// =============</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>                target[key] = <span class="hljs-title function_">cloneDeep3</span>(source[key], uniqueList); <span class="hljs-comment">// 新增代码，传入数组</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[key] = source[key];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 新增方法，用于查找</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">arr, item</span>) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i].<span class="hljs-property">source</span> === item) &#123;<br>            <span class="hljs-keyword">return</span> arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 用上面测试用例已测试通过</span><br></code></pre></td></tr></table></figure><p>现在已经很完美的解决了循环引用这种情况，那其实还是一种情况是引用丢失，我们看下面的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123;<span class="hljs-attr">a</span>: obj1, <span class="hljs-attr">b</span>: obj1&#125;;<br><br>obj2.<span class="hljs-property">a</span> === obj2.<span class="hljs-property">b</span>; <br><span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj3 = <span class="hljs-title function_">cloneDeep2</span>(obj2);<br>obj3.<span class="hljs-property">a</span> === obj3.<span class="hljs-property">b</span>; <br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>引用丢失在某些情况下是有问题的，比如上面的对象 obj2，obj2 的键值 a 和 b 同时引用了同一个对象 obj1，使用 cloneDeep2 进行深拷贝后就丢失了引用关系变成了两个不同的对象，那如何处理呢。</p><p>其实你有没有发现，我们的 cloneDeep3 已经解决了这个问题，因为只要存储已拷贝过的对象就可以了。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 木易杨<br>var obj3 <span class="hljs-operator">=</span> cloneDeep3(obj2)<span class="hljs-comment">;</span><br>obj3.a <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> obj3.b<span class="hljs-comment">; </span><br>// true<br></code></pre></td></tr></table></figure><p>完美！</p><h2 id="第四步：拷贝-Symbol"><a href="#第四步：拷贝-Symbol" class="headerlink" title="第四步：拷贝 Symbol"></a>第四步：拷贝 <code>Symbol</code></h2><p>这个时候可能要搞事情了，那我们能不能拷贝 Symol 类型呢？</p><p>当然可以，不过 <code>Symbol</code> 在 <code>ES6</code> 下才有，我们需要一些方法来检测出 <code>Symble</code> 类型。</p><p>方法一：<code>Object.getOwnPropertySymbols(...)</code></p><p>方法二：<code>Reflect.ownKeys(...)</code></p><p><strong>对于方法一</strong>可以查找一个给定对象的符号属性时返回一个 <code>?symbol</code> 类型的数组。注意，每个初始化的对象都是没有自己的 <code>symbol</code> 属性的，因此这个数组可能为空，除非你已经在对象上设置了 <code>symbol</code> 属性。（来自 MDN）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 创建新的symbol类型</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">// 从全局的symbol注册?表设置和取得symbol</span><br><br>obj[a] = <span class="hljs-string">&quot;localSymbol&quot;</span>;<br>obj[b] = <span class="hljs-string">&quot;globalSymbol&quot;</span>;<br><br><span class="hljs-keyword">var</span> objectSymbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objectSymbols.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objectSymbols)         <span class="hljs-comment">// [Symbol(a), Symbol(b)]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objectSymbols[<span class="hljs-number">0</span>])      <span class="hljs-comment">// Symbol(a)</span><br></code></pre></td></tr></table></figure><p><strong>对于方法二</strong>返回一个由目标对象<strong>自身</strong>的属性键组成的数组。它的返回值等同于<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>。(来自 MDN)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(&#123;<span class="hljs-attr">z</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// [ &quot;z&quot;, &quot;y&quot;, &quot;x&quot; ]</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>([]); <span class="hljs-comment">// [&quot;length&quot;]</span><br><br><span class="hljs-keyword">var</span> sym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;comet&quot;</span>);<br><span class="hljs-keyword">var</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;meteor&quot;</span>);<br><span class="hljs-keyword">var</span> obj = &#123;[sym]: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;str&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;773&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-number">0</span>,<br>           [sym2]: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;-1&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;second str&quot;</span>: <span class="hljs-number">0</span>&#125;;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-comment">// [ &quot;0&quot;, &quot;8&quot;, &quot;773&quot;, &quot;str&quot;, &quot;-1&quot;, &quot;second str&quot;, Symbol(comet), Symbol(meteor) ]</span><br><span class="hljs-comment">// 注意顺序</span><br><span class="hljs-comment">// Indexes in numeric order, </span><br><span class="hljs-comment">// strings in insertion order, </span><br><span class="hljs-comment">// symbols in insertion order</span><br></code></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>思路就是先查找有没有 <code>Symbol</code> 属性，如果查找到则先遍历处理 <code>Symbol</code> 情况，然后再处理正常情况，多出来的逻辑就是下面的新增代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep4</span>(<span class="hljs-params">source, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(source); <br>      <br>    <span class="hljs-keyword">let</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;;<br>    hash.<span class="hljs-title function_">set</span>(source, target);<br>    <br>    <span class="hljs-comment">// ============= 新增代码</span><br>    <span class="hljs-keyword">let</span> symKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(source); <span class="hljs-comment">// 查找</span><br>    <span class="hljs-keyword">if</span> (symKeys.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">// 查找成功</span><br>        symKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">symKey</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[symKey])) &#123;<br>                target[symKey] = <span class="hljs-title function_">cloneDeep4</span>(source[symKey], hash); <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[symKey] = source[symKey];<br>            &#125;    <br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// =============</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(source, key)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>                target[key] = <span class="hljs-title function_">cloneDeep4</span>(source[key], hash); <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                target[key] = source[key];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试下效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-comment">// 此处 a 是文章开始的测试用例</span><br><span class="hljs-keyword">var</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 创建新的symbol类型</span><br><span class="hljs-keyword">var</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">// 从全局的symbol注册?表设置和取得symbol</span><br><br>a[sym1] = <span class="hljs-string">&quot;localSymbol&quot;</span>;<br>a[sym2] = <span class="hljs-string">&quot;globalSymbol&quot;</span>;<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">cloneDeep4</span>(a);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// name: &quot;muyiy&quot;,</span><br><span class="hljs-comment">// a1: undefined,</span><br><span class="hljs-comment">//a2: null,</span><br><span class="hljs-comment">// a3: 123,</span><br><span class="hljs-comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;,</span><br><span class="hljs-comment">// circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span><br><span class="hljs-comment">//  [Symbol(a)]: &#x27;localSymbol&#x27;,</span><br><span class="hljs-comment">//  [Symbol(b)]: &#x27;globalSymbol&#x27;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>完美！</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep4</span>(<span class="hljs-params">source, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(source); <br>      <br>    <span class="hljs-keyword">let</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;;<br>    hash.<span class="hljs-title function_">set</span>(source, target);<br>    <br>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(source).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123; <span class="hljs-comment">// 改动</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>            target[key] = <span class="hljs-title function_">cloneDeep4</span>(source[key], hash); <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            target[key] = source[key];<br>        &#125;  <br>  &#125;);<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 测试已通过</span><br></code></pre></td></tr></table></figure><p>这里使用了 <code>Reflect.ownKeys()</code> 获取所有的键值，同时包括 <code>Symbol</code>，对 source 遍历赋值即可。</p><p>写到这里已经差不多了，我们再延伸下，对于 <code>target</code> 换一种写法，改动如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 木易杨</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep4</span>(<span class="hljs-params">source, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source)) <span class="hljs-keyword">return</span> source; <br>    <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(source); <br>      <br>    <span class="hljs-keyword">let</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [...source] : &#123; ...source &#125;; <span class="hljs-comment">// 改动 1</span><br>    hash.<span class="hljs-title function_">set</span>(source, target);<br>    <br>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123; <span class="hljs-comment">// 改动 2</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(source[key])) &#123;<br>            target[key] = <span class="hljs-title function_">cloneDeep4</span>(source[key], hash); <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            target[key] = source[key];<br>        &#125;  <br>  &#125;);<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-comment">// 测试已通过</span><br></code></pre></td></tr></table></figure><p>在改动 1 中，返回一个新数组或者新对象，获取到源对象之后就可以如改动 2 所示传入 target 遍历赋值即可。</p><p><code>Reflect.ownKeys()</code> 这种方式的问题在于不能深拷贝原型链上的数据，因为返回的是目标对象<strong>自身</strong>的属性键组成的数组。如果想深拷贝原型链上的数据怎么办，那用 <code>for..in</code> 就可以了。</p><p>我们再介绍下两个知识点，分别是<strong>构造字面量数组时使用展开语法</strong>和<strong>构造字面量对象时使用展开语法</strong>。（以下代码示例来源于 MDN）</p><h4 id="1、展开语法之字面量数组"><a href="#1、展开语法之字面量数组" class="headerlink" title="1、展开语法之字面量数组"></a>1、展开语法之字面量数组</h4><p>这是 <code>ES2015 （ES6）</code> 才有的语法，可以通过字面量方式, 构造新数组，而不再需要组合使用 <code>push</code>, <code>splice</code>, <code>concat</code> 等方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> parts = [<span class="hljs-string">&#x27;shoulders&#x27;</span>, <span class="hljs-string">&#x27;knees&#x27;</span>]; <br><span class="hljs-keyword">var</span> lyrics = [<span class="hljs-string">&#x27;head&#x27;</span>, ...parts, <span class="hljs-string">&#x27;and&#x27;</span>, <span class="hljs-string">&#x27;toes&#x27;</span>]; <br><span class="hljs-comment">// [&quot;head&quot;, &quot;shoulders&quot;, &quot;knees&quot;, &quot;and&quot;, &quot;toes&quot;]</span><br></code></pre></td></tr></table></figure><p>这里的使用方法和参数列表的展开有点类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">v, w, x, y, z</span>) &#123; &#125;<br><span class="hljs-keyword">var</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br><span class="hljs-title function_">myFunction</span>(-<span class="hljs-number">1</span>, ...args, <span class="hljs-number">2</span>, ...[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>返回的是新数组，对新数组修改之后不会影响到旧数组，类似于 <code>arr.slice()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> arr2 = [...arr]; <span class="hljs-comment">// like arr.slice()</span><br>arr2.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <br><br><span class="hljs-comment">// arr2 此时变成 [1, 2, 3, 4]</span><br><span class="hljs-comment">// arr 不受影响</span><br></code></pre></td></tr></table></figure><p>展开语法和 <code>Object.assign()</code> 行为一致, 执行的都是浅拷贝（即只遍历一层）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]];<br><span class="hljs-keyword">var</span> b = [...a];<br>b.<span class="hljs-title function_">shift</span>().<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// [[], [2], [3]]</span><br></code></pre></td></tr></table></figure><p>这里 a 是多层数组，b 只拷贝了第一层，对于第二层依旧和 a 持有同一个地址，所以对 b 的修改会影响到 a。</p><h4 id="2、展开语法之字面量对象"><a href="#2、展开语法之字面量对象" class="headerlink" title="2、展开语法之字面量对象"></a>2、展开语法之字面量对象</h4><p>这是 <code>ES2018</code> 才有的语法，将已有对象的所有<strong>可枚举属性</strong>拷贝到新构造的对象中，类似于 <code>Object.assign()</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">13</span> &#125;;<br><br><span class="hljs-keyword">var</span> clonedObj = &#123; ...obj1 &#125;;<br><span class="hljs-comment">// &#123; foo: &quot;bar&quot;, x: 42 &#125;</span><br><br><span class="hljs-keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;<br><span class="hljs-comment">// &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span><br></code></pre></td></tr></table></figure><p><code>Object.assign()</code> 函数会触发 setters，而展开语法不会。有时候不能替换或者模拟 <code>Object.assign()</code> 函数，因为会得到意想不到的结果，如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">x</span>: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">13</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">merge</span> = (<span class="hljs-params"> ...objects </span>) =&gt; ( &#123; ...objects &#125; );<br><br><span class="hljs-keyword">var</span> mergedObj = <span class="hljs-title function_">merge</span> ( obj1, obj2);<br><span class="hljs-comment">// &#123; 0: &#123; foo: &#x27;bar&#x27;, x: 42 &#125;, 1: &#123; foo: &#x27;baz&#x27;, y: 13 &#125; &#125;</span><br><br><span class="hljs-keyword">var</span> mergedObj = <span class="hljs-title function_">merge</span> ( &#123;&#125;, obj1, obj2);<br><span class="hljs-comment">// &#123; 0: &#123;&#125;, 1: &#123; foo: &#x27;bar&#x27;, x: 42 &#125;, 2: &#123; foo: &#x27;baz&#x27;, y: 13 &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>这里实际上是将多个解构变为剩余参数（ <code>rest</code> ），然后再将剩余参数展开为字面量对象.</p><h2 id="第五步：破解递归爆栈"><a href="#第五步：破解递归爆栈" class="headerlink" title="第五步：破解递归爆栈"></a>第五步：破解递归爆栈</h2><p>上面四步使用的都是递归方法，但是有一个问题在于会爆栈，错误提示如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// RangeError: Maximum call stack size exceeded</span><br></code></pre></td></tr></table></figure><p>那应该如何解决呢？其实我们使用循环就可以了，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneDeep5</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">const</span> root = &#123;&#125;;<br><br>    <span class="hljs-comment">// 栈</span><br>    <span class="hljs-keyword">const</span> loopList = [<br>        &#123;<br>            <span class="hljs-attr">parent</span>: root,<br>            <span class="hljs-attr">key</span>: <span class="hljs-literal">undefined</span>,<br>            <span class="hljs-attr">data</span>: x,<br>        &#125;<br>    ];<br><br>    <span class="hljs-keyword">while</span>(loopList.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-comment">// 广度优先</span><br>        <span class="hljs-keyword">const</span> node = loopList.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-keyword">const</span> parent = node.<span class="hljs-property">parent</span>;<br>        <span class="hljs-keyword">const</span> key = node.<span class="hljs-property">key</span>;<br>        <span class="hljs-keyword">const</span> data = node.<span class="hljs-property">data</span>;<br><br>        <span class="hljs-comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span><br>        <span class="hljs-keyword">let</span> res = parent;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>            res = parent[key] = &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> data) &#123;<br>            <span class="hljs-keyword">if</span> (data.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data[k] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>                    <span class="hljs-comment">// 下一次循环</span><br>                    loopList.<span class="hljs-title function_">push</span>(&#123;<br>                        <span class="hljs-attr">parent</span>: res,<br>                        <span class="hljs-attr">key</span>: k,<br>                        <span class="hljs-attr">data</span>: data[k],<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res[k] = data[k];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于篇幅问题就不过多介绍了，详情请参考下面这篇文章。</p><blockquote><p><a href="https://segmentfault.com/a/1190000016672263">深拷贝的终极探索（99% 的人都不知道）</a></p></blockquote><h2 id="本期思考题"><a href="#本期思考题" class="headerlink" title="本期思考题"></a>本期思考题</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">如何用 JS 实现 <span class="hljs-built_in">JSON</span>.parse?<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/">深入剖析 JavaScript 的深复制</a></p><p><a href="https://segmentfault.com/a/1190000016672263">深拷贝的终极探索（99% 的人都不知道）</a></p><p><a href="https://www.jianshu.com/p/b08bc61714c7">深入 js 深拷贝对象</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN 之展开语法</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN 之 Symbol</a></p></blockquote><blockquote><p><a href="https://github.com/yygmind/blog">https://github.com/yygmind/blog</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AMD、CMD、CommonJS、ES6Module的区别</title>
    <link href="/2020/05/11/AMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6Module%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/05/11/AMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6Module%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>回想起之前的一次面试， 第一轮面试官问我 AMD 和 CMD 的区别，我只回答说 AMD 是提前加载，CMD 是按需加载。第二轮面试官又问了我 CommonJS 和 ES6 Module 的区别，emmm…，我大致回答说新的比旧的好~~，虽然面试官并没有说什么，不过显然这样的答案并不是有助于面试、有助于自己的技术积累的。</p><p>所以有必要进行一次梳理，以便更清晰地了解它们的特点及差异。</p><span id="more"></span><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD 一开始是 CommonJS 规范中的一个草案，全称是 Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以 RequireJS 实现了 AMD 规范，所以一般说 AMD 也是指 RequireJS。</p><h4 id="RequireJS-的基本用法"><a href="#RequireJS-的基本用法" class="headerlink" title="RequireJS 的基本用法"></a>RequireJS 的基本用法</h4><p>通过<code>define</code>来定义一个模块，使用<code>require</code>可以导入定义的模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-comment">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;)<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-comment">//数组中声明需要加载的模块，可以是模块名、js文件路径</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">// 1</span><br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="RequireJS-的特点"><a href="#RequireJS-的特点" class="headerlink" title="RequireJS 的特点"></a>RequireJS 的特点</h4><p>对于依赖的模块，AMD 推崇<strong>依赖前置，提前执行</strong>。也就是说，在<code>define</code>方法里传入的依赖模块 (数组)，会在一开始就下载并执行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 是 SeaJS 在推广过程中生产的对模块定义的规范，在 Web 浏览器端的模块加载器中，SeaJS 与 RequireJS 并称，SeaJS 作者为阿里的玉伯。</p><h4 id="SeaJS-的基本用法"><a href="#SeaJS-的基本用法" class="headerlink" title="SeaJS 的基本用法"></a>SeaJS 的基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串，</span><br><span class="hljs-comment">* factory 为对象、字符串时，表示模块的接口就是该对象、字符串。</span><br><span class="hljs-comment">* define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<br><br>  <span class="hljs-built_in">exports</span>.<span class="hljs-property">setColor</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;#333&#x27;</span>);<br>  &#125;;<br>&#125;);<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-comment">//数组中声明需要加载的模块，可以是模块名、js文件路径</span><br>seajs.<span class="hljs-title function_">use</span>([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) &#123;<br>  $(<span class="hljs-string">&#x27;#el&#x27;</span>).<span class="hljs-title function_">click</span>(a.<span class="hljs-property">setColor</span>);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><h4 id="SeaJS-的特点"><a href="#SeaJS-的特点" class="headerlink" title="SeaJS 的特点"></a>SeaJS 的特点</h4><p>对于依赖的模块，CMD 推崇<strong>依赖就近，延迟执行</strong>。也就是说，只有到<code>require</code>时依赖模块才执行。</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 规范为 CommonJS 小组所提出，目的是弥补 JavaScript 在服务器端缺少模块化机制，NodeJS、webpack 都是基于该规范来实现的。</p><h4 id="CommonJS-的基本用法"><a href="#CommonJS-的基本用法" class="headerlink" title="CommonJS 的基本用法"></a>CommonJS 的基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><br><span class="hljs-title function_">a</span>();<span class="hljs-comment">//&quot;hello world&quot;</span><br><br><span class="hljs-comment">//或者</span><br><br><span class="hljs-comment">//a2.js</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">num</span> = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">obj</span> = &#123;<span class="hljs-attr">xx</span>: <span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-comment">//b2.js</span><br><span class="hljs-keyword">var</span> a2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a2&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);<span class="hljs-comment">//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="CommonJS-的特点"><a href="#CommonJS-的特点" class="headerlink" title="CommonJS 的特点"></a>CommonJS 的特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作；</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；</li><li>CommonJS 输出是值的拷贝 (即，<code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。</li></ul><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module 是 ES6 中规定的模块体系，相比上面提到的规范， ES6 Module 有更多的优势，有望成为浏览器和服务器通用的模块解决方案。</p><h4 id="ES6-Module-的基本用法"><a href="#ES6-Module-的基本用法" class="headerlink" title="ES6 Module 的基本用法"></a>ES6 Module 的基本用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;lin&#x27;</span>;<br><span class="hljs-keyword">var</span> age = <span class="hljs-number">13</span>;<br><span class="hljs-keyword">var</span> job = <span class="hljs-string">&#x27;ninja&#x27;</span>;<br><br><span class="hljs-keyword">export</span> &#123; name, age, job&#125;;<br><br><span class="hljs-comment">//b.js</span><br><span class="hljs-keyword">import</span> &#123; name, age, job&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age, job);<span class="hljs-comment">// lin 13 ninja</span><br><br><span class="hljs-comment">//或者</span><br><br><span class="hljs-comment">//a2.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;default &#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//b2.js</span><br><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a2.js&#x27;</span>;<br><span class="hljs-title function_">customName</span>(); <span class="hljs-comment">// &#x27;default&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure><h4 id="ES6-Module-的特点-对比-CommonJS"><a href="#ES6-Module-的特点-对比-CommonJS" class="headerlink" title="ES6 Module 的特点 (对比 CommonJS)"></a>ES6 Module 的特点 (对比 CommonJS)</h4><ul><li>CommonJS 模块是运行时加载，ES6 Module 是编译时输出接口；</li><li>CommonJS 加载的是整个模块，将所有的接口全部加载进来，ES6 Module 可以单独加载其中的某个接口；</li><li>CommonJS 输出是值的拷贝，ES6 Module 输出的是值的引用，被输出模块的内部的改变会影响引用的改变；</li><li>CommonJS <code>this</code>指向当前模块，ES6 Module <code>this</code>指向<code>undefined</code>;</li></ul><p>目前浏览器对 ES6 Module 兼容还不太好，我们平时在 webpack 中使用的<code>export</code>&#x2F;<code>import</code>，会被打包为<code>exports</code>&#x2F;<code>require</code>。</p><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>这里比较宽泛地把 JavaScript 中的几大模块化规范列举出来，希望借此对 JavaScript 模块化有大致的认识，而未对细节展开具体分析，感兴趣的可以自行探索。</p><p>原文地址 <a href="https://juejin.im/post/5db95e3a6fb9a020704bcd8d">https://juejin.im/post/5db95e3a6fb9a020704bcd8d</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法高频问题</title>
    <link href="/2020/05/07/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/07/%E7%AE%97%E6%B3%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>文中所有题目均为精心挑选过的超高频题目，所以大家可以收藏起来</p><h2 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h2><p>针对有一定数据结构基础 (了解链表, 二叉树, 二叉堆, 递归) 的基本概念, 并对时间空间复杂度有基本认知的。</p><h2 id="食用指南"><a href="#食用指南" class="headerlink" title="食用指南"></a>食用指南</h2><p>将文中列出的每道题至少手写 3 遍</p><h2 id="面试前可以按照本文整理出来的题目直接过一遍说明"><a href="#面试前可以按照本文整理出来的题目直接过一遍说明" class="headerlink" title="面试前可以按照本文整理出来的题目直接过一遍说明"></a>面试前可以按照本文整理出来的题目直接过一遍<br><span id="more"></span><br>说明</h2><p>文章更新频率: 除休息日外, 每天在题目下方更新一道题的题解</p><p>有 LeetCode 原题的将贴上原地址，不在文章内做题目描述</p><blockquote><p>Tc: Time complexity (时间复杂度)</p></blockquote><blockquote><p>Sc: Space complexity (空间复杂度)</p></blockquote><h2 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h2><h3 id="数组篇"><a href="#数组篇" class="headerlink" title="数组篇"></a>数组篇</h3><h4 id="1-twoSum-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#1-twoSum-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="1.twoSum [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>1.twoSum [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">LeetCode 第 1 题</a></p><p>按照题目要求, 我们第一时间想到的会是两层循环暴力解法：</p><p><strong>解法 1：Time &#x3D; O(n²), Space &#x3D; O(1)</strong></p><p>思路: 遍历每个元素 nums[j]，并查找是否存在一个值与 target - nums[j] 相等的目标元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums, target</span>) &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) &#123;<br>             <span class="hljs-keyword">if</span> (nums[j] == target - nums[i]) &#123;<br>                 <span class="hljs-keyword">return</span> [i,j];<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> [];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>**解法 2:Time &#x3D; O(n), Space &#x3D; O(n)**：</p><p>我们可以通过哈希表空间换时间。在进行迭代并将元素插入到表中的同时，我们回过头来检查哈希表中是否已经存在当前元素所对应的目标元素，如果存在，那我们就找到了问题的解，将其返回即可.(时间复杂度为 O(n), 空间复杂度也为 O(n))</p><p>符合题目要求 bingo✌</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> reduceHash = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> reduceResult = target - nums[i];<br>        <span class="hljs-keyword">if</span> (reduceHash[reduceResult] !== <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> [reduceHash[reduceResult], i];<br>        &#125;<br>        reduceHash[nums[i]] = i;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="2-缺失的数字-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#2-缺失的数字-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="2. 缺失的数字 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>2. 缺失的数字 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 第 53 题</a></p><p><strong>解法：</strong></p><p>思路: 我们先把所有输入了的数字存入 hash 表, 因为给定的数组是有序的，所以可以再过一遍 hash 表，遍历过程中如果某个数字在 hash 表中不存在，则该数字就是缺失的那个数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> missingNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> hash = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        hash[nums[i]] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> expectedNumCount = nums.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; expectedNumCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!hash[i]) &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">missingNumber</span>([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]));<span class="hljs-comment">//3</span><br><br></code></pre></td></tr></table></figure><h4 id="3-移动零-要求-Tc-O-n-Sc-O-1-移动后不能改变原来其他元素的相对位置-二线公司"><a href="#3-移动零-要求-Tc-O-n-Sc-O-1-移动后不能改变原来其他元素的相对位置-二线公司" class="headerlink" title="3. 移动零 [要求 Tc: O(n) Sc:O(1), 移动后不能改变原来其他元素的相对位置] (二线公司)"></a>3. 移动零 [要求 Tc: O(n) Sc:O(1), 移动后不能改变原来其他元素的相对位置] (二线公司)</h4><p><a href="https://leetcode-cn.com/problems/move-zeroes/">LeetCode 第 283 题</a></p><p><strong>解法：</strong></p><p><strong>思路:</strong> 双指针同向而行, fast 指针遇到非 0 就把 slow 指针位置的字符替换掉，slow 指针前进一步。直到 fast 指针把数组所有元素遍历完毕。(典型的两个挡板，三个区域思想), 再把 slow 指针后面的所有元素替换为 0。</p><p>同向性质:</p><p><strong>变量的物理意义:</strong> slow 的左侧不包含 slow 都是非 0 的数字，slow 的右侧包含 slow 都应该为 0，按照这个物理意义就可以达到原地算法的要求。因为快慢指针是同向而行的，所以算法为稳定算法 (不会影响元素的相对位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-property">length</span>; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] !== <span class="hljs-number">0</span>) &#123;<br>            nums[slow++] = nums[fast];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (slow &lt; nums.<span class="hljs-property">length</span>) &#123;<br>        nums[slow++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> input = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>];<br><span class="hljs-title function_">moveZeroes</span>(input);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input);<br><br></code></pre></td></tr></table></figure><h4 id="4-洗牌算法-乱序数组-要求-Tc-O-n-Sc-O-1-要求每个元素的打乱的概率相同-快手"><a href="#4-洗牌算法-乱序数组-要求-Tc-O-n-Sc-O-1-要求每个元素的打乱的概率相同-快手" class="headerlink" title="4. 洗牌算法 (乱序数组)[要求 Tc: O(n) Sc:O(1), 要求每个元素的打乱的概率相同] (快手)"></a>4. 洗牌算法 (乱序数组)[要求 Tc: O(n) Sc:O(1), 要求每个元素的打乱的概率相同] (快手)</h4><p><a href="https://leetcode-cn.com/problems/shuffle-an-array/">LeetCode 第 384 题</a></p><p><strong>解法:</strong></p><p><strong>思路:</strong> 本题思路就是使用 Fisher-Yates 洗牌算法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> m = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (m) &#123;<br>        <span class="hljs-keyword">let</span> random = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * m--) | <span class="hljs-number">0</span>;<br>        [arr[random],arr[m]] = [arr[m],arr[random]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">shuffle</span>([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>]));<br><br></code></pre></td></tr></table></figure><h4 id="5-两个数组的交集-要求-Tc-O-n-Sc-O-n-阿里"><a href="#5-两个数组的交集-要求-Tc-O-n-Sc-O-n-阿里" class="headerlink" title="5. 两个数组的交集 [要求 Tc: O(n) Sc:O(n)] (阿里)"></a>5. 两个数组的交集 [要求 Tc: O(n) Sc:O(n)] (阿里)</h4><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">LeetCode 第 349 题</a></p><p><strong>解法:</strong></p><p><strong>思路:</strong> 本题思路是看 nums1 数组里是否含有 nums2 的元素，如果有就添加到结果中返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-property">length</span>; i++) &#123;<br>   <span class="hljs-keyword">const</span> cur = nums1[i];<br>   <span class="hljs-keyword">if</span> (nums2.<span class="hljs-title function_">includes</span>(cur)) &#123;<br>       res.<span class="hljs-title function_">push</span>(cur);<br>   &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(res));<br><br></code></pre></td></tr></table></figure><h4 id="6-RainbowSort-要求-Tc-O-n-Sc-O-1-盛大"><a href="#6-RainbowSort-要求-Tc-O-n-Sc-O-1-盛大" class="headerlink" title="6.RainbowSort [要求 Tc: O(n) Sc:O(1)] (盛大)"></a>6.RainbowSort [要求 Tc: O(n) Sc:O(1)] (盛大)</h4><p>给定一系列球，其中球的颜色只能是红色，黄色或蓝色，对球进行排序，以使所有红色球都分组在左侧，所有黄色球都分组在中间，所有蓝色球分组在右侧。</p><p>例：</p><blockquote><p>[红] 被排序为 [红]</p></blockquote><blockquote><p>[黄，红] 被排序为 [红，黄]</p></blockquote><blockquote><p>[黄, 红, 红, 蓝, 黄, 红, 蓝] 被排序为 [红, 红, 红, 黄, 黄, 蓝, 蓝]</p></blockquote><p>假设条件:</p><blockquote><p>输入数组不为 null。</p></blockquote><p>corner case:</p><p>如果输入数组的长度为零怎么办？在这种情况下，我们应该直接返回空数组。</p><p><strong>解法：</strong></p><p><strong>思路:</strong> 本题思路是挡板思想, 使用三个挡板四个区域的思想进行划分 (交换数组元素位置)</p><p><strong>挡板的物理意义: [0-i) 全是红色,[i,j) 之间为黄色,(k-&gt;n-1] 全为蓝色，[j-k] 为未知探索区域</strong></p><p>j 为快指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = [<span class="hljs-string">&#x27;黄&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;蓝&#x27;</span>,<span class="hljs-string">&#x27;黄&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;蓝&#x27;</span>]<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rainbowSort</span>(<span class="hljs-params">rainbow</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = rainbow.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &lt;= k) &#123;<br>        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;红&#x27;</span>) &#123;<br>            <span class="hljs-title function_">swap</span>(rainbow,i,j);<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;黄&#x27;</span>) &#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;蓝&#x27;</span>) &#123;<br>            <span class="hljs-title function_">swap</span>(rainbow, j, k); <span class="hljs-comment">//这里不写j++是因为从k交换过来的元素不能保证就是黄色,为了安全起见下次循环再检查一次j位置。</span><br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//辅助交换函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr,i,j</span>) &#123;<br>    [arr[i],arr[j]] = [arr[j],arr[i]]<br>&#125;<br><span class="hljs-title function_">rainbowSort</span>(input);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input);<br><br></code></pre></td></tr></table></figure><h4 id="7-移除元素-要求-Tc-O-n-Sc-O-1"><a href="#7-移除元素-要求-Tc-O-n-Sc-O-1" class="headerlink" title="7. 移除元素 [要求 Tc: O(n) Sc:O(1)]"></a>7. 移除元素 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/remove-element/">LeetCode 第 27 题</a></p><p><strong>解法：</strong></p><p><strong>思路:</strong> 双指针同向而行, 快指针遇到非 val 就把 slow 指针位置的字符替换掉，slow 指针前进，直到数组所有元素遍历完毕。(典型的两个挡板，三个区域思想)</p><p><strong>变量的物理意义:</strong> slow 的左侧不包含 slow 都是非 val 的元素，slow 的右侧包含 slow 都应该为不包含 val 的元素，按照这个物理意义就可以达到原地算法的要求。因为快慢指针是同向而行的，所以算法为稳定算法 (不会影响元素的相对位置)</p><p><strong>挡板性质:</strong></p><p><strong>同向而行:</strong> slow 指针左边是处理好的元素 fast 指针右边是未知探索区域, 两个挡板中间不关注 (最后的结果不会改变元素相对位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, val</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-property">length</span>; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] !== val) &#123;<br>         nums[slow++] = nums[fast];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">//想要拿到去除后的数组可以: nums.slice(0,slow);</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="8-按奇偶排序数组-要求-Tc-O-n-Sc-O-1-腾讯"><a href="#8-按奇偶排序数组-要求-Tc-O-n-Sc-O-1-腾讯" class="headerlink" title="8. 按奇偶排序数组 [要求 Tc: O(n) Sc:O(1)] (腾讯)"></a>8. 按奇偶排序数组 [要求 Tc: O(n) Sc:O(1)] (腾讯)</h4><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">LeetCode 第 905 题</a></p><p><strong>解法：</strong></p><p><strong>思路:</strong> 继续使用挡板思想, 两个挡板三个区域, 同向而行,[0-i) 是偶数,[j-n-1] 是未探索区域</p><p><strong>挡板性质:</strong></p><p><strong>同向而行:</strong> slow 指针左边是处理好的元素 fast 指针右边是未知探索区域, 两个挡板中间不关注 (最后的结果不会改变元素相对位置)</p><p><strong>解法 1:(不改变元素相对位置: 同向而行)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sortArrayByParity = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; A.<span class="hljs-property">length</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (A[j] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-title function_">swap</span>(A, i++, j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr,l,r</span>) &#123;<br>    [arr[l],arr[r]] = [arr[r],arr[l]];<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sortArrayByParity</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]));<br><br></code></pre></td></tr></table></figure><p><strong>挡板性质:</strong></p><p><strong>相向而行:</strong> left 指针左边是处理好的元素, right 指针右边也是处理好的元素, 两个挡板中间是未处理区域 (最后的结果可能会改变元素相对位置)</p><p><strong>解法 2:(改变元素相对位置: 相向而行)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sortArrayByParityII = <span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = A.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">if</span> (A[i] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>           i++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[j] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;<br>           j--;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//i % 2 !== 0 &amp;&amp; j % 2 === 0</span><br>            <span class="hljs-title function_">swap</span>(A,i,j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> A;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, l, r</span>) &#123;<br>    [arr[l], arr[r]] = [arr[r], arr[l]];<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sortArrayByParityII</span>([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]));<br><br></code></pre></td></tr></table></figure><h4 id="9-数组中出现次数超过一半的数字-要求-Tc-O-n-Sc-O-1"><a href="#9-数组中出现次数超过一半的数字-要求-Tc-O-n-Sc-O-1" class="headerlink" title="9. 数组中出现次数超过一半的数字 [要求 Tc: O(n) Sc:O(1)]"></a>9. 数组中出现次数超过一半的数字 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/majority-element/">LeetCode 第 169 题</a></p><p><strong>思路:</strong> 这道题属于火拼问题, 见一个 sha 一个 (抵消), 最后留下的就是超过一半的元素。</p><p>先保留第一个元素，接着遍历，如果遇到和他相同的则加次数，否则就减次数，如果次数为 0 了就要换另一个元素了。</p><p>比如: A B C A</p><p>第一次保留 A, 用 A 跟剩下的打架，碰到不是 A 的就把 A 的个数减 1，如果遇到 A 就增加个数，直到遇到不同的元素把 A 的次数抵消完就把 A 踢下去, 并且把次数重新设置为 1。</p><p>如此下去最后肯定有个多出来的就是题解了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> num = array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (num !== array[i]) &#123;<br>            count--;<br>            <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) &#123;<br>                num = array[i];<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;;<br><span class="hljs-keyword">let</span> halfValue = <span class="hljs-title function_">majorityElement</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(halfValue); <span class="hljs-comment">//1</span><br><br></code></pre></td></tr></table></figure><h4 id="10-合并两个有序数组-要求-Tc-O-m-n-Sc-O-n-腾讯"><a href="#10-合并两个有序数组-要求-Tc-O-m-n-Sc-O-n-腾讯" class="headerlink" title="10. 合并两个有序数组 [要求 Tc: O(m + n) Sc:O(n)] (腾讯)"></a>10. 合并两个有序数组 [要求 Tc: O(m + n) Sc:O(n)] (腾讯)</h4><p>例:</p><blockquote><p>输入: nums1 &#x3D; [1,3], nums2 &#x3D; [4,5,7]</p></blockquote><blockquote><p>输出: [1,3,4,5,7]</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left[i] &lt; right[j] ? left[i++] : right[j++]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left[i++]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(right[j++]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">let</span> merged = <span class="hljs-title function_">merge</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(merged);<br><br></code></pre></td></tr></table></figure><h4 id="11-有序数组中小于某个数的个数-要求-Tc-O-logn-Sc-O-1-今日头条"><a href="#11-有序数组中小于某个数的个数-要求-Tc-O-logn-Sc-O-1-今日头条" class="headerlink" title="11. 有序数组中小于某个数的个数 [要求 Tc: O(logn) Sc:O(1)] (今日头条)"></a>11. 有序数组中小于某个数的个数 [要求 Tc: O(logn) Sc:O(1)] (今日头条)</h4><p>例:</p><blockquote><p>输入:[1, 2, 3, 4]</p></blockquote><blockquote><p>输入目标值: 2</p></blockquote><blockquote><p>输出: 1</p></blockquote><p><strong>思路:</strong> 题目提到有序数组，第一时间就应该想到二分 (再加之复杂度要求 logn 级别)。其实这道题就是让写个二分查找, 仔细想想，你要找的那个数的下标不就代表前面有几个比他小的数字吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> high = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>        <span class="hljs-keyword">const</span> mid = (low + (high - low) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> middleValue = array[mid];<br>        <span class="hljs-keyword">if</span> (middleValue &gt; target) &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &lt; target) &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> minCount = <span class="hljs-title function_">binarySearch</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(minCount); <span class="hljs-comment">// 1</span><br><br></code></pre></td></tr></table></figure><h4 id="12-数组去重-要求-Tc-O-n-Sc-O-1"><a href="#12-数组去重-要求-Tc-O-n-Sc-O-1" class="headerlink" title="12. 数组去重 [要求 Tc: O(n) Sc:O(1)]"></a>12. 数组去重 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LeetCode 第 26 题</a></p><p>该算法要求原地算法，所以继续使用挡板思想 (没理解的可以回到上文提及处继续理解)。</p><p>因为他至少有一个元素是不会重复的 (至少会保留一个元素)，所以从下标 1 开始处理。</p><p><strong>解法 1:</strong> 从索引 1 开始 (处理好的元素不包含 slow 位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fast = <span class="hljs-number">1</span>; fast &lt; arr.<span class="hljs-property">length</span>; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[fast] === arr[slow - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        arr[slow++] = arr[fast];<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow; <span class="hljs-comment">//想要拿到去除后的数组可以: arr.slice(0, slow);</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>解法 2:</strong> 从索引 0 开始,(处理好的元素包含 slow 位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fast = <span class="hljs-number">1</span>; fast &lt; arr.<span class="hljs-property">length</span>; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[fast] === arr[slow]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        arr[++slow] = arr[fast];<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>; <span class="hljs-comment">//想要拿到去除后的数组可以: arr.slice(0, slow + 1);</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="13-去掉连续的-a-和-c-保留所有-b-要求-Tc-O-n-Sc-O-1-元素相对位置不变-字节跳动"><a href="#13-去掉连续的-a-和-c-保留所有-b-要求-Tc-O-n-Sc-O-1-元素相对位置不变-字节跳动" class="headerlink" title="13. 去掉连续的 a 和 c, 保留所有 b [要求 Tc: O(n) Sc:O(1) 元素相对位置不变] (字节跳动)"></a>13. 去掉连续的 a 和 c, 保留所有 b [要求 Tc: O(n) Sc:O(1) 元素相对位置不变] (字节跳动)</h4><p><strong>思路:</strong> 还是使用快慢指针, 同向而行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAC</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>,fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; arr.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">if</span> (arr[fast] === <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>            arr[slow++] = arr[fast++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> begin = fast;<br>            <span class="hljs-keyword">while</span> (fast &lt; arr.<span class="hljs-property">length</span> &amp;&amp; arr[fast + <span class="hljs-number">1</span>] === arr[begin]) &#123;<br>                fast++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fast - begin === <span class="hljs-number">0</span>) &#123;<br>                arr[slow++] = arr[fast++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fast++;<br>            &#125;<br>        &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,slow).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">j1</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<span class="hljs-comment">//bcb</span><br><br></code></pre></td></tr></table></figure><h4 id="14-最长公共前缀-拼多多"><a href="#14-最长公共前缀-拼多多" class="headerlink" title="14. 最长公共前缀 (拼多多)"></a>14. 最长公共前缀 (拼多多)</h4><blockquote><p>例: [‘aaafsd’, ‘aawwewer’, ‘aaddfff’] &#x3D;&gt; ‘aa’</p></blockquote><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">LeetCode 第 14 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LCP</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!arr.<span class="hljs-property">length</span>) &#123;   <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> ans = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;j &lt; ans.<span class="hljs-property">length</span> &amp;&amp; j &lt; arr[i].<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (ans[j] !== arr[i][j]) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        ans = ans.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,j);<br>        <span class="hljs-keyword">if</span> (ans === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">LCP</span>([<span class="hljs-string">&#x27;aaafsd&#x27;</span>, <span class="hljs-string">&#x27;aawwewer&#x27;</span>, <span class="hljs-string">&#x27;aaddfff&#x27;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br></code></pre></td></tr></table></figure><h4 id="15-给定一个整数数组-a，其中-1-≤-a-i-≤-n-（n-为数组长度）-其中有些元素出现两次而其他元素出现一次-找到所有出现两次的元素-要求-Tc-O-n-Sc-O-1-字节跳动"><a href="#15-给定一个整数数组-a，其中-1-≤-a-i-≤-n-（n-为数组长度）-其中有些元素出现两次而其他元素出现一次-找到所有出现两次的元素-要求-Tc-O-n-Sc-O-1-字节跳动" class="headerlink" title="15. 给定一个整数数组 a，其中 1 ≤ a[i] ≤ n （n 为数组长度）, 其中有些元素出现两次而其他元素出现一次, 找到所有出现两次的元素 [要求 Tc: O(n) Sc:O(1)] (字节跳动)"></a>15. 给定一个整数数组 a，其中 1 ≤ a[i] ≤ n （n 为数组长度）, 其中有些元素出现两次而其他元素出现一次, 找到所有出现两次的元素 [要求 Tc: O(n) Sc:O(1)] (字节跳动)</h4><blockquote><p>例: 输入: [4,3,2,7,8,2,3,1] 输出: [2,3]</p></blockquote><p>解：<strong>目前没有思路</strong></p><h4 id="16-数组中所有元素组成的最大数是多少-作业帮"><a href="#16-数组中所有元素组成的最大数是多少-作业帮" class="headerlink" title="16. 数组中所有元素组成的最大数是多少 (作业帮)"></a>16. 数组中所有元素组成的最大数是多少 (作业帮)</h4><blockquote><p>例: [50, 2, 5, 9] &#x3D;&gt; 95502</p></blockquote><p><strong>思路:</strong> 我们把最大的数字依次排序肯定就是最大数 (降序排列)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> largestNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">S1</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">S2</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;b&#125;</span><span class="hljs-subst">$&#123;a&#125;</span>`</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">S2</span> - <span class="hljs-variable constant_">S1</span>;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] ? nums.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) : <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/largest-number">LeetCode 第 179 题</a></p><h3 id="字符串篇"><a href="#字符串篇" class="headerlink" title="字符串篇"></a>字符串篇</h3><h4 id="1-回文数-要求-Tc-O-log10n-Sc-O-1-或-Tc-O-n-Sc-O-1-腾讯"><a href="#1-回文数-要求-Tc-O-log10n-Sc-O-1-或-Tc-O-n-Sc-O-1-腾讯" class="headerlink" title="1. 回文数 [要求 Tc: O(log10n) Sc:O(1) 或 Tc: O(n) Sc:O(1)] (腾讯)"></a>1. 回文数 [要求 Tc: O(log10n) Sc:O(1) 或 Tc: O(n) Sc:O(1)] (腾讯)</h4><p><a href="https://leetcode-cn.com/problems/palindrome-number/">LeetCode 第 9 题</a></p><p><strong>思路:</strong> 使用双指针一个在前，一个在后, 前后对比。遇到两个指针不同就返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">palindrome</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = x.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">if</span> (x[i] !== x[j]) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>           i++;<br>           j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">palindrome</span>(<span class="hljs-string">&#x27;lol&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br></code></pre></td></tr></table></figure><h4 id="2-反转字符串-要求-Tc-O-n-Sc-O-1"><a href="#2-反转字符串-要求-Tc-O-n-Sc-O-1" class="headerlink" title="2. 反转字符串 [要求 Tc: O(n) Sc:O(1)]"></a>2. 反转字符串 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/reverse-string/">LeetCode 第 344 题</a></p><p><strong>思路:</strong> 使用双指针一个在前，一个在后, 每次都交换即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseString = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fast = s.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, slow = <span class="hljs-number">0</span>; fast &gt;= slow; fast--) &#123;<br>        <span class="hljs-title function_">swap</span>(s, slow++, fast);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, l, r</span>)&#123;<br>    <span class="hljs-keyword">let</span> temp = arr[l];<br>    arr[l] = arr[r];<br>    arr[r] = temp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-翻转单词顺序-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#3-翻转单词顺序-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="3. 翻转单词顺序 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>3. 翻转单词顺序 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 第 58 题</a></p><p><strong>思路:</strong> 将字符串按空格分割, 然后按照上题的方法交换单词顺序即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseWords = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> strArr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);<br>    <span class="hljs-keyword">let</span> reversed = strArr;<br>    <span class="hljs-title function_">reverse</span>(reversed, <span class="hljs-number">0</span>, reversed.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> reversed.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">input, left, right</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title function_">swap</span>(input, left, right);<br>    <span class="hljs-title function_">reverse</span>(input, left + <span class="hljs-number">1</span>, right -<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">arr, l, r</span>) &#123;<br>    [arr[l],arr[r]] = [arr[r],arr[l]];<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="4-有效的字母异位词-Anagram-要求-Tc-O-n-Sc-O-n"><a href="#4-有效的字母异位词-Anagram-要求-Tc-O-n-Sc-O-n" class="headerlink" title="4. 有效的字母异位词 (Anagram) [要求 Tc: O(n) Sc:O(n)]"></a>4. 有效的字母异位词 (Anagram) [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/valid-anagram/">LeetCode 第 242 题</a></p><p><strong>思路:</strong> 我们可以使用 hash 存储每个单词出现的次数，再用另一个字符串遍历一次进行减减操作，只要次数有不等于 0 的字母则返回 false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isAnagram = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) &#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> !== t.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> s) &#123;<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(item)) &#123;<br>            map.<span class="hljs-title function_">set</span>(item, map.<span class="hljs-title function_">get</span>(item) + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.<span class="hljs-title function_">set</span>(item, <span class="hljs-number">1</span>);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(item)) &#123;<br>            map.<span class="hljs-title function_">set</span>(item, map.<span class="hljs-title function_">get</span>(item) - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="5-找出字符串中出现次数最多的字母-要求-Tc-O-n-Sc-O-n"><a href="#5-找出字符串中出现次数最多的字母-要求-Tc-O-n-Sc-O-n" class="headerlink" title="5. 找出字符串中出现次数最多的字母 [要求 Tc: O(n) Sc:O(n)]"></a>5. 找出字符串中出现次数最多的字母 [要求 Tc: O(n) Sc:O(n)]</h4><blockquote><p>例 1: 输入’abccdtc’</p></blockquote><blockquote><p>输出: ‘c’</p></blockquote><blockquote><p>例 2: 输入’abbbbccdtc’</p></blockquote><blockquote><p>输出: ‘b’</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxCount</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> maxCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxElement = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> cur = str[i];<br>        <span class="hljs-keyword">if</span> (hash[cur]) &#123;<br>            hash[cur]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hash[cur] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maxCount &lt; hash[cur]) &#123;<br>            maxElement = cur;<br>            maxCount = hash[cur];<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> maxElement;<br>&#125;<br><span class="hljs-keyword">let</span> letter = <span class="hljs-title function_">maxCount</span>(<span class="hljs-string">&#x27;abccdtc&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(letter);<br><br></code></pre></td></tr></table></figure><h4 id="6-替换空格-要求-Tc-O-n-Sc-O-1-不允许使用正则表达式-今日头条"><a href="#6-替换空格-要求-Tc-O-n-Sc-O-1-不允许使用正则表达式-今日头条" class="headerlink" title="6. 替换空格 [要求 Tc: O(n) Sc:O(1) 不允许使用正则表达式] (今日头条)"></a>6. 替换空格 [要求 Tc: O(n) Sc:O(1) 不允许使用正则表达式] (今日头条)</h4><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 第 5 题</a></p><p><strong>思路:</strong> 使用快慢指针, 同向而行，快指针负责判断是不是空格，慢指针左侧都是处理好的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> replaceSpace = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    s = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-property">length</span>; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (s[fast] === <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s[fast] = <span class="hljs-string">&#x27;%20&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>其他解法 (不推荐面试中使用):</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> replaceSpace = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    s = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;%20&#x27;</span>);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;;<br><br><span class="hljs-keyword">var</span> replaceSpace = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    s = s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>,<span class="hljs-string">&#x27;%20&#x27;</span>);<br>    <span class="hljs-keyword">return</span> s;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="7-第一个只出现一次的字符-要求-Tc-O-n-Sc-O-n"><a href="#7-第一个只出现一次的字符-要求-Tc-O-n-Sc-O-n" class="headerlink" title="7. 第一个只出现一次的字符 [要求 Tc: O(n) Sc:O(n)]"></a>7. 第一个只出现一次的字符 [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 第 50 题</a></p><p><strong>思路:</strong> 遍历过程中存 hash 表, 如果当前值第一次出现就设置为 false, 后续处理遍历值为 false 的, 遇到为 false 的就直接返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> hash = &#123;&#125;;<br>    <span class="hljs-keyword">let</span> firstAppearLetter = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (s === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hash[s[i]] === <span class="hljs-literal">undefined</span>) &#123;<br>                hash[s[i]] = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hash[s[i]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(hash)) &#123;<br>        <span class="hljs-keyword">if</span> (!value) &#123;<br>            <span class="hljs-keyword">return</span> key;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="8-左旋转字符串-要求-Tc-O-n-Sc-O-n"><a href="#8-左旋转字符串-要求-Tc-O-n-Sc-O-n" class="headerlink" title="8. 左旋转字符串 [要求 Tc: O(n) Sc:O(n)]"></a>8. 左旋转字符串 [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 第 58 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseLeftWords = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> frontStr = s.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">let</span> backStr = s.<span class="hljs-title function_">slice</span>(n);<br>    <span class="hljs-keyword">return</span> backStr + frontStr;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="9-字符串全排列-要求-Tc-O-n-Sc-O-n²-阿里"><a href="#9-字符串全排列-要求-Tc-O-n-Sc-O-n²-阿里" class="headerlink" title="9. 字符串全排列 [要求 Tc: O(n!) Sc:O(n²)] (阿里)"></a>9. 字符串全排列 [要求 Tc: O(n!) Sc:O(n²)] (阿里)</h4><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 第 38 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> permutation = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> solution = [];<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> solution;<br>    &#125;<br>    <span class="hljs-title function_">permutationHelper</span>(s, solution);<br>    <span class="hljs-keyword">return</span> solution;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">permutationHelper</span>(<span class="hljs-params">s, solution, used = [], path = []</span>) &#123;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === s.<span class="hljs-property">length</span>) &#123;<br>        solution.<span class="hljs-title function_">push</span>(path.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> levelSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!levelSet.<span class="hljs-title function_">has</span>(s[i])) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                levelSet.<span class="hljs-title function_">add</span>(s[i]);<br>                path.<span class="hljs-title function_">push</span>(s[i]);<br>                <span class="hljs-title function_">permutationHelper</span>(s, solution, used, path);<br>                used[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//回溯</span><br>                path.<span class="hljs-title function_">pop</span>();<span class="hljs-comment">//回到母节点往右走时应该删除添加过的节点,防止保留意外的结果</span><br>            &#125;   <br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="10-合并连续数字-要求-Tc-O-n-Sc-O-1-今日头条"><a href="#10-合并连续数字-要求-Tc-O-n-Sc-O-1-今日头条" class="headerlink" title="10. 合并连续数字 [要求 Tc: O(n) Sc:O(1)] (今日头条)"></a>10. 合并连续数字 [要求 Tc: O(n) Sc:O(1)] (今日头条)</h4><blockquote><p>题目描述:</p></blockquote><blockquote><p>输入:[0, 2, 3, 5, 6, 7, 8, 9, 11, 13, 56, 57]</p></blockquote><blockquote><p>输出结果：</p></blockquote><blockquote><p>0,2-3,5-9,11,13,56-57</p></blockquote><p><strong>思路:</strong> 三指针, 同向而行, slow 左边的为处理好的元素, f 指针快速向前走, begin 指针记录区间开始区间, prev 指针记录区间结束位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-number">1</span>, slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> prev = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (f &lt; arr.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">let</span> begin = f - <span class="hljs-number">1</span>;<br>        prev = arr[begin];<br>        <span class="hljs-keyword">while</span> (f &lt; arr.<span class="hljs-property">length</span> &amp;&amp; arr[f] - prev === <span class="hljs-number">1</span>) &#123;<br>            prev = arr[f];<br>            f++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (f - begin === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (arr[f + <span class="hljs-number">1</span>] - arr[f] !== <span class="hljs-number">1</span>) &#123;<br>                !begin ? arr[slow++] = arr[begin] : arr[slow++] = arr[f];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!begin) arr[slow++] = arr[begin];<br>            &#125;<br>            f++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[slow++] = arr[begin] + <span class="hljs-string">`-`</span> + prev;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, slow).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> res = <span class="hljs-title function_">combine</span>([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">56</span>, <span class="hljs-number">57</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><br></code></pre></td></tr></table></figure><h4 id="11-字符串相加-腾讯"><a href="#11-字符串相加-腾讯" class="headerlink" title="11. 字符串相加 (腾讯)"></a>11. 字符串相加 (腾讯)</h4><p><a href="https://leetcode-cn.com/problems/add-strings/">LeetCode 第 415 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> addStrings = <span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> i = num1.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, j = num2.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> n1 = i &gt;= <span class="hljs-number">0</span> ? num1.<span class="hljs-title function_">charAt</span>(i) - <span class="hljs-number">0</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> n2 = j &gt;= <span class="hljs-number">0</span> ? num2.<span class="hljs-title function_">charAt</span>(j) - <span class="hljs-number">0</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> tmp = n1 + n2 + carry;<br>        carry = <span class="hljs-built_in">parseInt</span>(tmp / <span class="hljs-number">10</span>);<span class="hljs-comment">//算出十位数</span><br>        res.<span class="hljs-title function_">push</span>(tmp % <span class="hljs-number">10</span>);<span class="hljs-comment">//算出个位数</span><br>        i--; j--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) res.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="栈-队列篇"><a href="#栈-队列篇" class="headerlink" title="栈 &#x2F; 队列篇"></a>栈 &#x2F; 队列篇</h3><h4 id="1-实现一个栈，入栈-push、出栈-pop、返回最小值-min-的复杂度为-0-1-滴滴"><a href="#1-实现一个栈，入栈-push、出栈-pop、返回最小值-min-的复杂度为-0-1-滴滴" class="headerlink" title="1. 实现一个栈，入栈 push、出栈 pop、返回最小值 min 的复杂度为 0(1) (滴滴)"></a>1. 实现一个栈，入栈 push、出栈 pop、返回最小值 min 的复杂度为 0(1) (滴滴)</h4><p><a href="https://leetcode-cn.com/problems/min-stack/">LeetCode 第 115 题</a></p><p><strong>思路:</strong> stack2 为存储最小值的数组, 使用同步加同步减的思路, stack1 进来的新元素比 stack2 的 top 元素大则无视, 否则 stack2 顶部的元素变成刚刚进来的小值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MinStack</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span> = []; <br>&#125;;<br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123; <span class="hljs-comment">//同步加同步减push pop</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">push</span>(x);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">push</span>(x);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (x &lt; temp) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">push</span>(x)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">push</span>(temp);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">pop</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">top</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MinStack</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMin</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>&#125;;<br><br><br><br></code></pre></td></tr></table></figure><h4 id="2-使用两个栈实现一个队列-滴滴"><a href="#2-使用两个栈实现一个队列-滴滴" class="headerlink" title="2. 使用两个栈实现一个队列 (滴滴)"></a>2. 使用两个栈实现一个队列 (滴滴)</h4><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 第 9 题</a></p><p><strong>思路:</strong> 我们既然要实现队列, 那肯定就是要有其中一个栈作为辅助栈，用来倒腾另一个栈中的数据 (我们这里的 stack1 为主栈，stack2 为辅助栈);</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">CQueue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span> = [];<span class="hljs-comment">//2 1</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">value</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">CQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">appendTail</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">//如果stack1中有元素那就先把stack1中所有元素放到stack2中</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">pop</span>()); <br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">push</span>(value);<span class="hljs-comment">//添加新的值到stack1中</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack2</span>.<span class="hljs-title function_">pop</span>()); <span class="hljs-comment">//然后再把stack2中的元素放到stack1中</span><br>    &#125;<br>    <span class="hljs-comment">//这几步的意思是让stack1具有队列的性质(先进先出) 因为stack2代表stack1中之前的数据，然后会压到新数据的上面</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">CQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">deleteHead</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack1</span>.<span class="hljs-title function_">pop</span>();<span class="hljs-comment">//使用pop栈的方法，因为咱们利用辅助栈倒腾了一下所以直接pop后结果就是按照队列的性质输出了先进的值</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="3-有效的括号-要求-Tc-O-n-Sc-O-n-哔哩哔哩"><a href="#3-有效的括号-要求-Tc-O-n-Sc-O-n-哔哩哔哩" class="headerlink" title="3. 有效的括号 [要求 Tc: O(n) Sc:O(n)] (哔哩哔哩)"></a>3. 有效的括号 [要求 Tc: O(n) Sc:O(n)] (哔哩哔哩)</h4><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">LeetCode 第 20 题</a></p><p><strong>思路:</strong> 使用栈保存括号，遇到左括号直接入栈，遇到右括号就把栈顶的弹出来和当前的右括号匹配, 如果匹配失败说明不合法直接返回 false, 最后判断栈是不是空 (是不是所有括号都抵消完毕了), 不为空也说明不合法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isValid = <span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> map = &#123;<br>        <span class="hljs-string">&#x27;&#123;&#x27;</span>: <span class="hljs-string">&#x27;&#125;&#x27;</span>,<br>        <span class="hljs-string">&#x27;(&#x27;</span>: <span class="hljs-string">&#x27;)&#x27;</span>,<br>        <span class="hljs-string">&#x27;[&#x27;</span>: <span class="hljs-string">&#x27;]&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> stack = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map[str[i]]) &#123;<br>            stack.<span class="hljs-title function_">push</span>(str[i]);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[i] !== map[stack.<span class="hljs-title function_">pop</span>()]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.<span class="hljs-property">length</span> === <span class="hljs-number">0</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="链表篇"><a href="#链表篇" class="headerlink" title="链表篇"></a>链表篇</h3><h4 id="1-从尾到头打印单链表-要求-Tc-O-n-Sc-O-n"><a href="#1-从尾到头打印单链表-要求-Tc-O-n-Sc-O-n" class="headerlink" title="1. 从尾到头打印单链表 [要求 Tc: O(n) Sc:O(n)]"></a>1. 从尾到头打印单链表 [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 第 6 题</a></p><p><strong>思路:</strong> 基于 stack 的特性 (后进先出), 所以我们从头到尾过一遍链表，最后按照栈的顺序弹出就可以得到结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">let</span> cur = head;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>        stack.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>        cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> print = [];<br>    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>        print.<span class="hljs-title function_">push</span>(stack.<span class="hljs-title function_">pop</span>())<br>    &#125;<br>    <span class="hljs-keyword">return</span> print;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="2-删除链表的倒数第-K-个结点-要求-Tc-O-L-Sc-O-1"><a href="#2-删除链表的倒数第-K-个结点-要求-Tc-O-L-Sc-O-1" class="headerlink" title="2. 删除链表的倒数第 K 个结点 [要求 Tc: O(L) Sc:O(1)]"></a>2. 删除链表的倒数第 K 个结点 [要求 Tc: O(L) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 第 19 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummyNode.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> fast = dummyNode, slow = dummyNode;<br>    <span class="hljs-comment">// 快先走 n+1 步</span><br>    <span class="hljs-keyword">while</span>(n--) &#123;<br>        fast = fast.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-comment">// fast、slow 一起前进</span><br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.<span class="hljs-property">next</span>) &#123;<br>        fast = fast.<span class="hljs-property">next</span><br>        slow = slow.<span class="hljs-property">next</span><br>    &#125;<br>    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span><br>    <span class="hljs-keyword">return</span> dummyNode.<span class="hljs-property">next</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="3-判断单链表是否有环-要求-Tc-O-n-Sc-O-1-有赞"><a href="#3-判断单链表是否有环-要求-Tc-O-n-Sc-O-1-有赞" class="headerlink" title="3. 判断单链表是否有环 [要求 Tc: O(n) Sc:O(1)] (有赞)"></a>3. 判断单链表是否有环 [要求 Tc: O(n) Sc:O(1)] (有赞)</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">LeetCode 第 141 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> slow = fast = head;<br>    <span class="hljs-keyword">while</span> (fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span> (slow === fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="4-反转单链表-要求-Tc-O-n-Sc-O-1-链表类超高频"><a href="#4-反转单链表-要求-Tc-O-n-Sc-O-1-链表类超高频" class="headerlink" title="4. 反转单链表 [要求 Tc: O(n) Sc:O(1)] (链表类超高频)"></a>4. 反转单链表 [要求 Tc: O(n) Sc:O(1)] (链表类超高频)</h4><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 第 24 题</a></p><p><strong>反转思路如下过程:</strong></p><p>原始链表: head -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;- <span class="hljs-number">2</span>    <span class="hljs-number">3</span>  -&gt;  <span class="hljs-number">4</span> -&gt; <span class="hljs-literal">null</span><br><span class="hljs-title function_">pre</span>(<span class="hljs-literal">null</span>)    cur  next<br>        <br><span class="hljs-literal">null</span>  &lt;- <span class="hljs-number">2</span>  &lt;-  <span class="hljs-number">3</span>      <span class="hljs-number">4</span> -&gt; <span class="hljs-literal">null</span><br>        pre    cur   next<br>                <br><span class="hljs-literal">null</span>  &lt;- <span class="hljs-number">2</span>  &lt;-  <span class="hljs-number">3</span>  &lt;-  <span class="hljs-number">4</span>   <span class="hljs-literal">null</span><br>                      cur  next<br>                pre  <br><span class="hljs-literal">null</span>  &lt;- <span class="hljs-number">2</span>  &lt;-  <span class="hljs-number">3</span>  &lt;-  <span class="hljs-number">4</span>    <span class="hljs-literal">null</span><br>                      pre   cur  next<br> &lt;--------------------pre is the newHead to be returned<br><br></code></pre></td></tr></table></figure><p><strong>迭代解法 (从左到右反转):</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>, cur = head;<br>    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">let</span> next = cur.<span class="hljs-property">next</span>;<br>        cur.<span class="hljs-property">next</span> = pre;<br>        pre = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>递归解法:(从右往左反转)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span>(head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">let</span> newHead = <span class="hljs-title function_">reverseList</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>原始链表: 2 -&gt; 3 -&gt; null</p><p>第一次调用 reverseList:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span>  -&gt;  <span class="hljs-number">3</span> -&gt; <span class="hljs-literal">null</span><br>head  newHead<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head 干的事是: (<span class="hljs-number">2</span>的next是<span class="hljs-number">3</span>,将<span class="hljs-number">3</span>的next指向<span class="hljs-number">2</span>)：<br><span class="hljs-number">2</span>  &lt;-&gt;  <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span> 干的事是:<br><span class="hljs-literal">null</span> &lt;- <span class="hljs-number">2</span>  &lt;- <span class="hljs-number">3</span><br>       head<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> newHead 干的事是:<br><span class="hljs-literal">null</span> &lt;- <span class="hljs-number">2</span>  &lt;- <span class="hljs-number">3</span><br>             newHead<br><br></code></pre></td></tr></table></figure><p>第二次调用 reverseList:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2</span>  -&gt;  <span class="hljs-number">3</span> -&gt; <span class="hljs-literal">null</span><br>      head       <br>base <span class="hljs-attr">case</span>: <span class="hljs-keyword">return</span> newHead = <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h4 id="5-判断两个链表是否相交，若相交，求交点-链表没有环-要求-Tc-O-m-n-Sc-O-n-字节跳动"><a href="#5-判断两个链表是否相交，若相交，求交点-链表没有环-要求-Tc-O-m-n-Sc-O-n-字节跳动" class="headerlink" title="5. 判断两个链表是否相交，若相交，求交点 (链表没有环)[要求 Tc: O(m+n) Sc:O(n)] (字节跳动)"></a>5. 判断两个链表是否相交，若相交，求交点 (链表没有环)[要求 Tc: O(m+n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode/">LeetCode 第 160 题</a></p><p>headA:a+c+b<br>headB:b+c+a</p><p>因为 a+c+b &#x3D;&#x3D;&#x3D; b+c+a 因此终有一刻他们能相交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) &#123;<br>    <span class="hljs-keyword">if</span> (headA === <span class="hljs-literal">null</span> || headB === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> nodeA = headA;<br>    <span class="hljs-keyword">let</span> nodeB = headB;<br>    <span class="hljs-keyword">while</span> (nodeA !== nodeB) &#123;<br>        nodeA = nodeA ? nodeA.<span class="hljs-property">next</span> : headB;<br>        nodeB = nodeB ? nodeB.<span class="hljs-property">next</span> : headA;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nodeA;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="6-查找单链表的中间节点，要求只能遍历一次链表-要求-Tc-O-n-Sc-O-1"><a href="#6-查找单链表的中间节点，要求只能遍历一次链表-要求-Tc-O-n-Sc-O-1" class="headerlink" title="6. 查找单链表的中间节点，要求只能遍历一次链表 [要求 Tc: O(n) Sc:O(1)]"></a>6. 查找单链表的中间节点，要求只能遍历一次链表 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">LeetCode 第 876 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> middleNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = head;<br>    <span class="hljs-keyword">let</span> fast = head;<br>    <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="7-合并两个有序链表，合并后依然有序-要求-Tc-O-m-n-Sc-O-1"><a href="#7-合并两个有序链表，合并后依然有序-要求-Tc-O-m-n-Sc-O-1" class="headerlink" title="7. 合并两个有序链表，合并后依然有序 [要求 Tc: O(m+n) Sc:O(1)]"></a>7. 合并两个有序链表，合并后依然有序 [要求 Tc: O(m+n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 第 25 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">let</span> dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> cur1 = l1;<br>    <span class="hljs-keyword">let</span> cur2 = l2;<br>    <span class="hljs-keyword">let</span> tail = dummyHead;<br>    <span class="hljs-keyword">while</span> (cur1 !== <span class="hljs-literal">null</span> &amp;&amp; cur2 !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur1.<span class="hljs-property">val</span> &lt; cur2.<span class="hljs-property">val</span>) &#123;<br>            tail.<span class="hljs-property">next</span> = cur1;<br>            cur1 = cur1.<span class="hljs-property">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.<span class="hljs-property">next</span> = cur2;<br>            cur2 = cur2.<span class="hljs-property">next</span>;<br>        &#125;<br>        tail = tail.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur1 !== <span class="hljs-literal">null</span>) &#123;<br>        tail.<span class="hljs-property">next</span> = cur1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur2 !== <span class="hljs-literal">null</span>) &#123;<br>        tail.<span class="hljs-property">next</span> = cur2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.<span class="hljs-property">next</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="8-查找单链表的倒数第-K-个节点，要求只能遍历一次链表-要求-Tc-O-n-Sc-O-1"><a href="#8-查找单链表的倒数第-K-个节点，要求只能遍历一次链表-要求-Tc-O-n-Sc-O-1" class="headerlink" title="8. 查找单链表的倒数第 K 个节点，要求只能遍历一次链表 [要求 Tc: O(n) Sc:O(1)]"></a>8. 查找单链表的倒数第 K 个节点，要求只能遍历一次链表 [要求 Tc: O(n) Sc:O(1)]</h4><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11/">剑指 Offer 第 22 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> getKthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> fast = head, slow = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        fast = fast.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.<span class="hljs-property">next</span>;<br>        slow = slow.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二叉树篇"><a href="#二叉树篇" class="headerlink" title="二叉树篇"></a>二叉树篇</h3><h4 id="1-二叉树的删除实现-要求-Tc-O-H-Sc-O-H-字节跳动"><a href="#1-二叉树的删除实现-要求-Tc-O-H-Sc-O-H-字节跳动" class="headerlink" title="1. 二叉树的删除实现 [要求 Tc: O(H) Sc:O(H)] (字节跳动)"></a>1. 二叉树的删除实现 [要求 Tc: O(H) Sc:O(H)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">LeetCode 第 450 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, key</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-title function_">recursionDelete</span>(root, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursionDelete</span>(<span class="hljs-params">root, key</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &gt; key) &#123;<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">recursionDelete</span>(root.<span class="hljs-property">left</span>, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &lt; key) &#123;<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">recursionDelete</span>(root.<span class="hljs-property">right</span>, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//3种情况</span><br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//1</span><br>            root === <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//2</span><br>            root = root.<span class="hljs-property">right</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//2</span><br>            root = root.<span class="hljs-property">left</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">let</span> aux = <span class="hljs-literal">null</span>; <span class="hljs-comment">//3</span><br>        <span class="hljs-keyword">let</span> current = root.<span class="hljs-property">right</span>;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">left</span> != <span class="hljs-literal">null</span>) &#123;<br>        current = current.<span class="hljs-property">left</span>;<br>        &#125;<br>        aux = current;<br>        root.<span class="hljs-property">val</span> = aux.<span class="hljs-property">val</span>;<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">recursionDelete</span>(root.<span class="hljs-property">right</span>,aux.<span class="hljs-property">val</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-判断一棵树是否是平衡树-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#2-判断一棵树是否是平衡树-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="2. 判断一棵树是否是平衡树 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>2. 判断一棵树是否是平衡树 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">LeetCode 第 110 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isBalanced = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> lh = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-keyword">const</span> rh = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(lh - rh) &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isBalanced</span>(root.<span class="hljs-property">left</span>) &amp;&amp; <span class="hljs-title function_">isBalanced</span>(root.<span class="hljs-property">right</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="3-二叉树最大深度-要求-Tc-O-n-Sc-O-n-阿里"><a href="#3-二叉树最大深度-要求-Tc-O-n-Sc-O-n-阿里" class="headerlink" title="3. 二叉树最大深度 [要求 Tc: O(n) Sc:O(n)] (阿里)"></a>3. 二叉树最大深度 [要求 Tc: O(n) Sc:O(n)] (阿里)</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 第 55 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="5-二叉树中和为某一值的路径-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#5-二叉树中和为某一值的路径-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="5. 二叉树中和为某一值的路径 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>5. 二叉树中和为某一值的路径 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 第 34 题</a></p><p>第 34 题解:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pathSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, sum</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> [];<br>    <span class="hljs-keyword">const</span> solution = [];<br>    <span class="hljs-keyword">let</span> path = []<br>    <span class="hljs-title function_">pathSumHelper</span>(root,sum,solution,path);<br>    <span class="hljs-keyword">return</span> solution;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pathSumHelper</span>(<span class="hljs-params">root,sum,solution,path</span>) &#123;<br>    path.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span> == <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">right</span> == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">calcPath</span>(path) == sum) &#123;<br>        solution.<span class="hljs-title function_">push</span>([...path]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">left</span>)&#123;<br>        <span class="hljs-title function_">pathSumHelper</span>(root.<span class="hljs-property">left</span>,sum,solution,path);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">right</span>)&#123;<br>        <span class="hljs-title function_">pathSumHelper</span>(root.<span class="hljs-property">right</span>,sum,solution,path);<br>    &#125;<br>    path.<span class="hljs-title function_">pop</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcPath</span>(<span class="hljs-params">path</span>)&#123;<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;path.<span class="hljs-property">length</span>;i++)&#123;<br>        total += path[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="6-LCA-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#6-LCA-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="6.LCA[要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>6.LCA[要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 第 236 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root || root.<span class="hljs-property">val</span> == p.<span class="hljs-property">val</span> || root.<span class="hljs-property">val</span> == q.<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">left</span>, p, q);<br>    <span class="hljs-keyword">let</span> right = <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">right</span>, p, q);<br>    <span class="hljs-comment">//如果left不存在p或q就返回right的结果。如果left存在，right不存在就返回left结果。如果left和right都存在就返回根节点</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="7-二叉树层序遍历-要求-Tc-O-n-Sc-O-n-必会题"><a href="#7-二叉树层序遍历-要求-Tc-O-n-Sc-O-n-必会题" class="headerlink" title="7. 二叉树层序遍历 [要求 Tc: O(n) Sc:O(n)] (必会题)"></a>7. 二叉树层序遍历 [要求 Tc: O(n) Sc:O(n)] (必会题)</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode 第 102 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> queue = [root];<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">const</span> level = [];<br>        <span class="hljs-keyword">let</span> size = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span>) &#123;<br>                queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span>) &#123;<br>                queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>            &#125;<br>            level.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>        &#125;<br>        result.<span class="hljs-title function_">push</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="8-是否是-BST-要求-Tc-O-n-Sc-O-n-有赞"><a href="#8-是否是-BST-要求-Tc-O-n-Sc-O-n-有赞" class="headerlink" title="8. 是否是 BST[要求 Tc: O(n) Sc:O(n)] (有赞)"></a>8. 是否是 BST[要求 Tc: O(n) Sc:O(n)] (有赞)</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">LeetCode 第 98 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> min = -<span class="hljs-title class_">Infinity</span>;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-title class_">Infinity</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isValidBSTHelper</span>(root, min, max);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidBSTHelper</span>(<span class="hljs-params">root, min, max</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span> &lt;= min || root.<span class="hljs-property">val</span> &gt;= max) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isValidBSTHelper</span>(root.<span class="hljs-property">left</span>, min, root.<span class="hljs-property">val</span>) &amp;&amp; <span class="hljs-title function_">isValidBSTHelper</span>(root.<span class="hljs-property">right</span>, root.<span class="hljs-property">val</span>, max);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="9-是否是完全二叉树-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#9-是否是完全二叉树-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="9. 是否是完全二叉树 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>9. 是否是完全二叉树 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">LeetCode 第 958 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isCompleteTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> queue = [root];<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>       <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>       <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span>) &#123;<br>           flag = <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span>) &#123;<br>           flag = <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="10-翻转二叉树-要求-Tc-O-n-Sc-O-n"><a href="#10-翻转二叉树-要求-Tc-O-n-Sc-O-n" class="headerlink" title="10. 翻转二叉树 [要求 Tc: O(n) Sc:O(n)]"></a>10. 翻转二叉树 [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">LeetCode 第 226 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-title function_">invertTreeHelper</span>(root);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">invertTreeHelper</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> tmp = root.<span class="hljs-property">left</span>;<br>    root.<span class="hljs-property">left</span> = root.<span class="hljs-property">right</span>;<br>    root.<span class="hljs-property">right</span> = tmp;<br>    <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);<br>    <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="11-二叉树的右视图-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#11-二叉树的右视图-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="11. 二叉树的右视图 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>11. 二叉树的右视图 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">LeetCode 第 199 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rightSideView = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">let</span> queue = [root];<br>    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">const</span> level = [];<br>        <span class="hljs-keyword">let</span> size = queue.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">let</span> cur = queue.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span> (i === size - <span class="hljs-number">1</span>) &#123;<br>                level.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">left</span>) &#123;<br>                queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">left</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">right</span>) &#123;<br>                queue.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">right</span>);<br>            &#125;<br>        &#125;<br>        result.<span class="hljs-title function_">push</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="12-判断对称二叉树-要求-Tc-O-n-Sc-O-n"><a href="#12-判断对称二叉树-要求-Tc-O-n-Sc-O-n" class="headerlink" title="12. 判断对称二叉树 [要求 Tc: O(n) Sc:O(n)]"></a>12. 判断对称二叉树 [要求 Tc: O(n) Sc:O(n)]</h4><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">LeetCode 第 101 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isSymmetric = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isSymmetricHelper</span>(root, root);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isSymmetricHelper</span>(<span class="hljs-params">one, two</span>) &#123;<br>    <span class="hljs-keyword">if</span> (one === <span class="hljs-literal">null</span> &amp;&amp; two === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (one === <span class="hljs-literal">null</span> || two === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (one.<span class="hljs-property">val</span> !== two.<span class="hljs-property">val</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isSymmetricHelper</span>(one.<span class="hljs-property">left</span>,two.<span class="hljs-property">right</span>) &amp;&amp; <span class="hljs-title function_">isSymmetricHelper</span>(one.<span class="hljs-property">right</span>,two.<span class="hljs-property">left</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="13-二叉树的锯齿形层次遍历-要求-Tc-O-n-Sc-O-n-字节跳动"><a href="#13-二叉树的锯齿形层次遍历-要求-Tc-O-n-Sc-O-n-字节跳动" class="headerlink" title="13. 二叉树的锯齿形层次遍历 [要求 Tc: O(n) Sc:O(n)] (字节跳动)"></a>13. 二叉树的锯齿形层次遍历 [要求 Tc: O(n) Sc:O(n)] (字节跳动)</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 第 103 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>  <span class="hljs-keyword">const</span> printArr = []<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> printArr<br>  <span class="hljs-keyword">const</span> list = []<br>  list.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">level</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">node</span>: root &#125;)<br>  <span class="hljs-keyword">while</span>(list.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; level, node &#125; = list.<span class="hljs-title function_">shift</span>()<br>    <span class="hljs-keyword">if</span> (!printArr[level]) &#123;<br>      printArr[level] = []<br>    &#125;<br>    <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>      printArr[level].<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      printArr[level].<span class="hljs-title function_">unshift</span>(node.<span class="hljs-property">val</span>)<br>    &#125;<br>    node.<span class="hljs-property">left</span> &amp;&amp; list.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">level</span>: level + <span class="hljs-number">1</span>, <span class="hljs-attr">node</span>: node.<span class="hljs-property">left</span> &#125;)<br>    node.<span class="hljs-property">right</span> &amp;&amp; list.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">level</span>: level + <span class="hljs-number">1</span>, <span class="hljs-attr">node</span>: node.<span class="hljs-property">right</span> &#125;)<br>  &#125;<br>  <span class="hljs-keyword">return</span> printArr<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="14-构造二叉树"><a href="#14-构造二叉树" class="headerlink" title="14. 构造二叉树"></a>14. 构造二叉树</h4><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LeetCode 第 106 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">help</span>(<span class="hljs-params">inorder</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!inorder|| !inorder.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">let</span> top = preorder.<span class="hljs-title function_">shift</span>(), p = inorder.<span class="hljs-title function_">indexOf</span>(top);<br>        <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(top);<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">help</span>(inorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, p));<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">help</span>(inorder.<span class="hljs-title function_">slice</span>(p+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">help</span>(inorder);<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 第 105 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">help</span>(<span class="hljs-params">inorder</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!inorder|| !inorder.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">let</span> top = preorder.<span class="hljs-title function_">shift</span>(), p = inorder.<span class="hljs-title function_">indexOf</span>(top);<br>        <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(top);<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">help</span>(inorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, p));<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">help</span>(inorder.<span class="hljs-title function_">slice</span>(p + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">help</span>(inorder);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="堆-优先队列篇"><a href="#堆-优先队列篇" class="headerlink" title="堆 &#x2F; 优先队列篇"></a>堆 &#x2F; 优先队列篇</h3><h4 id="1-寻找第-k-大元素-要求-Tc-O-nlogn-Sc-O-1-腾讯-字节跳动-阿里"><a href="#1-寻找第-k-大元素-要求-Tc-O-nlogn-Sc-O-1-腾讯-字节跳动-阿里" class="headerlink" title="1. 寻找第 k 大元素 [要求 Tc: O(nlogn) Sc:O(1)] (腾讯, 字节跳动, 阿里)"></a>1. 寻找第 k 大元素 [要求 Tc: O(nlogn) Sc:O(1)] (腾讯, 字节跳动, 阿里)</h4><p><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions/266/heap-stack-queue/1154/">常见题型</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><br></code></pre></td></tr></table></figure><h3 id="二分查找篇"><a href="#二分查找篇" class="headerlink" title="二分查找篇"></a>二分查找篇</h3><h4 id="1-查找给定值-要求-Tc-O-logn-Sc-O-1-二分查找高频"><a href="#1-查找给定值-要求-Tc-O-logn-Sc-O-1-二分查找高频" class="headerlink" title="1. 查找给定值 [要求 Tc: O(logn) Sc:O(1)] (二分查找高频)"></a>1. 查找给定值 [要求 Tc: O(logn) Sc:O(1)] (二分查找高频)</h4><p><a href="https://leetcode-cn.com/problems/binary-search/">LeetCode 第 704 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">const</span> mid = (left + (right - left) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> middleValue = array[mid];<br>        <span class="hljs-keyword">if</span> (middleValue &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> index = <span class="hljs-title function_">binarySearch</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 1</span><br><br></code></pre></td></tr></table></figure><h4 id="2-查找最接近目标值的值-要求-Tc-O-logn-Sc-O-1"><a href="#2-查找最接近目标值的值-要求-Tc-O-logn-Sc-O-1" class="headerlink" title="2. 查找最接近目标值的值 [要求 Tc: O(logn) Sc:O(1)]"></a>2. 查找最接近目标值的值 [要求 Tc: O(logn) Sc:O(1)]</h4><p>给定目标整数 T 和按升序排序的整数数组 A，找到 A 中的索引 i，以使 A [i] 最接近 T。</p><p>假设条件:</p><p>数组中可以有重复的元素，并且我们可以返回具有相同值的任何索引。</p><p>例:</p><p>A &#x3D; [1,2,3]，T &#x3D; 2，返回 1</p><p>A &#x3D;[1，4，6]，T &#x3D; 3，返回 1</p><p>A &#x3D; [1，4，6]，T &#x3D; 5，返回 1 或 2</p><p>A &#x3D; [1、3、3、4]，T &#x3D; 2，返回 0 或 1 或 2</p><p>corner case:</p><p>如果 A 为空或 A 为零长度怎么办？在这种情况下，我们应该返回 - 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, target</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> mid = (left + (right - left) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> middleValue = array[mid];<br>        <span class="hljs-keyword">if</span> (middleValue === target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &lt; target) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target - array[left]) &gt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(target - array[right])) &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> index = <span class="hljs-title function_">binarySearch</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 2</span><br><br></code></pre></td></tr></table></figure><h4 id="3-第一个出现的目标值-要求-Tc-O-logn-Sc-O-1-二分查找高频"><a href="#3-第一个出现的目标值-要求-Tc-O-logn-Sc-O-1-二分查找高频" class="headerlink" title="3. 第一个出现的目标值 [要求 Tc: O(logn) Sc:O(1)] (二分查找高频)"></a>3. 第一个出现的目标值 [要求 Tc: O(logn) Sc:O(1)] (二分查找高频)</h4><p>给定目标整数 T 和按升序排序的整数数组 A，请找到 A 中 T 首次出现的索引，如果没有这样的索引，则返回 - 1。</p><p>假设条件</p><p>数组中可以有重复的元素。</p><p>例:</p><p>A &#x3D; [1,2,3]，T &#x3D; 2，返回 1</p><p>A &#x3D; [1,2,3]，T &#x3D; 4，返回 - 1</p><p>A &#x3D; [1,2,2,2,3]，T &#x3D; 2，返回 1</p><p>corner case:</p><p>如果 A 为零或长度为零的 A 怎么办？在这种情况下，我们应该返回 - 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, target</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> mid = (left + (right - left) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> middleValue = array[mid];<br>        <span class="hljs-keyword">if</span> (middleValue === target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array[right] === target ? right : array[left] === target ? left : -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">binarySearch</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-number">2</span>)); <span class="hljs-comment">//1</span><br><br></code></pre></td></tr></table></figure><h4 id="4-查找最接近目标值的-k-个数-要求-Tc-O-logn-k-Sc-O-1"><a href="#4-查找最接近目标值的-k-个数-要求-Tc-O-logn-k-Sc-O-1" class="headerlink" title="4. 查找最接近目标值的 k 个数 [要求 Tc: O(logn + k) Sc:O(1)]"></a>4. 查找最接近目标值的 k 个数 [要求 Tc: O(logn + k) Sc:O(1)]</h4><p>给定目标整数 T，非负整数 K 和按升序排序的整数数组 A，找到 A 中最接近 T 的 K 个数字。 如果存在平局，则始终首选较小的元素。</p><p>假设条件:</p><p>A 不为空 K 保证大于等于 0，K 保证小于等于 A.length 返回大小为 K 的整数数组，其中包含 A 中的 K 个最接近的数字（不是索引），并按数字和 T 之间的差值升序排列。</p><p>例:</p><p>A &#x3D; [1，2，3]，T &#x3D; 2，K &#x3D; 3，返回 [2，1，3] 或[2，3，1]</p><p>A &#x3D; [1，4，6，8]，T &#x3D; 3，K &#x3D; 3，返回 [4，1，6]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">array, target, k</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> mid = (left + (right - left) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> middleValue = array[mid];<br>        <span class="hljs-keyword">if</span> (middleValue === target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (middleValue &lt; target) &#123;<br>            left = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// post-processing find the closest number</span><br>    <span class="hljs-keyword">let</span> closeIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(array[left] - target) &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(array[right] - target)) &#123;<br>    closeIdx = left;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    closeIdx = right;<br>    &#125;<br>    <span class="hljs-comment">// These two should be the closest to target</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(k);<br>    <span class="hljs-keyword">let</span> l = closeIdx;<br>    <span class="hljs-keyword">let</span> r = closeIdx + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// this is a typical merge operation</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>    <span class="hljs-comment">// we can advance the left pointer when:</span><br>    <span class="hljs-comment">// 1. right pointer is already out of bound</span><br>    <span class="hljs-comment">// 2. right pointer is not out of bound, left pointer is not out of bound and array[left] is closer to target.</span><br>    <span class="hljs-keyword">if</span> (r &gt;= array.<span class="hljs-property">length</span>) &#123;<span class="hljs-comment">//can be merged two conditions</span><br>            result[i] = array[l--];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;<br>            result[i] = array[r++];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(array[l] - target) &lt;= <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(array[r] - target)) &#123;<br>            result[i] = array[l--];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[i] = array[r++];<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">binarySearch</span>([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>], <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// [4，1，6]</span><br><br></code></pre></td></tr></table></figure><h4 id="5-有一个排序数组，返回第一个比目标数字小的数-要求-Tc-O-logn-Sc-O-1-快手"><a href="#5-有一个排序数组，返回第一个比目标数字小的数-要求-Tc-O-logn-Sc-O-1-快手" class="headerlink" title="5. 有一个排序数组，返回第一个比目标数字小的数 (要求: Tc: O(logn) Sc:O(1)) (快手)"></a>5. 有一个排序数组，返回第一个比目标数字小的数 (要求: Tc: O(logn) Sc:O(1)) (快手)</h4><h3 id="动态规划篇"><a href="#动态规划篇" class="headerlink" title="动态规划篇"></a>动态规划篇</h3><h4 id="1-斐波那契数列-要求-Tc-O-n-Sc-O-n-O-1-动态规划类超高频"><a href="#1-斐波那契数列-要求-Tc-O-n-Sc-O-n-O-1-动态规划类超高频" class="headerlink" title="1. 斐波那契数列 (要求 Tc: O(n) Sc:O(n)&#x2F;O(1)) (动态规划类超高频)"></a>1. 斐波那契数列 (要求 Tc: O(n) Sc:O(n)&#x2F;O(1)) (动态规划类超高频)</h4><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/">LeetCode 第 704 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fib = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, sum;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum = a + b;<br>        a = b;<br>        b = sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="2-爬楼梯-要求-Tc-O-n-Sc-O-n-O-1-动态规划类超高频"><a href="#2-爬楼梯-要求-Tc-O-n-Sc-O-n-O-1-动态规划类超高频" class="headerlink" title="2. 爬楼梯 (要求 Tc: O(n) Sc:O(n)&#x2F;O(1)) (动态规划类超高频)"></a>2. 爬楼梯 (要求 Tc: O(n) Sc:O(n)&#x2F;O(1)) (动态规划类超高频)</h4><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode 第 70 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> climbStairs = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> dp = [];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="递归篇"><a href="#递归篇" class="headerlink" title="递归篇"></a>递归篇</h3><h4 id="1-岛屿数量-要求-Tc-O-MN-Sc-O-MN-微信"><a href="#1-岛屿数量-要求-Tc-O-MN-Sc-O-MN-微信" class="headerlink" title="1. 岛屿数量 (要求 Tc: O(MN) Sc:O(MN)) (微信)"></a>1. 岛屿数量 (要求 Tc: O(MN) Sc:O(MN)) (微信)</h4><p><a href="https://leetcode-cn.com/problems/number-of-islands/">LeetCode 第 200 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> dfs = <span class="hljs-keyword">function</span> (<span class="hljs-params">grid, i, j</span>) &#123;<br>  <span class="hljs-comment">// 把当前项变为0, 防止重新查找</span><br>  grid[i][j] = <span class="hljs-number">0</span>;     <br>  <span class="hljs-comment">// 当前项 上下左右检查</span><br>  <span class="hljs-keyword">if</span> (grid[i - <span class="hljs-number">1</span>] &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-title function_">dfs</span>(grid, i - <span class="hljs-number">1</span>, j);  <span class="hljs-comment">// 上</span><br>  <span class="hljs-keyword">if</span> (grid[i + <span class="hljs-number">1</span>] &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-title function_">dfs</span>(grid, i + <span class="hljs-number">1</span>, j);  <span class="hljs-comment">// 下</span><br>  <span class="hljs-keyword">if</span> (grid[i][j - <span class="hljs-number">1</span>] &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-title function_">dfs</span>(grid, i, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 左</span><br>  <span class="hljs-keyword">if</span> (grid[i][j + <span class="hljs-number">1</span>] &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-title function_">dfs</span>(grid, i, j + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-keyword">var</span> numIslands = <span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) &#123;<br>  <span class="hljs-keyword">if</span> (grid.<span class="hljs-property">length</span> &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> islands = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>        islands++;             <span class="hljs-comment">// 岛屿加1</span><br>        <span class="hljs-title function_">dfs</span>(grid, i, j);       <span class="hljs-comment">// 寻找与当前项相邻的 1 并把它们变成0</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> islands;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="2-从一个数组中找出-N-个数，其和为-M-的所有可能-不能重复使用已经使用过的元素-今日头条"><a href="#2-从一个数组中找出-N-个数，其和为-M-的所有可能-不能重复使用已经使用过的元素-今日头条" class="headerlink" title="2. 从一个数组中找出 N 个数，其和为 M 的所有可能 (不能重复使用已经使用过的元素) (今日头条)"></a>2. 从一个数组中找出 N 个数，其和为 M 的所有可能 (不能重复使用已经使用过的元素) (今日头条)</h4><p><a href="https://blog.csdn.net/weixin_34130269/article/details/91382220">参考题解 1</a></p><p><a href="https://juejin.im/post/5e46425f51882549652d4580#heading-8">参考题解 2</a></p><h4 id="3-子集-要求-Tc-O-N×2N-Sc-O-N×2N-腾讯"><a href="#3-子集-要求-Tc-O-N×2N-Sc-O-N×2N-腾讯" class="headerlink" title="3. 子集 (要求 Tc: O(N×2N) Sc:O(N×2N)) (腾讯)"></a>3. 子集 (要求 Tc: O(N×2N) Sc:O(N×2N)) (腾讯)</h4><p><a href="https://leetcode-cn.com/problems/subsets/">LeetCode 第 78 题</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> subsets = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!nums.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-keyword">let</span> solution = [];<br>    <span class="hljs-keyword">let</span> levelResult = [];<br>    <span class="hljs-title function_">subsetsHelper</span>(nums,<span class="hljs-number">0</span>,levelResult,solution);<br>    <span class="hljs-keyword">return</span> solution;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">subsetsHelper</span>(<span class="hljs-params">nums,level,lresult,solution</span>) &#123;<br>    <span class="hljs-comment">//base base</span><br>    <span class="hljs-keyword">if</span> (level === nums.<span class="hljs-property">length</span>) &#123;<br>        solution.<span class="hljs-title function_">push</span>([].<span class="hljs-title function_">concat</span>(lresult));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    lresult.<span class="hljs-title function_">push</span>(nums[level]);<br>    <span class="hljs-title function_">subsetsHelper</span>(nums, level + <span class="hljs-number">1</span>,lresult, solution);<span class="hljs-comment">//回溯</span><br>    lresult.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-title function_">subsetsHelper</span>(nums, level + <span class="hljs-number">1</span>, lresult, solution);<span class="hljs-comment">//回溯</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-扁平化对象-虾皮"><a href="#5-扁平化对象-虾皮" class="headerlink" title="5. 扁平化对象 (虾皮)"></a>5. 扁平化对象 (虾皮)</h4><blockquote><p>输入:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;a&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;b&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;c&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-number">1</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;aa&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&quot;c&quot;</span>: [<br>    <span class="hljs-number">1</span>,<br>  ]<br>&#125; <br><br></code></pre></td></tr></table></figure><blockquote><p>要求输出:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-string">&#x27;a.b.c.d&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">aa</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c[0]&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c[1]&#x27;</span>: <span class="hljs-number">2</span> &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>, res = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">inner</span> = (<span class="hljs-params">obj</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br>    keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> type = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj[item]).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Object&#x27;</span>) &#123;<br>        str += item + <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-title function_">inner</span>(obj[item], str, res);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;Array&#x27;</span>) &#123;<br>        obj[item].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">items, index</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> key = <span class="hljs-string">`<span class="hljs-subst">$&#123;item&#125;</span>[<span class="hljs-subst">$&#123;index&#125;</span>]`</span>;<br>          res[key] = items;<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        str += item;<br>        res[str] = obj[item];<br>        str = <span class="hljs-string">&#x27;&#x27;</span>;<br>      &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">inner</span>(obj);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">convert</span>(obj));<br><br></code></pre></td></tr></table></figure><h4 id="6-归类-天猫"><a href="#6-归类-天猫" class="headerlink" title="6. 归类 (天猫)"></a>6. 归类 (天猫)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs js">输入:<br><br><span class="hljs-keyword">const</span> industry_list = [<br>  &#123;<br>    <span class="hljs-string">&quot;parent_ind&quot;</span>: <span class="hljs-string">&quot;女装&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;连衣裙&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;女装&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;parent_ind&quot;</span>: <span class="hljs-string">&quot;女装&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;半身裙&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;parent_ind&quot;</span>: <span class="hljs-string">&quot;女装&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;A字裙&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;数码&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;parent_ind&quot;</span>: <span class="hljs-string">&quot;数码&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;电脑配件&quot;</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;parent_ind&quot;</span>: <span class="hljs-string">&quot;电脑配件&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;内存&quot;</span><br>  &#125;,<br>];<br>&gt; 输出:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  &quot;数码&quot;: &#123;</span><br><span class="hljs-comment">    &quot;电脑配件&quot;: &#123;</span><br><span class="hljs-comment">        &quot;内存&quot; : &#123;&#125;</span><br><span class="hljs-comment">     &#125;</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  &quot;女装&quot; : &#123;</span><br><span class="hljs-comment">     &quot;连衣裙&quot;: &#123;&#125;,</span><br><span class="hljs-comment">    &quot;半身裙&quot;: &#123;&#125;,</span><br><span class="hljs-comment">    &quot;A字裙&quot;: &#123;&#125;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert_format</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">const</span> res = &#123;&#125;;<br>  <span class="hljs-keyword">const</span> map = data.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">res, v</span>) =&gt;</span> (res[v.<span class="hljs-property">name</span>] = v, res), &#123;&#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>    <span class="hljs-keyword">if</span> (!item.<span class="hljs-property">parent_ind</span>) &#123;<br>      res[item.<span class="hljs-property">name</span>] = &#123;&#125;;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> data) &#123;<br>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">parent_ind</span> <span class="hljs-keyword">in</span> map) &#123;<br>      <span class="hljs-keyword">if</span> (map[item.<span class="hljs-property">parent_ind</span>].<span class="hljs-property">parent_ind</span>) &#123;<br>        <span class="hljs-keyword">const</span> path = <span class="hljs-title function_">dfs</span>(item.<span class="hljs-property">name</span>);<br>        <span class="hljs-keyword">let</span> re = res[path[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; path.<span class="hljs-property">length</span>; i++) &#123;<br>          <span class="hljs-keyword">if</span> (i === path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;<br>            re[path[i]] = &#123;&#125;;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            re = re[path[i]];<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        res[item.<span class="hljs-property">parent_ind</span>][item.<span class="hljs-property">name</span>] = &#123;&#125;;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">let</span> path = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">inner</span> = (<span class="hljs-params">name, path</span>) =&gt; &#123;<br>      path.<span class="hljs-title function_">unshift</span>(name);<br>      <span class="hljs-keyword">if</span> (!map[name].<span class="hljs-property">parent_ind</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-title function_">inner</span>(map[name].<span class="hljs-property">parent_ind</span>, path);<br>    &#125;;<br>    <span class="hljs-title function_">inner</span>(name, path);<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">convert_format</span>(industry_list);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br><br></code></pre></td></tr></table></figure><h3 id="排序篇"><a href="#排序篇" class="headerlink" title="排序篇"></a>排序篇</h3><h4 id="1-快速排序-要求-Tc-O-nlogn-Sc-O-nlogn-排序类超高频"><a href="#1-快速排序-要求-Tc-O-nlogn-Sc-O-nlogn-排序类超高频" class="headerlink" title="1. 快速排序 (要求 Tc: O(nlogn) Sc:O(nlogn)) (排序类超高频)"></a>1. 快速排序 (要求 Tc: O(nlogn) Sc:O(nlogn)) (排序类超高频)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array === <span class="hljs-literal">null</span> || array.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-title function_">doQuickSort</span>(array, <span class="hljs-number">0</span>, array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doQuickSort</span>(<span class="hljs-params">array,left,right</span>) &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> pivotPos = <span class="hljs-title function_">partition</span>(array,left,right);<br>    <span class="hljs-title function_">doQuickSort</span>(array,left, pivotPos - <span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">doQuickSort</span>(array,pivotPos + <span class="hljs-number">1</span>, right);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">array,left,right</span>) &#123;<br>        <span class="hljs-keyword">let</span> pivotIdx = (left + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (right - left + <span class="hljs-number">1</span>)) | <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> pivot = array[pivotIdx];<br><span class="hljs-comment">// swap pivot 元素到最右边的位置</span><br><span class="hljs-title function_">swap</span>(array, right, pivotIdx);<br><br><span class="hljs-keyword">let</span> leftBound = left;<br><span class="hljs-keyword">let</span> rightBound = right - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (leftBound &lt;= rightBound) &#123;<br>        <span class="hljs-comment">// [0,leftBound),(rightBound,right-1]是已探索区域，[leftBound+1,rightBound-1]是未探索区域。</span><br>        <span class="hljs-comment">// 当 leftBound == rightBound时, 索引不需要检查了</span><br>        <span class="hljs-keyword">if</span> (array[leftBound] &lt; pivot) &#123;<br>        leftBound++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (array[rightBound] &gt;= pivot) &#123;<br>        rightBound--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">swap</span>(array, leftBound, rightBound);<br>        leftBound++;<br>        rightBound--;<br>        &#125;<br>&#125; <span class="hljs-comment">// leftBound == rightBound + 1</span><br><span class="hljs-comment">// swap 回 pivot元素到中间的位置</span><br><span class="hljs-title function_">swap</span>(array, leftBound, right);<br><span class="hljs-keyword">return</span> leftBound;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">array, i, j</span>) &#123;<br>    <span class="hljs-keyword">let</span> tmp = array[i];<br>    array[i] = array[j];<br>    array[j] = tmp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="2-归并排序-要求-Tc-O-nlogn-Sc-O-n"><a href="#2-归并排序-要求-Tc-O-nlogn-Sc-O-n" class="headerlink" title="2. 归并排序 (要求 Tc: O(nlogn) Sc:O(n))"></a>2. 归并排序 (要求 Tc: O(nlogn) Sc:O(n))</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">if</span> (array.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> length = array.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(length / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid));<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">mergeSort</span>(array.<span class="hljs-title function_">slice</span>(mid,length));<br>        array = <span class="hljs-title function_">merge</span>(left,right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left,right</span>) &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-property">length</span> &amp;&amp; j &lt; right.<span class="hljs-property">length</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(left[i] &gt; right[j] ? left[i++] : right[j++]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">concat</span>(i &lt; left.<span class="hljs-property">length</span> ? left.<span class="hljs-title function_">slice</span>(i) : right.<span class="hljs-title function_">slice</span>(j));<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-插入排序-要求-Tc-O-n²-Sc-O-1"><a href="#3-插入排序-要求-Tc-O-n²-Sc-O-1" class="headerlink" title="3. 插入排序 (要求 Tc: O(n²) Sc:O(1))"></a>3. 插入排序 (要求 Tc: O(n²) Sc:O(1))</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> j = i;<br>        temp = array[i];<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; array[j - <span class="hljs-number">1</span>] &gt; temp) &#123;<br>            array[j] = array[j - <span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        array[j] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sort-an-array/">LeetCode 第 912 题</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上题目均为精选高频题，希望对大家有帮助.</p><p> 原文地址 <a href="https://juejin.im/post/5e9d4eaa51882573834edfb5">https://juejin.im/post/5e9d4eaa51882573834edfb5</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>tree-shaking</title>
    <link href="/2020/05/03/tree-shaking/"/>
    <url>/2020/05/03/tree-shaking/</url>
    
    <content type="html"><![CDATA[<p><em>tree shaking</em> 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码 (dead-code)。它依赖于 ES2015 模块语法的 <a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构</a> 特性，例如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export"><code>export</code></a>。这个术语和概念实际上是由 ES2015 模块打包工具 <a href="https://github.com/rollup/rollup">rollup</a> 普及起来的。</p><span id="more"></span><p>webpack 2 正式版本内置支持 ES2015 模块（也叫做 _harmony modules_）和未使用模块检测能力。新的 webpack 4 正式版本扩展了此检测能力，通过 <code>package.json</code> 的 <code>&quot;sideEffects&quot;</code> 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 “pure(纯的 ES2015 模块)”，由此可以安全地删除文件中未使用的部分。</p><blockquote><p>本指南的继承自 <a href="https://webpack.docschina.org/guides/getting-started">起步</a> 指南。如果你尚未阅读该指南，请先行阅读。</p></blockquote><p>在我们的项目中添加一个新的通用模块文件 <code>src/math.js</code>，并导出两个函数：</p><p><strong>project</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 1c">webpack<span class="hljs-punctuation">-</span>demo<br><span class="hljs-string">|- package.json</span><br><span class="hljs-string">|- webpack.config.js</span><br><span class="hljs-string">|- /dist</span><br>  <span class="hljs-string">|- bundle.js</span><br>  <span class="hljs-string">|- index.html</span><br><span class="hljs-string">|- /src</span><br>  <span class="hljs-string">|- index.js</span><br><span class="hljs-punctuation">+</span> <span class="hljs-string">|- math.js</span><br><span class="hljs-string">|- /node_modules</span><br></code></pre></td></tr></table></figure><p><strong>src&#x2F;math.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x * x * x;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <code>mode</code> 配置选项设置为 <a href="https://webpack.docschina.org/concepts/mode/#mode-development">development</a> 以确保 bundle 是未压缩版本：</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>- &#125;<br>+ &#125;,<br>+ <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>+ <span class="hljs-attr">optimization</span>: &#123;<br>+   <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span><br>+ &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>配置完这些后，更新入口脚本，使用其中一个新方法，并且为了简化示例，我们先将 <code>lodash</code> 删除：</p><p><strong>src&#x2F;index.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">- <span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br>+ <span class="hljs-keyword">import</span> &#123; cube &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;<br>-   <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>+   <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;pre&#x27;</span>);<br><br>-   <span class="hljs-comment">// lodash 是由当前 script 脚本 import 进来的</span><br>-   element.<span class="hljs-property">innerHTML</span> = _.<span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;webpack&#x27;</span>], <span class="hljs-string">&#x27; &#x27;</span>);<br>+   element.<span class="hljs-property">innerHTML</span> = [<br>+     <span class="hljs-string">&#x27;Hello webpack!&#x27;</span>,<br>+     <span class="hljs-string">&#x27;5 cubed is equal to &#x27;</span> + <span class="hljs-title function_">cube</span>(<span class="hljs-number">5</span>)<br>+   ].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n\n&#x27;</span>);<br><br>    <span class="hljs-keyword">return</span> element;<br>  &#125;<br><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());<br></code></pre></td></tr></table></figure><p>注意，我们<strong>没有从 <code>src/math.js</code> 模块中 <code>import</code> 另外一个 <code>square</code> 方法</strong>。这个函数就是所谓的 “未引用代码 (dead code)”，也就是说，应该删除掉未被引用的 <code>export</code>。现在运行 npm script <code>npm run build</code>，并查看输出的 bundle：</p><p><strong>dist&#x2F;bundle.js (around lines 90 - 100)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, __webpack_exports__, __webpack_require__</span>) &#123;<br>  <span class="hljs-string">&#x27;use strict&#x27;</span>;<br>  <br>   __webpack_exports__[<span class="hljs-string">&#x27;a&#x27;</span>] = cube;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x * x;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意，上面的 <code>unused harmony export square</code> 注释。如果你观察它下面的代码，你会注意到虽然我们没有引用 <code>square</code>，但它仍然被包含在 bundle 中。我们将在下一节解决这个问题。</p><p>在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有 side effect。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 webpack compiler 哪些代码是 “纯粹部分”。</p><p>通过 package.json 的 <code>&quot;sideEffects&quot;</code> 属性，来实现这种方式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果所有代码都不包含 side effect，我们就可以简单地将该属性标记为 <code>false</code>，来告知 webpack，它可以安全地删除未用到的 export。</p><blockquote><p>“side effect(副作用)” 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。</p></blockquote><p>如果你的代码确实有一些副作用，可以改为提供一个数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;./src/some-side-effectful-file.js&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>数组方式支持相对路径、绝对路径和 glob 模式匹配相关文件。它在内部使用 <a href="https://github.com/micromatch/micromatch#matching-features">micromatch</a>。</p><blockquote><p>注意，所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 <code>css-loader</code> 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;./src/some-side-effectful-file.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.css&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>最后，还可以在 <a href="https://webpack.docschina.org/configuration/module/#module-rules"><code>module.rules</code> 配置选项</a> 中设置 <code>&quot;sideEffects&quot;</code>。</p><p>通过 <code>import</code> 和 <code>export</code> 语法，我们已经找出需要删除的 “未引用代码 (dead code)”，然而，不仅仅是要找出，还要在 bundle 中删除它们。为此，我们需要将 <code>mode</code> 配置选项设置为 <a href="https://webpack.docschina.org/concepts/mode/#mode-production"><code>production</code></a>。</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;,<br>- <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>- <span class="hljs-attr">optimization</span>: &#123;<br>-   <span class="hljs-attr">usedExports</span>: <span class="hljs-literal">true</span><br>- &#125;<br>+ <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意，也可以在命令行接口中使用 <code>--optimize-minimize</code> 标记，来启用 <code>TerserPlugin</code>。</p></blockquote><p>准备就绪后，然后运行另一个 npm script <code>npm run build</code>，看看输出结果是否发生改变。</p><p>你发现 <code>dist/bundle.js</code> 中的差异了吗？显然，现在整个 bundle 都已经被 minify(压缩) 和 mangle(混淆破坏)，但是如果仔细观察，则不会看到引入 <code>square</code> 函数，但能看到 <code>cube</code> 函数的混淆破坏版本（<code>function r(e)&#123;return e*e*e&#125;n.a=r</code>）。现在，随着 minification(代码压缩) 和 tree shaking，我们的 bundle 减小几个字节！虽然，在这个特定示例中，可能看起来没有减少很多，但是，在有着复杂依赖树的大型应用程序上运行 tree shaking 时，会对 bundle 产生显著的体积优化。</p><blockquote><p>运行 tree shaking 需要 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a>。通过 <code>mode: &quot;production&quot;</code> 可以添加此插件。如果你没有使用 mode 设置，记得手动添加 <a href="https://webpack.docschina.org/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a>。</p></blockquote><p>我们已经知道，想要使用 <em>tree shaking</em> 必须注意以下……</p><ul><li>使用 ES2015 模块语法（即 <code>import</code> 和 <code>export</code>）。</li><li>确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel&#x2F;preset-env 的默认行为 - 更多详细信息请查看 <a href="https://babel.docschina.org/docs/en/babel-preset-env#modules">文档</a>）。</li><li>在项目 <code>package.json</code> 文件中，添加一个 “sideEffects” 属性。</li><li>通过将 <code>mode</code> 选项设置为 <a href="https://webpack.docschina.org/concepts/mode/#mode-production"><code>production</code></a>，启用 minification(代码压缩) 和 tree shaking。</li></ul><p>你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p><p>如果你对优化输出很感兴趣，请进入到下个指南，来了解 <a href="https://webpack.docschina.org/guides/production">生产环境</a> 构建的详细细节。</p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js柯里化</title>
    <link href="/2020/05/01/js%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2020/05/01/js%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在各种算法题以及技术文档中经常会看到柯里化这个词，那么，柯里化到底是什么？它在 js 中如何运用？对我们的编程有什么作用？都 9102 年了，如果你还不知道这些，那么你在面试过程中很可能会被面试官 diss🙄</p><span id="more"></span><hr><h3 id="什么是柯里化（Currying）"><a href="#什么是柯里化（Currying）" class="headerlink" title="什么是柯里化（Currying）"></a>什么是柯里化（Currying）</h3><p><em>维基百科</em>的<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596">解释</a>是：把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并返回接受剩余的参数而且返回结果的新函数的技术。其由数学家 Haskell Brooks Curry 提出，并以 curry 命名。</p><p>简单的说，柯里化函数持续地返回一个新函数直到所有的参数用尽为止。这些参数全部保持 “活着” 的状态（通过闭包），然后当柯里化链中的最后一个函数被返回和执行时会全部被用来执行。</p><p>这和<a href="https://links.jianshu.com/go?to=https://react.docschina.org/docs/higher-order-components.html">高阶组件</a>（Higher-order functions）如出一辙。前者返回一个新函数，后者返回一个新组件。</p><h3 id="举个简单的栗子"><a href="#举个简单的栗子" class="headerlink" title="举个简单的栗子"></a>举个简单的栗子</h3><p>本例使用到的部分 ES6 知识：<a href="https://links.jianshu.com/go?to=http://es6.ruanyifeng.com/%23docs/let">const</a>，<a href="https://links.jianshu.com/go?to=http://es6.ruanyifeng.com/%23docs/function">arrow function</a>。不了解的同学可先行查看。<br>写一个计算三个参数相乘的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span> (<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a * b * c<br>&#125;<br><span class="hljs-title function_">multiply</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>这是我们第一反应写出来的 demo，也是看起来最简单的实现方法。再来创建一个柯里化版本的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span> (<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> a * b * c<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-title function_">multiply</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>这里我们将 multiply(1，2，3) 调用变成了 multiply (1) (2) (3) 调用。<br>单独一个函数被转换成了一系列函数。为了得到数字 1、2、3 相乘的结果，这些数字被一个接一个地传递，每个数字预填了下一个函数内联调用。</p><p>我们把 multiply (1) (2) (3) 分割一下来帮助理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mul1 = <span class="hljs-title function_">multiply</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> mul2 = <span class="hljs-title function_">mul1</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">mul2</span>(<span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><p>当 mul2 使用 3 作为参数调用时，它一起使用了之前已拿到的参数 a&#x3D;1 和 b&#x3D;2 进行运算并返回结果 6。</p><p>作为一个嵌套函数，mul2 能够访问到外部的两个函数 multiply 和 mul1 的作用域。这就是为什么 mul2 能利用定义在已经‘离场’的函数中的参数来进行乘法操作的原因。即使这些函数早已返回并且从内存中垃圾回收了，但其变量仍然保持‘活着’(<a href="https://links.jianshu.com/go?to=https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000">闭包</a>)。你可以看到 3 个数字每次只有 1 个提供给函数，并且同一时间里一个新函数会被返回，直到所有的数字用尽为止。</p><p><strong>柯里化背后的逻辑就是获取一个函数并派生出一个返回特殊函数的函数</strong>，它实际上是一种思想，或者说是一种程序设计模式。</p><h3 id="柯里化的应用"><a href="#柯里化的应用" class="headerlink" title="柯里化的应用"></a>柯里化的应用</h3><h4 id="1-编写可以轻松复用和配置的小代码块，就像我们使用-npm-一样："><a href="#1-编写可以轻松复用和配置的小代码块，就像我们使用-npm-一样：" class="headerlink" title="1. 编写可以轻松复用和配置的小代码块，就像我们使用 npm 一样："></a>1. 编写可以轻松复用和配置的小代码块，就像我们使用 npm 一样：</h4><p>举个例子，你有一家商店，然后你想给你的优惠顾客 10% 的折扣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">discount</span> (<span class="hljs-params">price, discount</span>) &#123;<br>  <span class="hljs-keyword">return</span> price * discount<br>&#125;<br><br><span class="hljs-keyword">const</span> price = <span class="hljs-title function_">discount</span>(<span class="hljs-number">500</span>, <span class="hljs-number">0.1</span>) <br><br><br><span class="hljs-keyword">const</span> price = <span class="hljs-title function_">discount</span>(<span class="hljs-number">1500</span>, <span class="hljs-number">0.1</span>) <br><span class="hljs-keyword">const</span> price = <span class="hljs-title function_">discount</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">0.1</span>) <br><span class="hljs-keyword">const</span> price = <span class="hljs-title function_">discount</span>(<span class="hljs-number">50</span>, <span class="hljs-number">0.1</span>) <br><span class="hljs-keyword">const</span> price = <span class="hljs-title function_">discount</span>(<span class="hljs-number">300</span>, <span class="hljs-number">0.1</span>) <br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">discount</span> (<span class="hljs-params">discount</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">price</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> price * discount<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> tenPercentDiscount = <span class="hljs-title function_">discount</span>(<span class="hljs-number">0.1</span>)<br><br><br><span class="hljs-title function_">tenPercentDiscount</span>(<span class="hljs-number">500</span>) <br><br><br><span class="hljs-keyword">const</span> twentyPercentDiscount = <span class="hljs-title function_">discount</span>(<span class="hljs-number">0.2</span>)<br><br><br><span class="hljs-title function_">twentyPercentDiscount</span>(<span class="hljs-number">500</span>) <br><span class="hljs-title function_">twentyPercentDiscount</span>(<span class="hljs-number">3000</span>) <br><span class="hljs-title function_">twentyPercentDiscount</span>(<span class="hljs-number">80000</span>)<br></code></pre></td></tr></table></figure><p>这个例子说明，使用柯里化思想能让我们在遇到只能确定一个参数而无法确定另一个参数时，代码设计编的变得更方便与高效，达到提升性能的目的。</p><h4 id="2-避免频繁调用具有相同参数的函数："><a href="#2-避免频繁调用具有相同参数的函数：" class="headerlink" title="2. 避免频繁调用具有相同参数的函数："></a>2. 避免频繁调用具有相同参数的函数：</h4><p>比如我们有个用来计算体积的函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">volume</span> (<span class="hljs-params">l, w, h</span>) &#123;<br>  <span class="hljs-keyword">return</span> l * w * h<br>&#125;<br><br><br><span class="hljs-title function_">volume</span>(<span class="hljs-number">200</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>) <br><span class="hljs-title function_">volume</span>(<span class="hljs-number">32</span>, <span class="hljs-number">45</span>, <span class="hljs-number">100</span>) <br><span class="hljs-title function_">volume</span>(<span class="hljs-number">2322</span>, <span class="hljs-number">232</span>, <span class="hljs-number">100</span>) <br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">volume</span> (<span class="hljs-params">h</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">w</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">l</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> l * w * h<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> hCylinderHeight = <span class="hljs-title function_">volume</span>(<span class="hljs-number">100</span>)<br><span class="hljs-title function_">hCylinderHeight</span>(<span class="hljs-number">200</span>)(<span class="hljs-number">30</span>) <br><span class="hljs-title function_">hCylinderHeight</span>(<span class="hljs-number">2322</span>)(<span class="hljs-number">232</span>)<br></code></pre></td></tr></table></figure><h3 id="通用的柯里函数"><a href="#通用的柯里函数" class="headerlink" title="通用的柯里函数"></a>通用的柯里函数</h3><p>让我们建立一个函数来接受任何函数并且返回柯里化版本的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span> (<span class="hljs-params">fn, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args, ..._args)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在这里做了什么？我们的 curry 函数接受一个我们想要柯里化的函数（fn）和一个变量（…args）。这里的 rest 操作符用来将参数聚集成一个…args。接下来我们返回一个函数，该函数将其余参数收集为…<em>args。此函数通过 spread 运算符将… args 和…</em> args 作为参数解构传入来调用原始函数 fn，然后将值返回给用户。</p><p>让我们使用我们的 curry 函数用之前的例子来创建一个特殊的函数（一个专门用来计算 100m 长度的物品体积）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">volume</span> (<span class="hljs-params">l, h, w</span>) &#123;<br>  <span class="hljs-keyword">return</span> l * h * w<br>&#125;<br><span class="hljs-keyword">const</span> hCy = <span class="hljs-title function_">curry</span>(volume, <span class="hljs-number">100</span>)<br><span class="hljs-title function_">hCy</span>(<span class="hljs-number">200</span>, <span class="hljs-number">900</span>) <br><span class="hljs-title function_">hCy</span>(<span class="hljs-number">70</span>, <span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>将类似回调函数的参数传入柯里化函数，能使复杂的问题变得简单！</p><h3 id="使用递归实现-curry-函数"><a href="#使用递归实现-curry-函数" class="headerlink" title="使用递归实现 curry 函数"></a>使用递归实现 curry 函数</h3><p>JS 柯里化作为函数式编程的重要一环，频繁在算法题中出现。以上的通用柯里化函数还不够完善，我们希望只给 curry 函数传递一个 fn 就能达到目的，现在我们使用递归来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span> (<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">c</span> = (<span class="hljs-params">...args</span>) =&gt; (args.<span class="hljs-property">length</span> === fn.<span class="hljs-property">length</span>) ?<br>          <span class="hljs-title function_">fn</span>(...args) : <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> <span class="hljs-title function_">c</span>(...args, ..._args)<br>  <span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法几乎为最简洁、代码行数最少的实现方法了。<br>首先我们能确定，实现柯里化的核心就是要确定传入参数的个数，并通通取到。<br>其次，我们得知道，<code>fn.length</code>为 fn 函数接受的参数个数，那么该实现方法就能解读为：<br><strong>不断递归获取传入参数，直到取到的参数个数等于 fn 的参数个数为止，最终将获取到的所有参数传给 fn 并返回执行结果</strong>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>柯里化作为一种重要的程序思想，已经广为应用，它使我们应对复杂问题时能提升效率，增强可读性。希望读者都能体会这种思想并运用于实践，相信在提升技术的路上能越走越远，成为一名优秀的工程师！</p><p><a href="https://www.jianshu.com/p/7fa99a4bee8b">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack中module,chunk和bundle的区别是什么</title>
    <link href="/2020/04/30/webpack%E4%B8%ADmodule-chunk%E5%92%8Cbundle%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2020/04/30/webpack%E4%B8%ADmodule-chunk%E5%92%8Cbundle%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>首先我们在 src 目录下写我们的业务代码，引入 index.js、utils.js、common.js 和 index.css 这 4 个文件，目录结构如下：</p><span id="more"></span><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">src/<br>├── <span class="hljs-keyword">index</span>.css<br>├── <span class="hljs-keyword">index</span>.html <span class="hljs-meta"># 这个是 HTML 模板代码</span><br>├── <span class="hljs-keyword">index</span>.js<br>├── <span class="hljs-keyword">common</span>.js<br>└── utils.js<br>复制代码<br></code></pre></td></tr></table></figure><p>index.css 写一点儿简单的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>utils.js 文件写个求平方的工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure><p>common.js 文件写个 log 工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">log</span>: <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello &#x27;</span>, msg)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>index.js 文件做一些简单的修改，引入 css 文件和 common.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; log &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./common&#x27;</span>);<br><br><span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br></code></pre></td></tr></table></figure><p>webpack 的配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    entry<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        index<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;../src/index.js&quot;</span><span class="hljs-punctuation">,</span><br>        utils<span class="hljs-punctuation">:</span> &#x27;../src/utils.js&#x27;<span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        filename<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;[name].bundle.js&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 输出 index.js 和 utils.js</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                test<span class="hljs-punctuation">:</span> /\.css$/<span class="hljs-punctuation">,</span><br>                use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    MiniCssExtractPlugin.loader<span class="hljs-punctuation">,</span> <span class="hljs-comment">// 创建一个 link 标签</span><br>                    &#x27;css-loader&#x27;<span class="hljs-punctuation">,</span> <span class="hljs-comment">// css-loader 负责解析 CSS 代码, 处理 CSS 中的依赖</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>    plugins<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-comment">// 用 MiniCssExtractPlugin 抽离出 css 文件，以 link 标签的形式引入样式文件</span><br>        new MiniCssExtractPlugin(<span class="hljs-punctuation">&#123;</span><br>            filename<span class="hljs-punctuation">:</span> &#x27;index.bundle.css&#x27; <span class="hljs-comment">// 输出的 css 文件名为 index.css</span><br>        <span class="hljs-punctuation">&#125;</span>)<span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们运行一下 webpack，看一下打包的结果：</p><p><img src="/2020/04/30/webpack%E4%B8%ADmodule-chunk%E5%92%8Cbundle%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/module1.jpg" alt="image"></p><p>我们可以看出，index.css 和 common.js 在 index.js 中被引入，打包生成的 index.bundle.css 和 index.bundle.js 都属于 chunk 0，utils.js 因为是独立打包的，它生成的 utils.bundle.js 属于 chunk 1。</p><p>感觉还有些绕？我做了一张图，你肯定一看就懂：</p><p><img src="/2020/04/30/webpack%E4%B8%ADmodule-chunk%E5%92%8Cbundle%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/module2.jpg" alt="image"></p><p>看这个图就很明白了：</p><ol><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 <strong>module</strong> ；</li><li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 <strong>chunk</strong> 文件，webpack 会对这个 chunk 文件进行一些操作；</li><li>webpack 处理好 chunk 文件后，最后会输出 <strong>bundle</strong> 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</li></ol><p>一般来说一个 chunk 对应一个 bundle，比如上图中的 <code>utils.js -&gt; chunks 1 -&gt; utils.bundle.js</code>；但也有例外，比如说上图中，我就用 <code>MiniCssExtractPlugin</code> 从 chunks 0 中抽离出了 <code>index.bundle.css</code> 文件。</p><h3 id="一句话总结："><a href="#一句话总结：" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p><code>module</code>，<code>chunk</code> 和 <code>bundle</code> 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：</p><p>我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack动态懒加载</title>
    <link href="/2020/04/24/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/04/24/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>起因是因为一个基于 vue-cli3.0 的项目突然反馈 vendor 包过大，为了减少用户的白屏时间开始做优化。</p><span id="more"></span><hr><h4 id="webpack4-的-splitChunk-插件"><a href="#webpack4-的-splitChunk-插件" class="headerlink" title="webpack4 的 splitChunk 插件"></a>webpack4 的 splitChunk 插件</h4><p>用过 vue-cli3.0 的同学应该熟悉，其舍弃了以前常用的 build 文件夹下的<code>webpack.config.js</code>文件配置，配置内容全部放到<code>vue.config.js</code>文件中，实际上关于 webpack 的配置其实和之前大同小异。打包拆分不得不聊到常用的<code>CommonsChunkPlugin</code>。</p><p>旧项目常用的方式就是通过<code>webpack.optimize.CommonsChunkPlugin(opts)</code>，加载该插件进行代码分割。但是其存在很多问题：</p><ul><li>它可能导致下载更多的超过我们使用的代码</li><li>它在异步 chunks 中是低效的</li><li>配置繁琐，很难使用</li><li>难以被理解</li></ul><p>在 webpack4 抛弃了<code>CommonsChunkPlugin</code>，换成了更先进的<code>SplitChunksPlugin</code>。它们的区别就在于，<code>CommonChunksPlugin</code> 会找到多数模块中都共有的东西，并且把它提取出来（common.js），也就意味着如果你加载了 common.js，那么里面可能会存在一些当前模块不需要的东西。</p><p>而 <code>SplitChunksPlugin</code> 采用了完全不同的 heuristics 方法，它会根据模块之间的依赖关系，自动打包出很多很多（而不是单个）通用模块，可以保证加载进来的代码一定是会被依赖到的。</p><p>下面是一个简单的例子，假设我们有 4 个 chunk，分别依赖了以下模块：</p><p><img src="/2020/04/24/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/webplan1.png" alt="image"></p><p>根据<code>CommonChunksPlugin</code>的默认配置，会打包成：  </p><p><img src="/2020/04/24/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/webplan2.png" alt="image"></p><p>而<code>SplitChunksPlugin</code>会打包成：  </p><p><img src="/2020/04/24/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/webplan3.png" alt="image"></p><p>显然进一步优化了空间。</p><p>当然这不是本次讨论的重点，因为 vue-cli3.0 默认情况下已经是使用了<code>SplitChunksPlugin</code>的配置，查看 vue-cli service config 文件夹下的 app.js，有一段链式的 webpackConfig 配置了最终打包的 chunks 配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (isProd &amp;&amp; !process.<span class="hljs-property">env</span>.<span class="hljs-property">CYPRESS_ENV</span>) &#123;<br>  webpackConfig<br>    .<span class="hljs-property">optimization</span>.<span class="hljs-title function_">splitChunks</span>(&#123;<br>      <span class="hljs-attr">cacheGroups</span>: &#123;<br>        <span class="hljs-attr">vendors</span>: &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">`chunk-vendors`</span>,<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">10</span>,<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">common</span>: &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">`chunk-common`</span>,<br>          <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">priority</span>: -<span class="hljs-number">20</span>,<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>          <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>通常该默认情况可以满足大部分应用场景，但是考虑我们项目的特殊性，我需要额外提高<code>chunk-vendors</code>的 minChunks 项，让一些偶尔出现但是频率没有太高的依赖滚出 vendors。</p><hr><h4 id="动态懒加载"><a href="#动态懒加载" class="headerlink" title="动态懒加载"></a>动态懒加载</h4><p>先来聊聊 import 和 require 的区别。<br>require&#x2F;exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中的开发者自己草拟的规则，得到了大家的承认或者广泛的应用。比如 CommonJS、AMD、CMD 等等。<br>import&#x2F;export 则是名门正派。TC39 制定的新的 ECMAScript 版本，即 ES6（ES2015）中包含进来。</p><p><code>const PAGE_A = require.ensure([], () =&gt; &#123;require(&quot;a&quot;)&#125;</code>。早期写 vue-router，习惯以这种形式去完成异步加载。后续日常开发中，常用的就是 import from 来引入资源（千万避免全局引入 ui 组件，可能会导致资源包异常的大）webpack 官方就指出，应该用 import 来代替<code>require.ensure</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">determineDate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moment&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">moment</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>());<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Failed to load moment&#x27;</span>, err);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./component&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> );<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">determineDate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> moment = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moment&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>(<span class="hljs-string">&#x27;LLLL&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">determineDate</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str));<br></code></pre></td></tr></table></figure><p>相比较而言，import 使用了 promise 的封装，只接受一个参数，就是引用包的地址，语法十分简单。</p><p>由于 webpack 需要将所有 import() 的模块都进行单独打包，所以在工程打包阶段，webpack 会进行依赖收集。webpack 会找到所有 import() 的调用，将传入的参数处理成一个正则，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./app&#x27;</span>+path+<span class="hljs-string">&#x27;/util&#x27;</span>) =&gt; <span class="hljs-regexp">/^\.\/app.*\/util$/</span><br></code></pre></td></tr></table></figure><p>也就是说，import 参数中的所有变量，都会被替换为【.<em>】，而 webpack 就根据这个正则，查找所有符合条件的包，将其作为 package 进行打包。<br>所以 import 的正确姿势，应该是*<em>尽可能静态化表达包所处的路径，最小化变量控制的区域。</em></em><br>如我们要引用一堆页面组件，可以使用<code>import(&#39;./pages/&#39;+ComponentName)</code>，这样就可以实现引用的封装，同时也避免打包多余的内容。但是 webpack 会保证该路径下所有可能引入的文件是可用的，即会预请求。</p><p>官方指出，在 import 内部添加注释，可以完成 chunkname 命名、打包模式等功能。4.6 + 还支持 Prefetching&#x2F;Preloading 来提前加载 &#x2F; 预加载资源。（prefetch 用于未来会发生的场合，preload 用于当前场合）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<br>  <br>  <br>  <span class="hljs-string">&#x27;module&#x27;</span><br>);<br><br><span class="hljs-keyword">import</span>(<br>  <br>  <br>  <br>  <br>  <br>  <br>  <span class="hljs-string">`./locale/<span class="hljs-subst">$&#123;language&#125;</span>`</span><br>);<br></code></pre></td></tr></table></figure><p>的确是可以完美取代 require 了</p><hr><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><p>借助<code>webpack-bundle-analyzer</code>，可以清晰的查看，打包后之后项目的文件大小以及其构成。对于做性能优化有很大的帮助。具体使用方法不再详述，建议直接移步<a href="https://links.jianshu.com/go?to=https://www.npmjs.com/package/webpack-bundle-analyzer">官方文档</a>。</p><hr><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>其实大部分是关于 webpack 的使用方式。老的 require.ensure 也好，新的 import 也好，其实本质还是交给 webpack 去打包处理，在最后选择如何去引入。<br>重要的是 webpack 的配置，即便用了 vue-cli3.0 依然要考虑自定义配置如何去完成，再细化一点就是 import 的引入方式。</p><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://links.jianshu.com/go?to=https://juejin.im/post/5af1677c6fb9a07ab508dabb">一步一步的了解 webpack4 的 splitChunk 插件</a><br><a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/56820346">require 和 import 的区别</a><br><a href="https://links.jianshu.com/go?to=https://segmentfault.com/a/1190000015648036">webpack import() 动态加载模块踩坑</a><br><a href="https://links.jianshu.com/go?to=https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p><p>原文地址 <a href="https://www.jianshu.com/p/54015bf76047">https://www.jianshu.com/p/54015bf76047</a></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack配置</title>
    <link href="/2020/04/17/webpack%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/04/17/webpack%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="多入口配置"><a href="#多入口配置" class="headerlink" title="多入口配置"></a>多入口配置</h2><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;<br>        <span class="hljs-attr">index</span>: path.<span class="hljs-title function_">join</span>(srcPath, <span class="hljs-string">&#x27;index.js&#x27;</span>),<br>        <span class="hljs-attr">other</span>: path.<span class="hljs-title function_">join</span>(srcPath, <span class="hljs-string">&#x27;other.js&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>                <span class="hljs-attr">loader</span>: [<span class="hljs-string">&#x27;babel-loader&#x27;</span>],<br>                <span class="hljs-attr">include</span>: srcPath,<br>                <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span><br>            &#125;,<br>            <span class="hljs-comment">// &#123;</span><br>            <span class="hljs-comment">//     test: /\.css$/,</span><br>            <span class="hljs-comment">//     // loader 的执行顺序是：从后往前</span><br>            <span class="hljs-comment">//     loader: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br>            <span class="hljs-comment">// &#125;,</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-comment">// loader 的执行顺序是：从后往前</span><br>                <span class="hljs-attr">loader</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>] <span class="hljs-comment">// 加了 postcss</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>                <span class="hljs-comment">// 增加 &#x27;less-loader&#x27; ，注意顺序</span><br>                <span class="hljs-attr">loader</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>]<br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-comment">// new HtmlWebpackPlugin(&#123;</span><br>        <span class="hljs-comment">//     template: path.join(srcPath, &#x27;index.html&#x27;),</span><br>        <span class="hljs-comment">//     filename: &#x27;index.html&#x27;</span><br>        <span class="hljs-comment">// &#125;)</span><br><br>        <span class="hljs-comment">// 多入口 - 生成 index.html</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(srcPath, <span class="hljs-string">&#x27;index.html&#x27;</span>),<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span>,<br>            <span class="hljs-comment">// chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用</span><br>            <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;index&#x27;</span>]  <span class="hljs-comment">// 只引用 index.js</span><br>        &#125;),<br>        <span class="hljs-comment">// 多入口 - 生成 other.html</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>            <span class="hljs-attr">template</span>: path.<span class="hljs-title function_">join</span>(srcPath, <span class="hljs-string">&#x27;other.html&#x27;</span>),<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;other.html&#x27;</span>,<br>            <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;other&#x27;</span>]  <span class="hljs-comment">// 只引用 other.js</span><br>        &#125;)<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="CSS压缩"><a href="#CSS压缩" class="headerlink" title="CSS压缩"></a>CSS压缩</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; smart &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserJSPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> webpackCommonConf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)  <br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">smart</span>(webpackCommonConf, &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-comment">// filename: &#x27;bundle.[contentHash:8].js&#x27;,  // 打包代码时，加上 hash 戳</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contentHash:8].js&#x27;</span>, <span class="hljs-comment">// name 即多入口时 entry 的 key</span><br>        <span class="hljs-attr">path</span>: distPath,<br>        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            <span class="hljs-comment">// 图片 - 考虑 base64 编码的情况</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/</span>,<br>                <span class="hljs-attr">use</span>: &#123;<br>                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    <span class="hljs-attr">options</span>: &#123;<br>                        <span class="hljs-comment">// 小于 5kb 的图片用 base64 格式产出</span><br>                        <span class="hljs-comment">// 否则，依然延用 file-loader 的形式，产出 url 格式</span><br>                        <span class="hljs-attr">limit</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1024</span>,<br><br>                        <span class="hljs-comment">// 打包到 img 目录下</span><br>                        <span class="hljs-attr">outputPath</span>: <span class="hljs-string">&#x27;/img1/&#x27;</span>,<br><br>                        <span class="hljs-comment">// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span><br>                        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;</span><br>                    &#125;<br>                &#125;<br>            &#125;,<br>            <span class="hljs-comment">// 抽离 css</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-attr">loader</span>: [<br>                    <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span><br>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span><br>                ]<br>            &#125;,<br>            <span class="hljs-comment">// 抽离 less --&gt; css</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>                <span class="hljs-attr">loader</span>: [<br>                    <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span><br>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;less-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(), <span class="hljs-comment">// 会默认清空 output.path 文件夹</span><br>        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<br>            <span class="hljs-comment">// window.ENV = &#x27;production&#x27;</span><br>            <span class="hljs-attr">ENV</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;production&#x27;</span>)<br>        &#125;),<br><br>        <span class="hljs-comment">// 抽离 css 文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;css/main.[contentHash:8].css&#x27;</span><br>        &#125;)<br>    ],<br><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-comment">// 压缩 css</span><br>        <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserJSPlugin</span>(&#123;&#125;), <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>(&#123;&#125;)],<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="抽离公共代码"><a href="#抽离公共代码" class="headerlink" title="抽离公共代码"></a>抽离公共代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; smart &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">TerserJSPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> webpackCommonConf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">smart</span>(webpackCommonConf, &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-comment">// filename: &#x27;bundle.[contentHash:8].js&#x27;,  // 打包代码时，加上 hash 戳</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contentHash:8].js&#x27;</span>, <span class="hljs-comment">// name 即多入口时 entry 的 key</span><br>        <span class="hljs-attr">path</span>: distPath,<br>        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            <span class="hljs-comment">// 图片 - 考虑 base64 编码的情况</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/</span>,<br>                <span class="hljs-attr">use</span>: &#123;<br>                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    <span class="hljs-attr">options</span>: &#123;<br>                        <span class="hljs-comment">// 小于 5kb 的图片用 base64 格式产出</span><br>                        <span class="hljs-comment">// 否则，依然延用 file-loader 的形式，产出 url 格式</span><br>                        <span class="hljs-attr">limit</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1024</span>,<br><br>                        <span class="hljs-comment">// 打包到 img 目录下</span><br>                        <span class="hljs-attr">outputPath</span>: <span class="hljs-string">&#x27;/img1/&#x27;</span>,<br><br>                        <span class="hljs-comment">// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span><br>                        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;</span><br>                    &#125;<br>                &#125;<br>            &#125;,<br>            <span class="hljs-comment">// 抽离 css</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-attr">loader</span>: [<br>                    <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span><br>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span><br>                ]<br>            &#125;,<br>            <span class="hljs-comment">// 抽离 less</span><br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>                <span class="hljs-attr">loader</span>: [<br>                    <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span><br>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;less-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(), <span class="hljs-comment">// 会默认清空 output.path 文件夹</span><br>        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<br>            <span class="hljs-comment">// window.ENV = &#x27;production&#x27;</span><br>            <span class="hljs-attr">ENV</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;production&#x27;</span>)<br>        &#125;),<br><br>        <span class="hljs-comment">// 抽离 css 文件</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;css/main.[contentHash:8].css&#x27;</span><br>        &#125;)<br>    ],<br><br>    <span class="hljs-attr">optimization</span>: &#123;<br>        <span class="hljs-comment">// 压缩 css</span><br>        <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserJSPlugin</span>(&#123;&#125;), <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>(&#123;&#125;)],<br><br>        <span class="hljs-comment">// 分割代码块</span><br>        <span class="hljs-attr">splitChunks</span>: &#123;<br>            <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * initial 入口 chunk，对于异步导入的文件不处理</span><br><span class="hljs-comment">                async 异步 chunk，只对异步导入的文件处理</span><br><span class="hljs-comment">                all 全部 chunk</span><br><span class="hljs-comment">             */</span><br><br>            <span class="hljs-comment">// 缓存分组</span><br>            <span class="hljs-attr">cacheGroups</span>: &#123;<br>                <span class="hljs-comment">// 第三方模块</span><br>                <span class="hljs-attr">vendor</span>: &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-comment">// chunk 名称</span><br>                    <span class="hljs-attr">priority</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 权限更高，优先抽离，重要！！！</span><br>                    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/node_modules/</span>,<br>                    <span class="hljs-attr">minSize</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 大小限制</span><br>                    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>  <span class="hljs-comment">// 最少复用过几次</span><br>                &#125;,<br><br>                <span class="hljs-comment">// 公共的模块</span><br>                <span class="hljs-attr">common</span>: &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-comment">// chunk 名称</span><br>                    <span class="hljs-attr">priority</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 优先级</span><br>                    <span class="hljs-attr">minSize</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 公共模块的大小限制</span><br>                    <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>  <span class="hljs-comment">// 公共模块最少复用过几次</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack相关问题</title>
    <link href="/2020/04/11/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/11/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如-react-的-jsx-代码必须编译后才能在浏览器中使用；又如-sass-和-less-的代码浏览器也是不支持的。-而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack-脱颖而出成为了当今最流行的前端构建工具。-然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。问题一览"><a href="#随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如-react-的-jsx-代码必须编译后才能在浏览器中使用；又如-sass-和-less-的代码浏览器也是不支持的。-而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack-脱颖而出成为了当今最流行的前端构建工具。-然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。问题一览" class="headerlink" title="随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如 react 的 jsx 代码必须编译后才能在浏览器中使用；又如 sass 和 less 的代码浏览器也是不支持的。 而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack 脱颖而出成为了当今最流行的前端构建工具。 然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。问题一览"></a>随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如 react 的 jsx 代码必须编译后才能在浏览器中使用；又如 sass 和 less 的代码浏览器也是不支持的。 而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack 脱颖而出成为了当今最流行的前端构建工具。 然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。<br><span id="more"></span><br>问题一览</h2><ol><li>webpack 与 grunt、gulp 的不同？</li><li>与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？</li><li>有哪些常见的 Loader？他们是解决什么问题的？</li><li>有哪些常见的 Plugin？他们是解决什么问题的？</li><li>Loader 和 Plugin 的不同？</li><li>webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全</li><li>是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？</li><li>webpack 的热更新是如何做到的？说明其原理？</li><li>如何利用 webpack 来优化前端性能？（提高性能和体验）</li><li>如何提高 webpack 的构建速度？</li><li>怎么配置单页应用？怎么配置多页应用？</li><li>npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</li><li>如何在 vue 项目中实现按需加载？</li></ol><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h3 id="1-webpack-与-grunt、gulp-的不同？"><a href="#1-webpack-与-grunt、gulp-的不同？" class="headerlink" title="1. webpack 与 grunt、gulp 的不同？"></a>1. webpack 与 grunt、gulp 的不同？</h3><p>三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。</p><p>grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个 web 的构建流程。</p><p>webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。</p><p>所以总结一下：</p><ul><li>从构建思路来说</li></ul><p>gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个 <code>Task</code>，并合理控制所有 <code>Task</code> 的调用关系 webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工</p><ul><li>对于知识背景来说</li></ul><p>gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路</p><h3 id="2-与-webpack-类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用-webpack？"><a href="#2-与-webpack-类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用-webpack？" class="headerlink" title="2. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？"></a>2. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？</h3><p>同样是基于入口的打包工具还有以下几个主流的：</p><ul><li>webpack</li><li>rollup</li><li>parcel</li></ul><p><strong>从应用场景上来看：</strong></p><ul><li>webpack 适用于大型复杂的前端站点构建</li><li>rollup 适用于基础库的打包，如 vue、react</li><li>parcel 适用于简单的实验性项目，他可以满足低门槛的快速看到效果</li></ul><p>由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel</p><h3 id="3-有哪些常见的-Loader？他们是解决什么问题的？"><a href="#3-有哪些常见的-Loader？他们是解决什么问题的？" class="headerlink" title="3. 有哪些常见的 Loader？他们是解决什么问题的？"></a>3. 有哪些常见的 Loader？他们是解决什么问题的？</h3><ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><h3 id="4-有哪些常见的-Plugin？他们是解决什么问题的？"><a href="#4-有哪些常见的-Plugin？他们是解决什么问题的？" class="headerlink" title="4. 有哪些常见的 Plugin？他们是解决什么问题的？"></a>4. 有哪些常见的 Plugin？他们是解决什么问题的？</h3><ul><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li></ul><h3 id="5-Loader-和-Plugin-的不同？"><a href="#5-Loader-和-Plugin-的不同？" class="headerlink" title="5.Loader 和 Plugin 的不同？"></a>5.Loader 和 Plugin 的不同？</h3><p><strong>不同的作用</strong></p><ul><li><strong>Loader</strong> 直译为 “加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。</li><li><strong>Plugin</strong> 直译为 “插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>不同的用法</strong></p><ul><li><strong>Loader</strong> 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载 (loader) 和使用的参数（options）</li><li><strong>Plugin</strong> 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="6.webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全"></a>6.webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全</h3><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h3 id="7-是否写过-Loader-和-Plugin？描述一下编写-loader-或-plugin-的思路？"><a href="#7-是否写过-Loader-和-Plugin？描述一下编写-loader-或-plugin-的思路？" class="headerlink" title="7. 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？"></a>7. 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？</h3><p>Loader 像一个 “翻译官” 把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。</p><p>编写 Loader 时要遵循单一原则，每个 Loader 只做一种 “转义” 工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback() 方法，将内容返回给 webpack。 还可以通过 this.async() 生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。</p><p>相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><h3 id="8-webpack-的热更新是如何做到的？说明其原理？"><a href="#8-webpack-的热更新是如何做到的？说明其原理？" class="headerlink" title="8.webpack 的热更新是如何做到的？说明其原理？"></a>8.webpack 的热更新是如何做到的？说明其原理？</h3><p>webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>原理：</p><p><img src="/2020/04/11/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/webpack1.jpeg" alt="image"></p><p>首先要知道 server 端和 client 端都做了处理工作</p><ol><li>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li><li>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</li><li>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</li><li>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li><li>webpack-dev-server&#x2F;client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack&#x2F;hot&#x2F;dev-server 的工作就是根据 webpack-dev-server&#x2F;client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</li><li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li><li>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li><li>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</li></ol><h3 id="9-如何利用-webpack-来优化前端性能？（提高性能和体验）"><a href="#9-如何利用-webpack-来优化前端性能？（提高性能和体验）" class="headerlink" title="9. 如何利用 webpack 来优化前端性能？（提高性能和体验）"></a>9. 如何利用 webpack 来优化前端性能？（提高性能和体验）</h3><p>用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。</p><ul><li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css</li><li>利用 <a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a> 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li><li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现</li><li>提取公共代码。</li></ul><h3 id="10-如何提高-webpack-的构建速度？"><a href="#10-如何提高-webpack-的构建速度？" class="headerlink" title="10. 如何提高 webpack 的构建速度？"></a>10. 如何提高 webpack 的构建速度？</h3><ol><li>多入口情况下，使用 CommonsChunkPlugin 来提取公共代码</li><li>通过 externals 配置来提取常用库</li><li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使用 Happypack 实现多线程加速编译</li><li>使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度</li><li>使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ol><h3 id="11-怎么配置单页应用？怎么配置多页应用？"><a href="#11-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="11. 怎么配置单页应用？怎么配置多页应用？"></a>11. 怎么配置单页应用？怎么配置多页应用？</h3><p>单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述</p><p>多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：</p><ul><li>每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表</li><li>随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</li></ul><h3 id="12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？"><a href="#12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？" class="headerlink" title="12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？"></a>12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</h3><p>Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。</p><p>NPM 模块需要注意以下问题：</p><ol><li>要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。</li><li>Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。</li><li>Npm 包大小应该是尽量小（有些仓库会限制包大小）</li><li>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</li><li>UI 组件类的模块应该将依赖的其它资源文件，例如. css 文件也需要包含在发布的模块里。</li></ol><p>基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化：</p><ol><li>CommonJS 模块化规范的解决方案： 设置 output.libraryTarget&#x3D;’commonjs2’使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用</li><li>输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。</li><li>Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改. babelrc 文件，为其加入 transform-runtime 插件</li><li>不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。</li><li>对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下：</li></ol><p><img src="/2020/04/11/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/webpack2.jpeg" alt="image"></p><h3 id="13-如何在-vue-项目中实现按需加载？"><a href="#13-如何在-vue-项目中实现按需加载？" class="headerlink" title="13. 如何在 vue 项目中实现按需加载？"></a>13. 如何在 vue 项目中实现按需加载？</h3><p>Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</p><p>不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在. babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。</p><p><img src="/2020/04/11/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/webpack3.png" alt="image"></p><p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p><p>通过 import(<em>) 语句来控制加载时机，webpack 内置了对于 import(</em>) 的解析，会将 import(<em>) 中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到 import(</em>) 语句时，会去加载 Chunk 对应生成的文件。import() 会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill</p><p><strong>参考文章</strong></p><ul><li>关于 webpack 的面试题有哪些？</li><li>前端面试之 webpack 面试常见问题</li><li>《深入浅出 webpack》电子版</li><li>webpack 构建性能优化策略小结</li></ul><p>原文链接：<a href="https://www.cnblogs.com/gaoht/p/11310365.html">https://www.cnblogs.com/gaoht/p/11310365.html</a>  </p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6中的Proxy、Reflect以及Vue3.0中的应用原理</title>
    <link href="/2020/04/02/ES6%E4%B8%AD%E7%9A%84Proxy%E3%80%81Reflect%E4%BB%A5%E5%8F%8AVue3-0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/02/ES6%E4%B8%AD%E7%9A%84Proxy%E3%80%81Reflect%E4%BB%A5%E5%8F%8AVue3-0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Object-defineProperty的一些劣势："><a href="#使用Object-defineProperty的一些劣势：" class="headerlink" title="使用Object.defineProperty的一些劣势："></a>使用<code>Object.defineProperty</code>的一些劣势：</h2><ol><li><code>Object.defineProperty</code>监听的是对象的属性，如果对象比较复杂，需要逐个深层遍历他的属性来实现监听，耗费性能</li><li><code>Object.defineProperty</code>无法监听数组的变化，使 Vue 不得不对数组做了额外的 hack。</li></ol><p>相比之下<code>Proxy</code>就更强大，接下来我们就来了解他。</p><span id="more"></span><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN-Proxy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN-Reflect</a></li><li><a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf#heading-3">面试官: 实现双向绑定 Proxy 比 defineproperty 优劣如何?</a></li></ul><h3 id="Proxy-简介"><a href="#Proxy-简介" class="headerlink" title="Proxy 简介"></a>Proxy 简介</h3><p>MDN 上是这么描述的——Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><p>官方的描述总是言简意赅，以至于不明觉厉…</p><p>其实就是在对目标对象的操作之前提供了拦截，可以对外界的操作进行过滤和改写，修改某些操作的默认行为，这样我们可以不直接操作对象本身，而是通过操作对象的代理对象来间接来操作对象，达到预期的目的~</p><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。使用方法如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 语法</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><span class="hljs-comment">// 用例</span><br><span class="hljs-keyword">let</span> p = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> proxyP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(p, &#123;<br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 获取proxyP对象属性时的自定义逻辑</span><br>&#125;,<br><span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-comment">// 设置proxyP对象属性时的自定义逻辑</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上边的代码中：</p><ul><li>target：用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li><li>p&#x2F;proxyP：是一个被代理后的新对象, 它拥有 target 的一切属性和方法. 只不过其行为和结果是在 handler 中自定义的.</li></ul><blockquote><p>这里重点说一下<code>handler</code>：<code>handler</code>本身就是 ES6 所新设计的一个对象. 它的作用就是用来自定义代理对象的各种可代理操作。它本身一共有 13 中方法, 每种方法都可以代理一种操作，常用的几种方法如下:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span><br>handler.<span class="hljs-title function_">defineProperty</span>()<br><br><span class="hljs-comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span><br>handler.<span class="hljs-title function_">has</span>()<br><br><span class="hljs-comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span><br>handler.<span class="hljs-title function_">get</span>()<br><br><span class="hljs-comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span><br>handler.<span class="hljs-title function_">set</span>()<br><br><span class="hljs-comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span><br>handler.<span class="hljs-title function_">deleteProperty</span>()<br><br><span class="hljs-comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span><br>handler.<span class="hljs-title function_">ownKeys</span>()<br><br><span class="hljs-comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span><br>handler.<span class="hljs-title function_">apply</span>()<br><br><span class="hljs-comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span><br>handler.<span class="hljs-title function_">construct</span>()<br></code></pre></td></tr></table></figure><p>Proxy 对于代理模式 Proxy 的作用主要体现在三个方面:</p><ol><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ol><h3 id="Proxy-在-Vue3-0-中的应用原理"><a href="#Proxy-在-Vue3-0-中的应用原理" class="headerlink" title="Proxy 在 Vue3.0 中的应用原理"></a>Proxy 在 Vue3.0 中的应用原理</h3><p>上边已经说过了<code>Object.defineProperty</code>的劣势。相应的<code>Proxy</code>的优势就很明显了：</p><ul><li>Proxy 可以直接监听对象而非属性</li><li>Proxy 可以直接监听数组的变化</li><li>Proxy 有 13 中拦截方法，功能更强大。</li></ul><p>Proxy 的劣势： 兼容性问题, 而且无法用 polyfill 磨平, 因此 Vue 要到 3.0 版本才能用 Proxy 重写。</p><p>简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>);<br><span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, key, value, receiver);<br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;text&#x27;</span>) &#123;<br>      input.<span class="hljs-property">value</span> = value;<br>      p.<span class="hljs-property">innerHTML</span> = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>  &#125;,<br>&#125;);<br><br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  newObj.<span class="hljs-property">text</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><blockquote><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与处理器对象的方法相同。Reflect 不是一个函数对象，因此它是不可构造 (即不可<code>new Reflect</code>) 的。</p></blockquote><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><p><strong>也就是说，Reflect.fn 表示 handler 中的 fn 的默认行为。</strong></p><p>这里我们看两段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这里是get/set方法打印log之后，再执行默认行为</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);<br>    <span class="hljs-comment">// 在浏览器console中，get方法会默认打印出值</span><br>    <span class="hljs-comment">// 如果没有Reflect.get执行默认行为，就无法正确打印出值，而会打印undefined</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`setting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 这里是先执行默认的set确保默认行为执行，set成功之后在打印log，然后返回</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(&#123;&#125;, &#123;<br>  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, name, value, receiver</span>) &#123;<br>    <span class="hljs-keyword">var</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target,name, value, receiver);<br>    <span class="hljs-keyword">if</span> (success) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;property &#x27;</span> + name + <span class="hljs-string">&#x27; on &#x27;</span> + target + <span class="hljs-string">&#x27; set to &#x27;</span> + value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> success;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Creabine/article/details/87811207">原文地址 </a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>路由原理</title>
    <link href="/2020/03/22/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"/>
    <url>/2020/03/22/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>稍微复杂一点的SPA，都需要路由</li><li>vue-router是标配</li></ul><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>hash</li><li>history<span id="more"></span></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><ul><li>hash变化会触发网页跳转，即浏览器前进或后退</li><li>hash变化不会刷新页面</li><li>hash不会提交到server端</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hash test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hash test<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>修改 hash<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// hash 变化，包括：</span></span><br><span class="language-javascript">        <span class="hljs-comment">// a. JS 修改 url</span></span><br><span class="language-javascript">        <span class="hljs-comment">// b. 手动修改 url 的 hash</span></span><br><span class="language-javascript">        <span class="hljs-comment">// c. 浏览器前进、后退</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;old url&#x27;</span>, event.<span class="hljs-property">oldURL</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;new url&#x27;</span>, event.<span class="hljs-property">newURL</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hash:&#x27;</span>, location.<span class="hljs-property">hash</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 页面初次加载，获取 hash</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hash:&#x27;</span>, location.<span class="hljs-property">hash</span>)</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// JS 修改 url</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn1&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;#/user&#x27;</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><ul><li>用url规范的路由，跳转时不刷新页面</li><li>history.pushState</li><li>window.onpopState</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>history API test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>history API test<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn1&quot;</span>&gt;</span>修改 url<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 页面初次加载，获取 path</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;load&#x27;</span>, location.<span class="hljs-property">pathname</span>)</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 打开一个新的路由</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 【注意】用 pushState 方式，浏览器不会刷新页面</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn1&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> state = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;page1&#x27;</span> &#125;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;切换路由到&#x27;</span>, <span class="hljs-string">&#x27;page1&#x27;</span>)</span><br><span class="language-javascript">            history.<span class="hljs-title function_">pushState</span>(state, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;page1&#x27;</span>) <span class="hljs-comment">// 重要！！</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 监听浏览器前进、后退</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onpopstate</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123; <span class="hljs-comment">// 重要！！</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onpopstate&#x27;</span>, event.<span class="hljs-property">state</span>, location.<span class="hljs-property">pathname</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 需要 server 端配合，可参考</span></span><br><span class="language-javascript">        <span class="hljs-comment">// https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件渲染过程</title>
    <link href="/2020/03/11/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <url>/2020/03/11/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="初次渲染过程"><a href="#初次渲染过程" class="headerlink" title="初次渲染过程"></a>初次渲染过程</h2><ol><li>解析模版为render函数（编译打包时已经完成，开发环境下完成）（vue-loader）</li><li>触发响应式，监听data属性，getter setter</li><li>执行render函数，生成vnode，patch（elem,vnode）</li></ol><span id="more"></span><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><ol><li>修改data，触发setter（此前在getter中已经被监听）</li><li>重新执行render函数，生成newVnode</li><li>patch(vnode,newVnode)</li></ol><h2 id="异步渲染过程"><a href="#异步渲染过程" class="headerlink" title="异步渲染过程"></a>异步渲染过程</h2><ol><li>$nextTick</li><li>汇总data的修改一次性更新视图</li><li>修改DOM操作次数，提升性能</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue模板编译</title>
    <link href="/2020/02/28/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
    <url>/2020/02/28/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="模版编译"><a href="#模版编译" class="headerlink" title="模版编译"></a>模版编译</h2><ul><li>模版是vue开发中最常用的部分，即与使用相关的原理</li><li>不是html，有指令等</li><li>组件渲染和更新的过程</li></ul><span id="more"></span><h3 id="js的with语法"><a href="#js的with语法" class="headerlink" title="js的with语法"></a>js的with语法</h3><ul><li>改变{}内自由变量的查找规则，当作obj的属性来查找</li><li>如果找不到匹配的属性，则报错</li><li>with慎用，打破了作用域的规则，易读性差</li></ul><h3 id="vue-template-complier将模版编译为render函数"><a href="#vue-template-complier将模版编译为render函数" class="headerlink" title="vue template complier将模版编译为render函数"></a>vue template complier将模版编译为render函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> compiler = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-template-compiler&#x27;</span>)<br><br><span class="hljs-comment">// 插值</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`</span><br><span class="hljs-comment">// with(this)&#123;return createElement(&#x27;p&#x27;,[createTextVNode(toString(message))])&#125;</span><br><span class="hljs-comment">// h -&gt; vnode</span><br><span class="hljs-comment">// createElement -&gt; vnode</span><br><br><span class="hljs-comment">// // 表达式</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;flag ? message : &#x27;no message found&#x27;&#125;&#125;&lt;/p&gt;`</span><br><span class="hljs-comment">// // with(this)&#123;return _c(&#x27;p&#x27;,[_v(_s(flag ? message : &#x27;no message found&#x27;))])&#125;</span><br><br><span class="hljs-comment">// // 属性和动态属性</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;</span><br><span class="hljs-string">        &lt;img :src=&quot;imgUrl&quot;/&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,</span><br><span class="hljs-comment">//      &#123;staticClass:&quot;container&quot;,attrs:&#123;&quot;id&quot;:&quot;div1&quot;&#125;&#125;,</span><br><span class="hljs-comment">//      [</span><br><span class="hljs-comment">//          _c(&#x27;img&#x27;,&#123;attrs:&#123;&quot;src&quot;:imgUrl&#125;&#125;)])&#125;</span><br><br><span class="hljs-comment">// // 条件</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;p v-if=&quot;flag === &#x27;a&#x27;&quot;&gt;A&lt;/p&gt;</span><br><span class="hljs-string">        &lt;p v-else-if=&quot;flag === &#x27;b&#x27;&quot;&gt;C&lt;/p&gt;</span><br><span class="hljs-string">        &lt;p v-else&gt;B&lt;/p&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,[(flag === &#x27;a&#x27;)?_c(&#x27;p&#x27;,[_v(&quot;A&quot;)]):_c(&#x27;p&#x27;,[_v(&quot;B&quot;)])])&#125;</span><br><br><span class="hljs-comment">// 循环</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;ul&#x27;,_l((list),function(item)&#123;return _c(&#x27;li&#x27;,&#123;key:item.id&#125;,[_v(_s(item.title))])&#125;),0)&#125;</span><br><br><span class="hljs-comment">// 事件</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;button @click=&quot;clickHandler&quot;&gt;submit&lt;/button&gt;</span><br><span class="hljs-string">`</span><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;button&#x27;,&#123;on:&#123;&quot;click&quot;:clickHandler&#125;&#125;,[_v(&quot;submit&quot;)])&#125;</span><br><br><span class="hljs-comment">// v-model</span><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`</span><br><span class="hljs-comment">// 主要看 input 事件</span><br><span class="hljs-comment">// with(this)&#123;return _c(&#x27;input&#x27;,&#123;directives:[&#123;name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(name),expression:&quot;name&quot;&#125;],attrs:&#123;&quot;type&quot;:&quot;text&quot;&#125;,domProps:&#123;&quot;value&quot;:(name)&#125;,on:&#123;&quot;input&quot;:function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125;</span><br><br><span class="hljs-comment">// render 函数</span><br><span class="hljs-comment">// 返回 vnode</span><br><span class="hljs-comment">// patch</span><br><br><span class="hljs-comment">// 编译</span><br><span class="hljs-keyword">const</span> res = compiler.<span class="hljs-title function_">compile</span>(template)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">render</span>)<br><br><span class="hljs-comment">// ---------------分割线--------------</span><br><br><span class="hljs-comment">// // 从 vue 源码中找到缩写函数的含义</span><br><span class="hljs-comment">// function installRenderHelpers (target) &#123;</span><br><span class="hljs-comment">//     target._o = markOnce;</span><br><span class="hljs-comment">//     target._n = toNumber;</span><br><span class="hljs-comment">//     target._s = toString;</span><br><span class="hljs-comment">//     target._l = renderList;</span><br><span class="hljs-comment">//     target._t = renderSlot;</span><br><span class="hljs-comment">//     target._q = looseEqual;</span><br><span class="hljs-comment">//     target._i = looseIndexOf;</span><br><span class="hljs-comment">//     target._m = renderStatic;</span><br><span class="hljs-comment">//     target._f = resolveFilter;</span><br><span class="hljs-comment">//     target._k = checkKeyCodes;</span><br><span class="hljs-comment">//     target._b = bindObjectProps;</span><br><span class="hljs-comment">//     target._v = createTextVNode;</span><br><span class="hljs-comment">//     target._e = createEmptyVNode;</span><br><span class="hljs-comment">//     target._u = resolveScopedSlots;</span><br><span class="hljs-comment">//     target._g = bindObjectListeners;</span><br><span class="hljs-comment">//     target._d = bindDynamicKeys;</span><br><span class="hljs-comment">//     target._p = prependModifier;</span><br><span class="hljs-comment">// &#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="执行render-生成-vnode"><a href="#执行render-生成-vnode" class="headerlink" title="执行render 生成 vnode"></a>执行render 生成 vnode</h3><p>执行render函数生成vnode</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>模版编译为render函数，执行render函数返回vnode</li><li>基于vonde再执行patch和diff</li><li>使用webpack vue-loader，会在开发环境下编译模版</li></ul><h3 id="可以使用render代替template"><a href="#可以使用render代替template" class="headerlink" title="可以使用render代替template"></a>可以使用render代替template</h3>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue虚拟DOM</title>
    <link href="/2020/02/12/Vue%E8%99%9A%E6%8B%9FDOM/"/>
    <url>/2020/02/12/Vue%E8%99%9A%E6%8B%9FDOM/</url>
    
    <content type="html"><![CDATA[<h2 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual DOM）"></a>虚拟DOM（Virtual DOM）</h2><ul><li>vdom是实现Vue和React的重要基石</li><li>diff算法是vdom最核心、最关键的部分</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>有一定的复杂度，想减少计算次数比较难</li><li>把计算转为js计算，性能更优</li><li>vdom是用js模拟dom结构，计算出最小的变更，然后操作dom<span id="more"></span></li></ul><h2 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h2><ul><li>简洁强大的vdom库，易学易用</li><li>Vue也是参考他来做的</li></ul><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><ul><li>diff即对比</li><li>js对象也可以做diff</li><li>两棵树也可以做diff</li></ul><h4 id="树的diff算法的时间复杂度是"><a href="#树的diff算法的时间复杂度是" class="headerlink" title="树的diff算法的时间复杂度是"></a>树的diff算法的时间复杂度是</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs math">O(n^3)<br></code></pre></td></tr></table></figure><ul><li>遍历第一棵树</li><li>遍历第二棵树</li><li>排序</li></ul><p><strong>1000个节点要算一亿次</strong></p><h4 id="优化时间复杂度到O-n"><a href="#优化时间复杂度到O-n" class="headerlink" title="优化时间复杂度到O(n)"></a>优化时间复杂度到O(n)</h4><ul><li>只比较同一层级，不跨级比较</li><li>tag不同，则删掉重建，不再深度比较</li><li>tag和key都相同，则认为是相同节点，不再深度比较</li></ul><h3 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; vnode, <span class="hljs-title class_">VNode</span>, <span class="hljs-title class_">VNodeData</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vnode&#x27;</span>;<br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">VNodes</span> = <span class="hljs-title class_">VNode</span>[];<br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">VNodeChildElement</span> = <span class="hljs-title class_">VNode</span> | string | number | <span class="hljs-literal">undefined</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">ArrayOrElement</span>&lt;T&gt; = T | T[];<br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">VNodeChildren</span> = <span class="hljs-title class_">ArrayOrElement</span>&lt;<span class="hljs-title class_">VNodeChildElement</span>&gt;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> is <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./is&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addNS</span> (<span class="hljs-params">data: any, children: VNodes | <span class="hljs-literal">undefined</span>, sel: string | <span class="hljs-literal">undefined</span></span>): <span class="hljs-keyword">void</span> &#123;<br>  data.<span class="hljs-property">ns</span> = <span class="hljs-string">&#x27;http://www.w3.org/2000/svg&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (sel !== <span class="hljs-string">&#x27;foreignObject&#x27;</span> &amp;&amp; children !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; ++i) &#123;<br>      <span class="hljs-keyword">let</span> childData = children[i].<span class="hljs-property">data</span>;<br>      <span class="hljs-keyword">if</span> (childData !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-title function_">addNS</span>(childData, (children[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>).<span class="hljs-property">children</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNodes</span>, children[i].<span class="hljs-property">sel</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">sel: string</span>): <span class="hljs-title class_">VNode</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">sel: string, data: VNodeData | <span class="hljs-literal">null</span></span>): <span class="hljs-title class_">VNode</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">sel: string, children: VNodeChildren</span>): <span class="hljs-title class_">VNode</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">sel: string, data: VNodeData | <span class="hljs-literal">null</span>, children: VNodeChildren</span>): <span class="hljs-title class_">VNode</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span> (<span class="hljs-params">sel: any, b?: any, c?: any</span>): <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">VNodeData</span> = &#123;&#125;, <span class="hljs-attr">children</span>: any, <span class="hljs-attr">text</span>: any, <span class="hljs-attr">i</span>: number;<br>  <span class="hljs-keyword">if</span> (c !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">if</span> (b !== <span class="hljs-literal">null</span>) &#123; data = b; &#125;<br>    <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">array</span>(c)) &#123;<br>      children = c;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(c)) &#123;<br>      text = c;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &amp;&amp; c.<span class="hljs-property">sel</span>) &#123;<br>      children = [c];<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b !== <span class="hljs-literal">undefined</span> &amp;&amp; b !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">array</span>(b)) &#123;<br>      children = b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(b)) &#123;<br>      text = b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b &amp;&amp; b.<span class="hljs-property">sel</span>) &#123;<br>      children = [b];<br>    &#125; <span class="hljs-keyword">else</span> &#123; data = b; &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (children !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; ++i) &#123;<br>      <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(children[i])) children[i] = <span class="hljs-title function_">vnode</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, children[i], <span class="hljs-literal">undefined</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<br>    sel[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;s&#x27;</span> &amp;&amp; sel[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;v&#x27;</span> &amp;&amp; sel[<span class="hljs-number">2</span>] === <span class="hljs-string">&#x27;g&#x27;</span> &amp;&amp;<br>    (sel.<span class="hljs-property">length</span> === <span class="hljs-number">3</span> || sel[<span class="hljs-number">3</span>] === <span class="hljs-string">&#x27;.&#x27;</span> || sel[<span class="hljs-number">3</span>] === <span class="hljs-string">&#x27;#&#x27;</span>)<br>  ) &#123;<br>    <span class="hljs-title function_">addNS</span>(data, children, sel);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回 vnode</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">vnode</span>(sel, data, children, text, <span class="hljs-literal">undefined</span>);<br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> h;<br><br></code></pre></td></tr></table></figure><p>h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的</p><figure class="highlight plaintext"><figcaption><span>h </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs render:">```js<br>render: function (createElement) &#123;<br>    return createElement(App);<br>&#125;<br></code></pre></td></tr></table></figure><p>进一步缩写为(ES6 语法)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">render</span> (createElement) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">App</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再进一步缩写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">render</span> (h)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>按照 ES6 箭头函数的写法，就得到了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>);<br></code></pre></td></tr></table></figure><p>它来自单词 hyperscript，这个单词通常用在 virtual-dom 的实现中。Hyperscript 本身是指<br>生成HTML 结构的 script 脚本，因为 HTML 是 hyper-text markup language 的缩写（超文本标记语言）</p><h3 id="patch函数"><a href="#patch函数" class="headerlink" title="patch函数"></a>patch函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* global module, document, Node */</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Module</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/module&#x27;</span>;<br><span class="hljs-keyword">import</span> vnode, &#123; <span class="hljs-title class_">VNode</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./vnode&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> is <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./is&#x27;</span>;<br><span class="hljs-keyword">import</span> htmlDomApi, &#123; <span class="hljs-variable constant_">DOMAPI</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./htmldomapi&#x27;</span>;<br><br>type <span class="hljs-title class_">NonUndefined</span>&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-literal">undefined</span> ? never : T;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUndef</span> (<span class="hljs-params">s: any</span>): boolean &#123; <span class="hljs-keyword">return</span> s === <span class="hljs-literal">undefined</span>; &#125;<br><span class="hljs-keyword">function</span> isDef&lt;A&gt; (<span class="hljs-attr">s</span>: A): s is <span class="hljs-title class_">NonUndefined</span>&lt;A&gt; &#123; <span class="hljs-keyword">return</span> s !== <span class="hljs-literal">undefined</span>; &#125;<br><br>type <span class="hljs-title class_">VNodeQueue</span> = <span class="hljs-title class_">VNode</span>[];<br><br><span class="hljs-keyword">const</span> emptyNode = <span class="hljs-title function_">vnode</span>(<span class="hljs-string">&#x27;&#x27;</span>, &#123;&#125;, [], <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span> (<span class="hljs-params">vnode1: VNode, vnode2: VNode</span>): boolean &#123;<br>  <span class="hljs-comment">// key 和 sel 都相等</span><br>  <span class="hljs-comment">// undefined === undefined // true</span><br>  <span class="hljs-keyword">return</span> vnode1.<span class="hljs-property">key</span> === vnode2.<span class="hljs-property">key</span> &amp;&amp; vnode1.<span class="hljs-property">sel</span> === vnode2.<span class="hljs-property">sel</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isVnode</span> (<span class="hljs-params">vnode: any</span>): vnode is <span class="hljs-title class_">VNode</span> &#123;<br>  <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">sel</span> !== <span class="hljs-literal">undefined</span>;<br>&#125;<br><br>type <span class="hljs-title class_">KeyToIndexMap</span> = &#123;[<span class="hljs-attr">key</span>: string]: number&#125;;<br><br>type <span class="hljs-title class_">ArraysOf</span>&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-title class_">Array</span>&lt;T[K]&gt;;<br>&#125;<br><br>type <span class="hljs-title class_">ModuleHooks</span> = <span class="hljs-title class_">ArraysOf</span>&lt;<span class="hljs-title class_">Module</span>&gt;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createKeyToOldIdx</span> (<span class="hljs-params">children: VNode[], beginIdx: number, endIdx: number</span>): <span class="hljs-title class_">KeyToIndexMap</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">map</span>: <span class="hljs-title class_">KeyToIndexMap</span> = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = beginIdx; i &lt;= endIdx; ++i) &#123;<br>    <span class="hljs-keyword">const</span> key = children[i]?.<span class="hljs-property">key</span>;<br>    <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">undefined</span>) &#123;<br>      map[key] = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> map;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">hooks</span>: <span class="hljs-title class_">Array</span>&lt;keyof <span class="hljs-title class_">Module</span>&gt; = [<span class="hljs-string">&#x27;create&#x27;</span>, <span class="hljs-string">&#x27;update&#x27;</span>, <span class="hljs-string">&#x27;remove&#x27;</span>, <span class="hljs-string">&#x27;destroy&#x27;</span>, <span class="hljs-string">&#x27;pre&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>];<br><br><span class="hljs-keyword">export</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./h&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; thunk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./thunk&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span> (<span class="hljs-params">modules: <span class="hljs-built_in">Array</span>&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: number, <span class="hljs-attr">j</span>: number, cbs = (&#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">ModuleHooks</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">api</span>: <span class="hljs-variable constant_">DOMAPI</span> = domApi !== <span class="hljs-literal">undefined</span> ? domApi : htmlDomApi;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hooks.<span class="hljs-property">length</span>; ++i) &#123;<br>    cbs[hooks[i]] = [];<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; modules.<span class="hljs-property">length</span>; ++j) &#123;<br>      <span class="hljs-keyword">const</span> hook = modules[j][hooks[i]];<br>      <span class="hljs-keyword">if</span> (hook !== <span class="hljs-literal">undefined</span>) &#123;<br>        (cbs[hooks[i]] <span class="hljs-keyword">as</span> any[]).<span class="hljs-title function_">push</span>(hook);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">emptyNodeAt</span> (<span class="hljs-params">elm: Element</span>) &#123;<br>    <span class="hljs-keyword">const</span> id = elm.<span class="hljs-property">id</span> ? <span class="hljs-string">&#x27;#&#x27;</span> + elm.<span class="hljs-property">id</span> : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">const</span> c = elm.<span class="hljs-property">className</span> ? <span class="hljs-string">&#x27;.&#x27;</span> + elm.<span class="hljs-property">className</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;.&#x27;</span>) : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">vnode</span>(api.<span class="hljs-title function_">tagName</span>(elm).<span class="hljs-title function_">toLowerCase</span>() + id + c, &#123;&#125;, [], <span class="hljs-literal">undefined</span>, elm);<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRmCb</span> (<span class="hljs-params">childElm: Node, listeners: number</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">rmCb</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (--listeners === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">const</span> parent = api.<span class="hljs-title function_">parentNode</span>(childElm);<br>        api.<span class="hljs-title function_">removeChild</span>(parent, childElm);<br>      &#125;<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span> (<span class="hljs-params">vnode: VNode, insertedVnodeQueue: VNodeQueue</span>): <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: any, data = vnode.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">if</span> (data !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">const</span> init = data.<span class="hljs-property">hook</span>?.<span class="hljs-property">init</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(init)) &#123;<br>        <span class="hljs-title function_">init</span>(vnode);<br>        data = vnode.<span class="hljs-property">data</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> children = vnode.<span class="hljs-property">children</span>, sel = vnode.<span class="hljs-property">sel</span>;<br>    <span class="hljs-keyword">if</span> (sel === <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>        vnode.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>      &#125;<br>      vnode.<span class="hljs-property">elm</span> = api.<span class="hljs-title function_">createComment</span>(vnode.<span class="hljs-property">text</span>!);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sel !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-comment">// Parse selector</span><br>      <span class="hljs-keyword">const</span> hashIdx = sel.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br>      <span class="hljs-keyword">const</span> dotIdx = sel.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>, hashIdx);<br>      <span class="hljs-keyword">const</span> hash = hashIdx &gt; <span class="hljs-number">0</span> ? hashIdx : sel.<span class="hljs-property">length</span>;<br>      <span class="hljs-keyword">const</span> dot = dotIdx &gt; <span class="hljs-number">0</span> ? dotIdx : sel.<span class="hljs-property">length</span>;<br>      <span class="hljs-keyword">const</span> tag = hashIdx !== -<span class="hljs-number">1</span> || dotIdx !== -<span class="hljs-number">1</span> ? sel.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(hash, dot)) : sel;<br>      <span class="hljs-keyword">const</span> elm = vnode.<span class="hljs-property">elm</span> = <span class="hljs-title function_">isDef</span>(data) &amp;&amp; <span class="hljs-title function_">isDef</span>(i = data.<span class="hljs-property">ns</span>)<br>        ? api.<span class="hljs-title function_">createElementNS</span>(i, tag)<br>        : api.<span class="hljs-title function_">createElement</span>(tag);<br>      <span class="hljs-keyword">if</span> (hash &lt; dot) elm.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>, sel.<span class="hljs-title function_">slice</span>(hash + <span class="hljs-number">1</span>, dot));<br>      <span class="hljs-keyword">if</span> (dotIdx &gt; <span class="hljs-number">0</span>) elm.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>, sel.<span class="hljs-title function_">slice</span>(dot + <span class="hljs-number">1</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\./g</span>, <span class="hljs-string">&#x27; &#x27;</span>));<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">create</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">create</span>[i](emptyNode, vnode);<br>      <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">array</span>(children)) &#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; ++i) &#123;<br>          <span class="hljs-keyword">const</span> ch = children[i];<br>          <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>            api.<span class="hljs-title function_">appendChild</span>(elm, <span class="hljs-title function_">createElm</span>(ch <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>, insertedVnodeQueue));<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is.<span class="hljs-title function_">primitive</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>        api.<span class="hljs-title function_">appendChild</span>(elm, api.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>));<br>      &#125;<br>      <span class="hljs-keyword">const</span> hook = vnode.<span class="hljs-property">data</span>!.<span class="hljs-property">hook</span>;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(hook)) &#123;<br>        hook.<span class="hljs-property">create</span>?.(emptyNode, vnode);<br>        <span class="hljs-keyword">if</span> (hook.<span class="hljs-property">insert</span>) &#123;<br>          insertedVnodeQueue.<span class="hljs-title function_">push</span>(vnode);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vnode.<span class="hljs-property">elm</span> = api.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>!);<br>    &#125;<br>    <span class="hljs-keyword">return</span> vnode.<span class="hljs-property">elm</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addVnodes</span> (<span class="hljs-params"></span><br><span class="hljs-params">    parentElm: Node,</span><br><span class="hljs-params">    before: Node | <span class="hljs-literal">null</span>,</span><br><span class="hljs-params">    vnodes: VNode[],</span><br><span class="hljs-params">    startIdx: number,</span><br><span class="hljs-params">    endIdx: number,</span><br><span class="hljs-params">    insertedVnodeQueue: VNodeQueue</span><br><span class="hljs-params">  </span>) &#123;<br>    <span class="hljs-keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;<br>      <span class="hljs-keyword">const</span> ch = vnodes[startIdx];<br>      <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createElm</span>(ch, insertedVnodeQueue), before);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeDestroyHook</span> (<span class="hljs-params">vnode: VNode</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">if</span> (data !== <span class="hljs-literal">undefined</span>) &#123;<br>      data?.<span class="hljs-property">hook</span>?.<span class="hljs-property">destroy</span>?.(vnode);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">destroy</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">destroy</span>[i](vnode);<br>      <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">children</span> !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; ++j) &#123;<br>          <span class="hljs-keyword">const</span> child = vnode.<span class="hljs-property">children</span>[j];<br>          <span class="hljs-keyword">if</span> (child != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> child !== <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>            <span class="hljs-title function_">invokeDestroyHook</span>(child);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeVnodes</span> (<span class="hljs-params">parentElm: Node,</span><br><span class="hljs-params">    vnodes: VNode[],</span><br><span class="hljs-params">    startIdx: number,</span><br><span class="hljs-params">    endIdx: number</span>): <span class="hljs-keyword">void</span> &#123;<br>    <span class="hljs-keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">listeners</span>: number, <span class="hljs-attr">rm</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>, ch = vnodes[startIdx];<br>      <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch.<span class="hljs-property">sel</span>)) &#123;<br>          <span class="hljs-title function_">invokeDestroyHook</span>(ch); <span class="hljs-comment">// hook 操作</span><br><br>          <span class="hljs-comment">// 移除 DOM 元素</span><br>          listeners = cbs.<span class="hljs-property">remove</span>.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>;<br>          rm = <span class="hljs-title function_">createRmCb</span>(ch.<span class="hljs-property">elm</span>!, listeners);<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">remove</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">remove</span>[i](ch, rm);<br>          <span class="hljs-keyword">const</span> removeHook = ch?.<span class="hljs-property">data</span>?.<span class="hljs-property">hook</span>?.<span class="hljs-property">remove</span>;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(removeHook)) &#123;<br>            <span class="hljs-title function_">removeHook</span>(ch, rm);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">rm</span>();<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Text node</span><br>          api.<span class="hljs-title function_">removeChild</span>(parentElm, ch.<span class="hljs-property">elm</span>!);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span> (<span class="hljs-params">parentElm: Node,</span><br><span class="hljs-params">    oldCh: VNode[],</span><br><span class="hljs-params">    newCh: VNode[],</span><br><span class="hljs-params">    insertedVnodeQueue: VNodeQueue</span>) &#123;<br>    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>, newStartIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx];<br>    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx];<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">oldKeyToIdx</span>: <span class="hljs-title class_">KeyToIndexMap</span> | <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">idxInOld</span>: number;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">elmToMove</span>: <span class="hljs-title class_">VNode</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">before</span>: any;<br><br>    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-keyword">if</span> (oldStartVnode == <span class="hljs-literal">null</span>) &#123;<br>        oldStartVnode = oldCh[++oldStartIdx]; <span class="hljs-comment">// Vnode might have been moved left</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndVnode == <span class="hljs-literal">null</span>) &#123;<br>        oldEndVnode = oldCh[--oldEndIdx];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartVnode == <span class="hljs-literal">null</span>) &#123;<br>        newStartVnode = newCh[++newStartIdx];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndVnode == <span class="hljs-literal">null</span>) &#123;<br>        newEndVnode = newCh[--newEndIdx];<br><br>      <span class="hljs-comment">// 开始和开始对比</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;<br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue);<br>        oldStartVnode = oldCh[++oldStartIdx];<br>        newStartVnode = newCh[++newStartIdx];<br>      <br>      <span class="hljs-comment">// 结束和结束对比</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;<br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue);<br>        oldEndVnode = oldCh[--oldEndIdx];<br>        newEndVnode = newCh[--newEndIdx];<br><br>      <span class="hljs-comment">// 开始和结束对比</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span><br>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue);<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">elm</span>!, api.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>!));<br>        oldStartVnode = oldCh[++oldStartIdx];<br>        newEndVnode = newCh[--newEndIdx];<br><br>      <span class="hljs-comment">// 结束和开始对比</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span><br>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue);<br>        api.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>!, oldStartVnode.<span class="hljs-property">elm</span>!);<br>        oldEndVnode = oldCh[--oldEndIdx];<br>        newStartVnode = newCh[++newStartIdx];<br><br>      <span class="hljs-comment">// 以上四个都未命中</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (oldKeyToIdx === <span class="hljs-literal">undefined</span>) &#123;<br>          oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx);<br>        &#125;<br>        <span class="hljs-comment">// 拿新节点 key ，能否对应上 oldCh 中的某个节点的 key</span><br>        idxInOld = oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span> <span class="hljs-keyword">as</span> string];<br>  <br>        <span class="hljs-comment">// 没对应上</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123; <span class="hljs-comment">// New element</span><br>          api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue), oldStartVnode.<span class="hljs-property">elm</span>!);<br>          newStartVnode = newCh[++newStartIdx];<br>        <br>        <span class="hljs-comment">// 对应上了</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 对应上 key 的节点</span><br>          elmToMove = oldCh[idxInOld];<br><br>          <span class="hljs-comment">// sel 是否相等（sameVnode 的条件）</span><br>          <span class="hljs-keyword">if</span> (elmToMove.<span class="hljs-property">sel</span> !== newStartVnode.<span class="hljs-property">sel</span>) &#123;<br>            <span class="hljs-comment">// New element</span><br>            api.<span class="hljs-title function_">insertBefore</span>(parentElm, <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue), oldStartVnode.<span class="hljs-property">elm</span>!);<br>          <br>          <span class="hljs-comment">// sel 相等，key 相等</span><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">patchVnode</span>(elmToMove, newStartVnode, insertedVnodeQueue);<br>            oldCh[idxInOld] = <span class="hljs-literal">undefined</span> <span class="hljs-keyword">as</span> any;<br>            api.<span class="hljs-title function_">insertBefore</span>(parentElm, elmToMove.<span class="hljs-property">elm</span>!, oldStartVnode.<span class="hljs-property">elm</span>!);<br>          &#125;<br>          newStartVnode = newCh[++newStartIdx];<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;<br>      <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;<br>        before = newCh[newEndIdx + <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">elm</span>;<br>        <span class="hljs-title function_">addVnodes</span>(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">patchVnode</span> (<span class="hljs-params">oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue</span>) &#123;<br>    <span class="hljs-comment">// 执行 prepatch hook</span><br>    <span class="hljs-keyword">const</span> hook = vnode.<span class="hljs-property">data</span>?.<span class="hljs-property">hook</span>;<br>    hook?.<span class="hljs-property">prepatch</span>?.(oldVnode, vnode);<br><br>    <span class="hljs-comment">// 设置 vnode.elem</span><br>    <span class="hljs-keyword">const</span> elm = vnode.<span class="hljs-property">elm</span> = oldVnode.<span class="hljs-property">elm</span>!;<br>  <br>    <span class="hljs-comment">// 旧 children</span><br>    <span class="hljs-keyword">let</span> oldCh = oldVnode.<span class="hljs-property">children</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>[];<br>    <span class="hljs-comment">// 新 children</span><br>    <span class="hljs-keyword">let</span> ch = vnode.<span class="hljs-property">children</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>[];<br><br>    <span class="hljs-keyword">if</span> (oldVnode === vnode) <span class="hljs-keyword">return</span>;<br>  <br>    <span class="hljs-comment">// hook 相关</span><br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">data</span> !== <span class="hljs-literal">undefined</span>) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">update</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">update</span>[i](oldVnode, vnode);<br>      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">hook</span>?.<span class="hljs-property">update</span>?.(oldVnode, vnode);<br>    &#125;<br><br>    <span class="hljs-comment">// vnode.text === undefined （vnode.children 一般有值）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(vnode.<span class="hljs-property">text</span>)) &#123;<br>      <span class="hljs-comment">// 新旧都有 children</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh) &amp;&amp; <span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-keyword">if</span> (oldCh !== ch) <span class="hljs-title function_">updateChildren</span>(elm, oldCh, ch, insertedVnodeQueue);<br>      <span class="hljs-comment">// 新 children 有，旧 children 无 （旧 text 有）</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(ch)) &#123;<br>        <span class="hljs-comment">// 清空 text</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) api.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>);<br>        <span class="hljs-comment">// 添加 children</span><br>        <span class="hljs-title function_">addVnodes</span>(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, insertedVnodeQueue);<br>      <span class="hljs-comment">// 旧 child 有，新 child 无</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-comment">// 移除 children</span><br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 旧 text 有</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldVnode.<span class="hljs-property">text</span>)) &#123;<br>        api.<span class="hljs-title function_">setTextContent</span>(elm, <span class="hljs-string">&#x27;&#x27;</span>);<br>      &#125;<br><br>    <span class="hljs-comment">// else : vnode.text !== undefined （vnode.children 无值）</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.<span class="hljs-property">text</span> !== vnode.<span class="hljs-property">text</span>) &#123;<br>      <span class="hljs-comment">// 移除旧 children</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(oldCh)) &#123;<br>        <span class="hljs-title function_">removeVnodes</span>(elm, oldCh, <span class="hljs-number">0</span>, oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-comment">// 设置新 text</span><br>      api.<span class="hljs-title function_">setTextContent</span>(elm, vnode.<span class="hljs-property">text</span>!);<br>    &#125;<br>    hook?.<span class="hljs-property">postpatch</span>?.(oldVnode, vnode);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span> (<span class="hljs-params">oldVnode: VNode | Element, vnode: VNode</span>): <span class="hljs-title class_">VNode</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: number, <span class="hljs-attr">elm</span>: <span class="hljs-title class_">Node</span>, <span class="hljs-attr">parent</span>: <span class="hljs-title class_">Node</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">insertedVnodeQueue</span>: <span class="hljs-title class_">VNodeQueue</span> = [];<br>    <span class="hljs-comment">// 执行 pre hook</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">pre</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">pre</span>[i]();<br><br>    <span class="hljs-comment">// 第一个参数不是 vnode</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isVnode</span>(oldVnode)) &#123;<br>      <span class="hljs-comment">// 创建一个空的 vnode ，关联到这个 DOM 元素</span><br>      oldVnode = <span class="hljs-title function_">emptyNodeAt</span>(oldVnode);<br>    &#125;<br><br>    <span class="hljs-comment">// 相同的 vnode（key 和 sel 都相等）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldVnode, vnode)) &#123;<br>      <span class="hljs-comment">// vnode 对比</span><br>      <span class="hljs-title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue);<br>    <br>    <span class="hljs-comment">// 不同的 vnode ，直接删掉重建</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      elm = oldVnode.<span class="hljs-property">elm</span>!;<br>      parent = api.<span class="hljs-title function_">parentNode</span>(elm);<br><br>      <span class="hljs-comment">// 重建</span><br>      <span class="hljs-title function_">createElm</span>(vnode, insertedVnodeQueue);<br><br>      <span class="hljs-keyword">if</span> (parent !== <span class="hljs-literal">null</span>) &#123;<br>        api.<span class="hljs-title function_">insertBefore</span>(parent, vnode.<span class="hljs-property">elm</span>!, api.<span class="hljs-title function_">nextSibling</span>(elm));<br>        <span class="hljs-title function_">removeVnodes</span>(parent, [oldVnode], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; insertedVnodeQueue.<span class="hljs-property">length</span>; ++i) &#123;<br>      insertedVnodeQueue[i].<span class="hljs-property">data</span>!.<span class="hljs-property">hook</span>!.<span class="hljs-property">insert</span>!(insertedVnodeQueue[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.<span class="hljs-property">post</span>.<span class="hljs-property">length</span>; ++i) cbs.<span class="hljs-property">post</span>[i]();<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue的响应式</title>
    <link href="/2020/01/23/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <url>/2020/01/23/Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h2><p><strong>核心的API</strong></p><span id="more"></span><h3 id="监听对象（简单）"><a href="#监听对象（简单）" class="headerlink" title="监听对象（简单）"></a>监听对象（简单）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;<br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, <span class="hljs-string">&#x27;name&#x27;</span> ,&#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get &#x27;</span>+name)<br>        <span class="hljs-keyword">return</span> name<br>    &#125;,<br>    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set &#x27;</span>+value)<br>        name = value <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="复杂对象监听"><a href="#复杂对象监听" class="headerlink" title="复杂对象监听"></a>复杂对象监听</h3><h4 id="线程上的代码"><a href="#线程上的代码" class="headerlink" title="线程上的代码"></a>线程上的代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 准备数据</span><br><span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-comment">// 需要深度监听</span><br>    &#125;,<br>    <span class="hljs-attr">nums</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>&#125;<br><br><span class="hljs-comment">// 监听数据</span><br><span class="hljs-title function_">observer</span>(data)<br><br><span class="hljs-comment">// 测试</span><br>data.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;lisi&#x27;</span><br>data.<span class="hljs-property">age</span> = <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h4 id="observer方法"><a href="#observer方法" class="headerlink" title="observer方法"></a>observer方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">observer</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 不是对象或数组</span><br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;<br>        <span class="hljs-title function_">defineReactive</span>(target, key, target[key])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="defineReactive方法"><a href="#defineReactive方法" class="headerlink" title="defineReactive方法"></a>defineReactive方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 重新定义属性，监听起来</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-comment">// 深度监听</span><br>    <span class="hljs-title function_">observer</span>(value)<br><br>    <span class="hljs-comment">// 核心 API</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> value<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (newValue !== value) &#123;<br>                <span class="hljs-comment">// 深度监听</span><br>                <span class="hljs-title function_">observer</span>(newValue)<br><br>                <span class="hljs-comment">// 设置新值</span><br>                <span class="hljs-comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span><br>                value = newValue<br><br>                <span class="hljs-comment">// 触发更新视图</span><br>                <span class="hljs-title function_">updateView</span>()<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>此处使用递归的形式，进行对象的向下遍历</p></blockquote><h4 id="Object-defineProperty的缺点"><a href="#Object-defineProperty的缺点" class="headerlink" title="Object.defineProperty的缺点"></a>Object.defineProperty的缺点</h4><ul><li>深度监听，需要一次性递归到底，计算量大</li><li>无法监听新增&#x2F;删除属性（所以使用Vue的set和delete方法）</li><li>无法监听原生数组，需要特殊处理</li></ul><h3 id="数组监听"><a href="#数组监听" class="headerlink" title="数组监听"></a>数组监听</h3><h4 id="对数组进行重新定义"><a href="#对数组进行重新定义" class="headerlink" title="对数组进行重新定义"></a>对数组进行重新定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 重新定义数组原型</span><br><span class="hljs-keyword">const</span> oldArrayProperty = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-comment">// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型</span><br><span class="hljs-keyword">const</span> arrProto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(oldArrayProperty);<br>[<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">methodName</span> =&gt;</span> &#123;<br>    arrProto[methodName] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">updateView</span>() <span class="hljs-comment">// 触发视图更新</span><br>        <span class="hljs-comment">// 在执行updateView后，任然能够继续执行数组对象原有的方法</span><br>        oldArrayProperty[methodName].<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...<span class="hljs-variable language_">arguments</span>)<br>        <span class="hljs-comment">// 污染全局</span><br>        <span class="hljs-comment">// Array.prototype.push.call(this, ...arguments)</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="修改observer"><a href="#修改observer" class="headerlink" title="修改observer"></a>修改observer</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">observer</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 不是对象或数组</span><br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 污染全局的 Array 原型</span><br>    <span class="hljs-comment">// Array.prototype.push = function () &#123;</span><br>    <span class="hljs-comment">//     updateView()</span><br>    <span class="hljs-comment">//     ...</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target)) &#123;<br>        target.<span class="hljs-property">__proto__</span> = arrProto<br>    &#125;<br><br>    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;<br>        <span class="hljs-title function_">defineReactive</span>(target, key, target[key])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue和MVVM</title>
    <link href="/2020/01/12/Vue%E5%92%8CMVVM/"/>
    <url>/2020/01/12/Vue%E5%92%8CMVVM/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><h3 id="Vue-js是什么"><a href="#Vue-js是什么" class="headerlink" title="Vue.js是什么"></a>Vue.js是什么</h3><ul><li>Vue.js 是一个轻巧、高性能、可组件化的 MVVM 库，拥有非常容易上手的 API；</li><li>Vue.js是一个构建数据驱动的 Web 界面的库。</li></ul><span id="more"></span><h3 id="Vue-js-的特性"><a href="#Vue-js-的特性" class="headerlink" title="Vue.js 的特性"></a>Vue.js 的特性</h3><ol><li>轻量级的框架</li><li>双向数据绑定</li><li>指令</li><li>插件化（组件化）</li></ol><h3 id="MVVM-框架"><a href="#MVVM-框架" class="headerlink" title="MVVM 框架"></a>MVVM 框架</h3><ul><li>MVVM（Model-View-ViewModel）是对 MVC（Model-View-Control）和 MVP（Model-View-Presenter）的进一步改进。<blockquote><p>『View』：视图层（UI 用户界面）</p></blockquote></li></ul><blockquote><p>『ViewModel』：业务逻辑层（一切 js 可视为业务逻辑）</p></blockquote><blockquote><p>『Model』：数据层（存储数据及对数据的处理如增删改查）</p></blockquote><ul><li>MVVM 将数据双向绑定（data-binding）作为核心思想，View 和 Model 之间没有联系，它们通过 ViewModel 这个桥梁进行交互。</li><li>Model 和 ViewModel 之间的交互是双向的，因此 View 的变化会自动同步到 Model，而 Model 的变化也会立即反映到 View 上显示。</li><li>当用户操作 View，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。</li><li>Angular 和 Ember 都采用这种模式。</li></ul><h3 id="Vue-的开发模式"><a href="#Vue-的开发模式" class="headerlink" title="Vue 的开发模式"></a>Vue 的开发模式</h3><ul><li>通过 script 标签直接引入 vue.js</li><li>通过 Vue 的脚手架工具 vue-cli 来进行一键项目搭建</li></ul><h3 id="Vue-js-的优点"><a href="#Vue-js-的优点" class="headerlink" title="Vue.js 的优点"></a>Vue.js 的优点</h3><ul><li>简单轻巧，功能强大，拥有非常容易上手的 API；</li><li>可组件化 和 响应式设计；</li><li>实现数据与结构分离，高性能，易于浏览器的加载速度；</li><li>MVVM 模式，数据双向绑定，减少了 DOM 操作，将更多精力放在数据和业务逻辑上。</li></ul><h3 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h3><ul><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 “View” 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>方便测试。界面素来是比较难于测试的，开发中大部分 Bug 来至于逻辑处理，由于 ViewModel 分离了许多逻辑，可以对 ViewModel 构造单元测试。</li><li>易用 灵活 高效。</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="JQuery和MVVM的区别"><a href="#JQuery和MVVM的区别" class="headerlink" title="JQuery和MVVM的区别"></a>JQuery和MVVM的区别</h3><ul><li>数据和视图的分离，解耦（开放封闭原则）</li><li>以数据驱动视图，只关心数据变化，DOM操作被封装</li></ul><h3 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h3><ul><li>MVVM 是 Model-View-ViewModel 的缩写。MVVM 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。</li><li>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</li><li>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</li></ul><h2 id="Vue和MVVM"><a href="#Vue和MVVM" class="headerlink" title="Vue和MVVM"></a>Vue和MVVM</h2><ul><li>响应式：vue如何监听到data的每个属性变化？</li><li>模板引擎：vue的模板如何被解析，指令如何处理？</li><li>渲染：vue的模板如何被渲染成html？以及渲染过程</li></ul><h3 id="vue中如何实现响应式"><a href="#vue中如何实现响应式" class="headerlink" title="vue中如何实现响应式"></a>vue中如何实现响应式</h3><h4 id="什么是响应式"><a href="#什么是响应式" class="headerlink" title="什么是响应式"></a>什么是响应式</h4><ul><li>修改data属性后，vue立刻监听到</li><li>data属性被代理到vm上</li></ul><h3 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h3><p><strong>实现响应式的核心函数</strong></p><blockquote><p>Object.defineProperty(obj, prop, desc)的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性<br>模板中没有的数据，不会走get监听，所以也不会走set监听，Object.defineProperty的原则是走get才会走set,防止无用的数据重复渲染。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = &#123;&#125;<br><span class="hljs-keyword">var</span> data = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-keyword">var</span> key, value<br><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> data) &#123;<br>    (<span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;<br>        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(vm, key, &#123;<br>            <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get&#x27;</span>, data[key]) <span class="hljs-comment">// 监听</span><br>                <span class="hljs-keyword">return</span> data[key]<br>            &#125;,<br>            <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set&#x27;</span>, newVal) <span class="hljs-comment">// 监听</span><br>                data[key] = newVal<br>            &#125;<br>        &#125;)<br>    &#125;)(key)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vue中如何解析模板"><a href="#vue中如何解析模板" class="headerlink" title="vue中如何解析模板"></a>vue中如何解析模板</h3><h4 id="模板是什么？"><a href="#模板是什么？" class="headerlink" title="模板是什么？"></a>模板是什么？</h4><ul><li>本质：字符串</li><li>有逻辑，如v-if v-for等</li><li>与html很像，但有很大区别</li><li>最终还要转化成html来显示</li><li>模板最终要装换成js代码（render函数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//模板</span><br>    &lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;price&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    &lt;/div&gt;<br><span class="hljs-comment">//render函数</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">with</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;  <span class="hljs-comment">// this 就是 vm</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<br>                    <span class="hljs-string">&#x27;div&#x27;</span>,<br>                    &#123;<br>                        <span class="hljs-attr">attrs</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;app&#x27;</span>&#125;<br>                    &#125;,<br>                    [<br>                        <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;p&#x27;</span>, [<span class="hljs-title function_">_v</span>(<span class="hljs-title function_">_s</span>(price))])<br>                    ]<br>                )<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//在vue源码中搜索code.render，然后alert(code.render)可以看render函数</span><br></code></pre></td></tr></table></figure><ul><li>h函数生成vdom</li><li>patch函数渲染成dom</li></ul><hr><ul><li>h函数就是vue中的createElement方法，这个函数作用就是创建虚拟dom，追踪dom变化的</li></ul><h3 id="vue的整个实现流程"><a href="#vue的整个实现流程" class="headerlink" title="vue的整个实现流程"></a>vue的整个实现流程</h3><ol><li>解析模板成render函数</li><li>响应式开始监听</li><li>首次渲染，显示页面，且绑定依赖</li><li>data属性变化，触发rerender</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2020/01/01/VueRouter/"/>
    <url>/2020/01/01/VueRouter/</url>
    
    <content type="html"><![CDATA[<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><ul><li>hash</li><li>history<span id="more"></span></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>带＃</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>需要server支持</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>:[<br>        <span class="hljs-comment">// 动态路径参数 以冒号开头。命中/user/10等格式路由</span><br>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-attr">component</span>:<span class="hljs-title class_">User</span>&#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br> <span class="hljs-attr">routes</span>: [<br> &#123;<br> <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Navigator&#x27;</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>)<br> &#125;,<br> &#123;<br> <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/tucao&#x27;</span>,<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tucao&#x27;</span>,<br> <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;tucao&quot; */</span> <span class="hljs-string">&#x27;./../components/Tucao&#x27;</span>)<br> &#125;<br> ]<br></code></pre></td></tr></table></figure><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由钩子函数有三种：</p><ol><li><p>全局钩子： beforeEach、 afterEach</p></li><li><p>单个路由里面的钩子： beforeEnter、 beforeLeave</p></li><li><p>组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</p></li></ol><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>无论访问哪一个路径，都会触发全局的钩子函数，位置是调用router的方法</p><p><strong>router.beforeEach() 进入之前触发</strong></p><p><strong>router.afterEach() 进入之后触发</strong></p><h4 id="beforeEach（全局前置守卫）"><a href="#beforeEach（全局前置守卫）" class="headerlink" title="beforeEach（全局前置守卫）"></a>beforeEach（全局前置守卫）</h4><p>使用 router.beforeEach 注册一个全局前置守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    。。。<br>&#125;)<br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>每个守卫方法接收三个参数：</p><ul><li>to: Route: 即将要进入的目标路由对象（to是一个对象，是将要进入的路由对象，可以用to.path调用路由对象中的属性）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 这是一个必须需要调用的方法，执行效果依赖 next 方法的调用参数。</li></ul><h5 id="next参数"><a href="#next参数" class="headerlink" title="next参数"></a>next参数</h5><ul><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed (确认的)。</li><li>next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按 钮)，那么 URL 地址会重置到 from 路由对应的地址。</li><li>next(‘&#x2F;‘) 或者 next({ path: ‘&#x2F;‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在router-link 的 to prop或router.push中的选项。</li><li>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调。</li></ul><blockquote><p>确保要调用 next 方法，否则钩子就不会被 resolved。</p></blockquote><h4 id="afterEach（全局后置钩子）"><a href="#afterEach（全局后置钩子）" class="headerlink" title="afterEach（全局后置钩子）"></a>afterEach（全局后置钩子）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    。。。<br>&#125;)<br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</p><h4 id="路由独享的守卫-单个路由独享的"><a href="#路由独享的守卫-单个路由独享的" class="headerlink" title="路由独享的守卫(单个路由独享的)"></a>路由独享的守卫(单个路由独享的)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br> <span class="hljs-attr">routes</span>: [<br> &#123;<br> <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Navigator&#x27;</span>,<br> router.<span class="hljs-title function_">beforeEnter</span>(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    ...<br> &#125;),<br> <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>)<br> &#125;<br> ]<br></code></pre></td></tr></table></figure><h4 id="组件级路由钩子"><a href="#组件级路由钩子" class="headerlink" title="组件级路由钩子"></a>组件级路由钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><br>data,<br><br>methods<br><br><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params"></span>)&#123;<br><br>   <span class="hljs-comment">// this 不指向实例 组件还没创建</span><br><br>    <span class="hljs-title function_">next</span>(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span>&#123;<br><br>        <span class="hljs-comment">// vm就是实例</span><br><br>    &#125;)<br><br>&#125;<br><br><span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2020/01/01/VueRouter/luyou1.png" alt="image"><br>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><p><img src="/2020/01/01/VueRouter/luyou2.png" alt="image"></p><p>注意~ ： beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p><p>这个离开守卫beforeRouteLeave()通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p><p><img src="/2020/01/01/VueRouter/luyou3.png" alt="image"></p><h4 id="完整的导航解析流程："><a href="#完整的导航解析流程：" class="headerlink" title="完整的导航解析流程："></a>完整的导航解析流程：</h4><ol><li><p>导航被触发。</p></li><li><p>在失活的组件里调用离开守卫。</p></li><li><p>调用全局的 beforeEach 守卫。</p></li><li><p>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p></li><li><p>在路由配置里调用 beforeEnter。</p></li><li><p>解析异步路由组件。</p></li><li><p>在被激活的组件里调用 beforeRouteEnter。</p></li><li><p>调用全局的 beforeResolve 守卫 (2.5+)。</p></li><li><p>导航被确认。</p></li><li><p>调用全局的 afterEach 钩子。</p></li><li><p>触发 DOM 更新。</p></li><li><p>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vuex</title>
    <link href="/2019/12/06/Vuex/"/>
    <url>/2019/12/06/Vuex/</url>
    
    <content type="html"><![CDATA[<h2 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h2><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态(你可以理解成 vue 组件里的某些 data )。</p><p>Vue有五个核心概念：</p><ul><li>state：基本数据</li><li>getters：从基本数据派生的数据 </li><li>mutations：提交更改数据的方法，同步！ </li><li>actions：像一个装饰器，包裹mutations，使之可以异步。 </li><li>modules：模块化Vuex<span id="more"></span></li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>state即Vuex中的基本数据</p><h3 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h3><p>Vuex使用单一状态树，即用一个对象就包含了全部的状态数据。state作为构造器选项，定义了所有我们需要的基本状态参数。</p><h3 id="在Vue组件中获得Vuex属性"><a href="#在Vue组件中获得Vuex属性" class="headerlink" title="在Vue组件中获得Vuex属性"></a>在Vue组件中获得Vuex属性</h3><p>我们可以通过Vue的Computed获得Vuex的state，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">0</span><br>    &#125;<br>&#125;)<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-comment">//..</span><br>    store,<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">//..</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p><h3 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h3><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span><br><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">computed</span>: <span class="hljs-title function_">mapState</span>(&#123;<br>    <span class="hljs-comment">// 箭头函数可使代码更简练</span><br>    <span class="hljs-attr">count</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span>,<br><br>    <span class="hljs-comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span><br>    <span class="hljs-attr">countAlias</span>: <span class="hljs-string">&#x27;count&#x27;</span>,<br><br>    <span class="hljs-comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span><br>    <span class="hljs-title function_">countPlusLocalState</span> (state) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">localCount</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: <span class="hljs-title function_">mapState</span>([<br>  <span class="hljs-comment">// 映射 this.count 为 store.state.count</span><br>  <span class="hljs-string">&#x27;count&#x27;</span><br>])<br></code></pre></td></tr></table></figure><h3 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h3><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">localComputed</span> () <span class="hljs-comment">//本地计算属性</span><br>  <span class="hljs-comment">//使用对象展开运算符将此对象混入到外部对象中</span><br>  ...<span class="hljs-title function_">mapState</span>(&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>… 展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p><p>展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。</p><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>即从store的state中派生出的状态。</p><p>getters接收state作为其第一个参数，接受其他 getters 作为第二个参数，如不需要，第二个参数可以省略如下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>    <span class="hljs-attr">state</span>: &#123;<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">0</span><br>    &#125;，<br>    <span class="hljs-attr">getters</span>: &#123;<br>        <span class="hljs-comment">// 单个参数</span><br>        <span class="hljs-attr">countDouble</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>)&#123;<br>            <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>        &#125;,<br>        <span class="hljs-comment">// 两个参数</span><br>        <span class="hljs-attr">countDoubleAndDouble</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">state, getters</span>) &#123;<br>            <span class="hljs-keyword">return</span> getters.<span class="hljs-property">countDouble</span> * <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>与state一样，我们也可以通过Vue的Computed获得Vuex的getters。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-comment">//..</span><br>    store,<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-attr">count</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span><br>        &#125;,<br>        <span class="hljs-attr">countDouble</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">countDouble</span><br>        &#125;,<br>        <span class="hljs-attr">countDoubleAndDouble</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">countDoubleAndDouble</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">//..</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h3><p>mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，与state类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span><br>    ...<span class="hljs-title function_">mapGetters</span>([<br>      <span class="hljs-string">&#x27;countDouble&#x27;</span>,<br>      <span class="hljs-string">&#x27;CountDoubleAndDouble&#x27;</span>,<br>      <span class="hljs-comment">//..</span><br>    ])<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mapGetters</span>(&#123;<br>  <span class="hljs-comment">// 映射 this.double 为 store.getters.countDouble</span><br>  <span class="hljs-attr">double</span>: <span class="hljs-string">&#x27;countDouble&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2><p>提交mutation是更改Vuex中的store中的状态的唯一方法。</p><p>mutation必须是同步的，如果要异步需要使用action。</p><p>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。（提交荷载在大多数情况下应该是一个对象）,提交荷载也可以省略的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-comment">//无提交荷载</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>        state.<span class="hljs-property">count</span>++<br>    &#125;<br>    <span class="hljs-comment">//提交荷载</span><br>    <span class="hljs-title function_">incrementN</span>(<span class="hljs-params">state, obj</span>) &#123;<br>      state.<span class="hljs-property">count</span> += obj.<span class="hljs-property">n</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//无提交荷载</span><br>store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br><span class="hljs-comment">//提交荷载</span><br>store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;incrementN&#x27;</span>, &#123;<br>    <span class="hljs-attr">n</span>: <span class="hljs-number">100</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>我们也可以使用这样包含 type 属性的对象的提交方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">store.<span class="hljs-title function_">commit</span>(&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;incrementN&#x27;</span>,<br>  <span class="hljs-attr">n</span>: <span class="hljs-number">10</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Mutations-需遵守-Vue-的响应规则"><a href="#Mutations-需遵守-Vue-的响应规则" class="headerlink" title="Mutations 需遵守 Vue 的响应规则"></a>Mutations 需遵守 Vue 的响应规则</h3><ul><li>最好提前在你的 store 中初始化好所有所需属性。</li><li>当需要在对象上添加新属性时，你应该<br>使用 Vue.set(obj, ‘newProp’, 123), 或者<br>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写state.obj &#x3D; {…state.obj, newProp: 123 }</li></ul><h3 id="mapMutations-辅助函数"><a href="#mapMutations-辅助函数" class="headerlink" title="mapMutations 辅助函数"></a>mapMutations 辅助函数</h3><p>与其他辅助函数类似，你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...<span class="hljs-title function_">mapMutations</span>([<br>      <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 映射 this.increment() 为 this.$store.commit(&#x27;increment&#x27;)</span><br>    ]),<br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<br>      <span class="hljs-attr">add</span>: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 映射 this.add() 为 this.$store.commit(&#x27;increment&#x27;)</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h2><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span> (state) &#123;<br>      state.<span class="hljs-property">count</span>++<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">increment</span> (context) &#123;<br>      <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><h3 id="分发actions"><a href="#分发actions" class="headerlink" title="分发actions"></a>分发actions</h3><p>Action 通过 store.dispatch 方法触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="其他与mutations类似的地方"><a href="#其他与mutations类似的地方" class="headerlink" title="其他与mutations类似的地方"></a>其他与mutations类似的地方</h3><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 以载荷形式分发</span><br>store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementN&#x27;</span>, &#123;<br>  <span class="hljs-attr">n</span>: <span class="hljs-number">10</span><br>&#125;)<br><br><span class="hljs-comment">// 以对象形式分发</span><br>store.<span class="hljs-title function_">dispatch</span>(&#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;incrementN&#x27;</span>,<br>  <span class="hljs-attr">n</span>: <span class="hljs-number">10</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="mapActions辅助函数"><a href="#mapActions辅助函数" class="headerlink" title="mapActions辅助函数"></a>mapActions辅助函数</h3><p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-attr">methods</span>: &#123;<br>    ...<span class="hljs-title function_">mapActions</span>([<br>      <span class="hljs-string">&#x27;incrementN&#x27;</span> <span class="hljs-comment">//映射 this.incrementN() 为 this.$store.dispatch(&#x27;incrementN&#x27;)</span><br>    ]),<br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<br>      <span class="hljs-attr">add</span>: <span class="hljs-string">&#x27;incrementN&#x27;</span> <span class="hljs-comment">//映射 this.add() 为 this.$store.dispatch(&#x27;incrementN&#x27;)</span><br>    &#125;)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-attr">state</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">getters</span>: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> moduleB = &#123;<br>  <span class="hljs-attr">state</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123; ... &#125;,<br>  <span class="hljs-attr">actions</span>: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    <span class="hljs-attr">a</span>: moduleA,<br>    <span class="hljs-attr">b</span>: moduleB<br>  &#125;<br>&#125;)<br><br>store.<span class="hljs-property">state</span>.<span class="hljs-property">a</span> <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.<span class="hljs-property">state</span>.<span class="hljs-property">b</span> <span class="hljs-comment">// -&gt; moduleB 的状态</span><br></code></pre></td></tr></table></figure><h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态,对于模块内部的 getter，根节点状态会作为第三个参数:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-keyword">state</span>: &#123; count: <span class="hljs-number">0</span> &#125;,<br>  mutations: &#123;<br>    increment (<span class="hljs-keyword">state</span>) &#123;<br>      // <span class="hljs-keyword">state</span> 模块的局部状态<br>      <span class="hljs-keyword">state</span>.count++<br>    &#125;<br>  &#125;,<br><br>  getters: &#123;<br>    doubleCount (<span class="hljs-keyword">state</span>) &#123;<br>      return <span class="hljs-keyword">state</span>.count * <span class="hljs-number">2</span><br>    &#125;,<br>    sumWithRootCount (<span class="hljs-keyword">state</span>, getters, rootState) &#123;<br>      return <span class="hljs-keyword">state</span>.count + rootState.count<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样，对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">incrementIfOddOnRootSum</span> (context) &#123;<br>      <span class="hljs-keyword">if</span> ((context.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + context.<span class="hljs-property">rootState</span>.<span class="hljs-property">count</span>) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_35955795/article/details/57412181">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件的高级特性</title>
    <link href="/2019/11/21/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2019/11/21/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="自定义v-model"><a href="#自定义v-model" class="headerlink" title="自定义v-model"></a>自定义v-model</h2><h4 id="model-vue"><a href="#model-vue" class="headerlink" title="model.vue"></a>model.vue</h4><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 例如：vue 颜色选择 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;text1&quot;</span></span><br><span class="hljs-tag">        @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;change1&#x27;, $event.target.value)&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        1. 上面的 input 使用了 :value 而不是 v-model</span><br><span class="hljs-comment">        2. 上面的 change1 和 model.event1 要对应起来</span><br><span class="hljs-comment">        3. text1 属性对应起来</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">model</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;text1&#x27;</span>, <span class="hljs-comment">// 对应 props text1</span></span><br><span class="language-javascript">        <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;change1&#x27;</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">text1</span>: <span class="hljs-title class_">String</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">CustomVModel</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ul1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            &#123;&#123;item&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addItem&quot;</span>&gt;</span>添加一项<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;app&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">list</span>: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">addItem</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 1. 异步渲染，$nextTick 待 DOM 渲染完再回调</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 获取 DOM 元素</span></span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> ulElem = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">ul1</span></span><br><span class="language-javascript">          <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( ulElem.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> )</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="slot（插槽）"><a href="#slot（插槽）" class="headerlink" title="slot（插槽）"></a>slot（插槽）</h2><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><br>            默认内容，即父组件没设置内容时，这里显示<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;url&#x27;</span>],</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;&#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="父组件使用时"><a href="#父组件使用时" class="headerlink" title="父组件使用时"></a>父组件使用时</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">SlotDemo</span> <span class="hljs-attr">:url</span>=<span class="hljs-string">&quot;website.url&quot;</span>&gt;</span><br>   &#123;&#123;website.title&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">SlotDemo</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="scope-slot"><a href="#scope-slot" class="headerlink" title="scope slot"></a>scope slot</h3><h4 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:slotData</span>=<span class="hljs-string">&quot;website&quot;</span>&gt;</span><br>            &#123;&#123;website.subTitle&#125;&#125; <span class="hljs-comment">&lt;!-- 默认值显示 subTitle ，即父组件不传内容时 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;url&#x27;</span>],</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">website</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://wangEditor.com/&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;wangEditor&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">subTitle</span>: <span class="hljs-string">&#x27;轻量级富文本编辑器&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ScopedSlotDemo</span> <span class="hljs-attr">:url</span>=<span class="hljs-string">&quot;website.url&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>        &#123;&#123;slotProps.slotData.title&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ScopedSlotDemo</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="动态、异步组件"><a href="#动态、异步组件" class="headerlink" title="动态、异步组件"></a>动态、异步组件</h2><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;xxxx(组件名称)&quot;</span>/&gt;</span><br>// 此处需要写动态的名字（在data中绑定）<br></code></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-title class_">FormDemo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../BaseUse/FormDemo&#x27;</span>)<br>      &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-title class_">FormDemo</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../BaseUse/FormDemo&#x27;</span>)<br>  &#125;,<br></code></pre></td></tr></table></figure><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><ul><li>vue内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM</li><li>keep-alive是用在一个直属子组件被开关的情形，同时只有一个子组件在渲染，若有v-for则不会工作</li></ul><p>注：keep-alive是一个抽象组件，自身不会渲染一个DOM元素，也不会出现在父组件链中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span> <span class="hljs-comment">&lt;!-- tab 切换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">KeepAliveStageA</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;state === &#x27;A&#x27;&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- v-show --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">KeepAliveStageB</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;state === &#x27;B&#x27;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">KeepAliveStageC</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;state === &#x27;C&#x27;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure><p>区别：</p><ul><li>v-if在切换过程中会销毁并创建</li><li>v-show在首次加载组件时，会三个同时创建</li><li>keep-alive会在在切换时候创建，但是不会销毁</li></ul><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><h3 id="mixin-js"><a href="#mixin-js" class="headerlink" title="mixin.js"></a>mixin.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;北京&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">showName</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">// eslint-disable-next-line</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// eslint-disable-next-line</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mixin mounted&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;name&#125;&#125; &#123;&#123;major&#125;&#125; &#123;&#123;city&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showName&quot;</span>&gt;</span>显示姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> myMixin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mixin&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">mixins</span>: [myMixin], <span class="hljs-comment">// 可以添加多个，会自动合并起来</span></span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;双越&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">major</span>: <span class="hljs-string">&#x27;web 前端&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;component mounted&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>mixin对象则local对象覆盖mixin对象</li><li>生命周期钩子函数则是合并执行，先执行mixin后执行local</li></ul><h3 id="mixin的问题"><a href="#mixin的问题" class="headerlink" title="mixin的问题"></a>mixin的问题</h3><ul><li>变量来源不明确，不利于阅读</li><li>多mixin可能造成命名冲突</li><li>mixin和组件可能出现多对多的关系，复杂度高</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件通讯</title>
    <link href="/2019/11/11/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <url>/2019/11/11/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="prop和-emit"><a href="#prop和-emit" class="headerlink" title="prop和$emit"></a>prop和$emit</h2><span id="more"></span><h3 id="index-vue"><a href="#index-vue" class="headerlink" title="index.vue"></a>index.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Input</span> @<span class="hljs-attr">add</span>=<span class="hljs-string">&quot;addHandler&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">List</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;list&quot;</span> @<span class="hljs-attr">delete</span>=<span class="hljs-string">&quot;deleteHandler&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Input</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Input&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./List&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title class_">Input</span>,</span><br><span class="language-javascript">        <span class="hljs-title class_">List</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">list</span>: [</span><br><span class="language-javascript">                &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id-1&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span></span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id-2&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            ]</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">addHandler</span>(<span class="hljs-params">title</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">id</span>: <span class="hljs-string">`id-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span>,</span><br><span class="language-javascript">                title</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">deleteHandler</span>(<span class="hljs-params">id</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> !== id)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;index created&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;index mounted&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;index before update&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;index updated&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="input-vue"><a href="#input-vue" class="headerlink" title="input.vue"></a>input.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;title&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addTitle&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> event <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">addTitle</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 调用父组件的事件</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 调用自定义事件</span></span><br><span class="language-javascript">            event.$emit(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="list-vue"><a href="#list-vue" class="headerlink" title="list.vue"></a>list.vue</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>                &#123;&#123;item.title&#125;&#125;<br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;deleteItem(item.id)&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> event <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// props: [&#x27;list&#x27;]</span></span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// prop 类型和默认值</span></span><br><span class="language-javascript">        <span class="hljs-attr">list</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><br><span class="language-javascript">            <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> []</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">deleteItem</span>(<span class="hljs-params">id</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;delete&#x27;</span>, id)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">addTitleHandler</span>(<span class="hljs-params">title</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;on add title&#x27;</span>, title)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;list created&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;list mounted&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 绑定自定义事件</span></span><br><span class="language-javascript">        event.$on(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTitleHandler</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;list before update&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;list updated&#x27;</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 及时销毁，否则可能造成内存泄露</span></span><br><span class="language-javascript">        event.$off(<span class="hljs-string">&#x27;onAddTitle&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">addTitleHandler</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="event-js"><a href="#event-js" class="headerlink" title="event.js"></a>event.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br><br></code></pre></td></tr></table></figure><p><strong>在组件销毁时，需要销毁自定义事件。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础二</title>
    <link href="/2019/11/01/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>/2019/11/01/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h2><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历数组<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in listArr&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>                &#123;&#123;index&#125;&#125; - &#123;&#123;item.id&#125;&#125; - &#123;&#123;item.title&#125;&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历对象<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val, key, index) in listObj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span><br>                &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; -  &#123;&#123;val.title&#125;&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">flag</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">listArr</span>: [</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;, <span class="hljs-comment">// 数据结构中，最好有 id ，方便使用 key</span></span><br><span class="language-javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><br><span class="language-javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;</span><br><span class="language-javascript">            ],</span><br><span class="language-javascript">            <span class="hljs-attr">listObj</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;,</span><br><span class="language-javascript">                <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><br><span class="language-javascript">                <span class="hljs-attr">c</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;,</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>v-for不光能遍历数组，也可以遍历对象</li><li>v-for和v-if不能同时使用</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment1&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment2(2, $event)&quot;</span>&gt;</span>+2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">num</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">increment1</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event&#x27;</span>, event, event.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>) <span class="hljs-comment">// 是原生的 event 对象</span></span><br><span class="language-javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)</span><br><span class="language-javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">currentTarget</span>) <span class="hljs-comment">// 注意，事件是被注册到当前元素的，和 React 不一样</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 1. event 是原生的</span></span><br><span class="language-javascript">            <span class="hljs-comment">// 2. 事件被挂载到当前元素</span></span><br><span class="language-javascript">            <span class="hljs-comment">// 和 DOM 事件一样</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">increment2</span>(<span class="hljs-params">val, event</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> + val</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">loadHandler</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// do some thing</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadHandler</span>)</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//【注意】用 vue 绑定的事件，组建销毁时会自动被解绑</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 自己绑定的事件，需要自己销毁！！！</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">loadHandler</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入框: &#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多行文本: &#123;&#123;desc&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 注意，&lt;textarea&gt;&#123;&#123;desc&#125;&#125;&lt;/textarea&gt; 是不允许的！！！ --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>复选框 &#123;&#123;checked&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多个复选框 &#123;&#123;checkedNames&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>单选 &#123;&#123;gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择 &#123;&#123;selected&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择（多选） &#123;&#123;selectedList&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selectedList&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;双越&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;自我介绍&#x27;</span>,</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">checkedNames</span>: [],</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">selectedList</span>: []</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端错误监控</title>
    <link href="/2019/10/21/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
    <url>/2019/10/21/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h2><p>一般来说前端错误分为两类</p><ol><li>即时运行错误</li><li>资源加载错误</li></ol><span id="more"></span><h2 id="错误捕获方式"><a href="#错误捕获方式" class="headerlink" title="错误捕获方式"></a>错误捕获方式</h2><h3 id="即时运行错误"><a href="#即时运行错误" class="headerlink" title="即时运行错误"></a>即时运行错误</h3><ol><li>try catch</li><li>window.onerror</li></ol><h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><p><strong>资源加载错误不会冒泡，所以window.onerror捕获不到</strong></p><ol><li>object.onerror</li><li>performance.getEntries()（获取所有加载资源）</li><li>Error事件捕获<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>错误监控<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;捕获&#x27;</span>, e);</span><br><span class="language-javascript">      &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//badu.com/test.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol><h4 id="跨域js的运行错误"><a href="#跨域js的运行错误" class="headerlink" title="跨域js的运行错误"></a>跨域js的运行错误</h4><p><strong>所有跨域js的运行错误都会显示为Script error</strong><br>解决方法：</p><ol><li>在script标签上增加crossorigin属性(客户端)</li><li>设置资源响应头Access-Control-Allow-Origin:*（服务端）</li></ol><h2 id="上报错误"><a href="#上报错误" class="headerlink" title="上报错误"></a>上报错误</h2><h3 id="用ajax通信上报"><a href="#用ajax通信上报" class="headerlink" title="用ajax通信上报"></a>用ajax通信上报</h3><p>不建议这么来做</p><h3 id="利用Image对象进行上报"><a href="#利用Image对象进行上报" class="headerlink" title="利用Image对象进行上报"></a>利用Image对象进行上报</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">     (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()).<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://baidu.com/tesjk?r=tksjk&#x27;</span>;</span><br><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>很容易实现请求，比ajax方便的多</p>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础一</title>
    <link href="/2019/10/20/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>/2019/10/20/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>文本插值 &#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>JS 表达式 &#123;&#123; flag ? &#x27;yes&#x27; : &#x27;no&#x27; &#125;&#125; （只能是表达式，不能是 js 语句）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span>动态属性 id<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>有 xss 风险<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>【注意】使用 v-html 之后，将会覆盖子元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 其他常用指令后面讲 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">rawHtml</span>: <span class="hljs-string">&#x27;指令 - 原始 html &lt;b&gt;加粗&lt;/b&gt; &lt;i&gt;斜体&lt;/i&gt;&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">dynamicId</span>: <span class="hljs-string">`id-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>一个计算属性,类似于过滤器,对绑定到view的数据进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: &#123;<br>   <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>   <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Bar&#x27;</span><br> &#125;,<br> <span class="hljs-attr">computed</span>: &#123;<br>   <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>fullName不可在data里面定义</strong></p><h4 id="get和set用法"><a href="#get和set用法" class="headerlink" title="get和set用法"></a>get和set用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Bar&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>  fullName：&#123;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//回调函数 当需要读取当前属性值是执行，根据相关数据计算并返回当前属性的值</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>    &#125;,<br>   <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;<span class="hljs-comment">//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据</span><br>       <span class="hljs-comment">//val就是fullName的最新属性值</span><br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)<br>        <span class="hljs-keyword">const</span> names = val.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(names)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = names[<span class="hljs-number">0</span>];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = names[<span class="hljs-number">1</span>];<br>   &#125;<br>   &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>computed有缓存，data不变则不会重新计算</strong></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch是一个观察的动作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Bar&#x27;</span>,<br>    <span class="hljs-attr">fullName</span>: <span class="hljs-string">&#x27;Foo Bar&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>     <span class="hljs-attr">firstName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>  &#125;,<br>  <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + val<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-string">&#x27;first&#x27;</span>:<span class="hljs-number">2</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">watch</span>:&#123;<br>      <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>)<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-string">&#x27;first&#x27;</span>:&#123;<br>          <span class="hljs-attr">second</span>:<span class="hljs-number">0</span><br>        &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">watch</span>:&#123;<br>      <span class="hljs-attr">secondChange</span>:&#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">oldVal,newVal</span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(oldVal)<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal)<br>        &#125;,<br>        <span class="hljs-attr">deep</span>:<span class="hljs-literal">true</span><br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><ul><li><p><strong>console.log打印的结果,发现oldVal和newVal值是一样的,所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化（只针对引用类型）</strong></p></li><li><p>oldVal和newVal值一样的原因是它们索引同一个对象&#x2F;数组。Vue <strong>不会保留修改之前值的副本</strong></p></li><li><p>深度监听对应的函数名必须为handler,否则无效果,因为watcher里面对应的是对handler的调用</p></li></ul><h4 id="监听对象单个属性"><a href="#监听对象单个属性" class="headerlink" title="监听对象单个属性"></a>监听对象单个属性</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">first</span>: &#123;<br>      <span class="hljs-attr">second</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;;<br>&#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-string">&quot;first.second&quot;</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>用computed作为中间件转化,因为computed可以取到对应的属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">first</span>: &#123;<br>      <span class="hljs-attr">second</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;;<br>&#125;,<br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">secondChange</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">first</span>.<span class="hljs-property">second</span>;<br>  &#125;<br>&#125;,<br><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-title function_">secondChange</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;second属性值变化了&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="computed特性"><a href="#computed特性" class="headerlink" title="computed特性"></a>computed特性</h4><ol><li>是计算值</li><li>应用：就是简化tempalte里面双花括号计算和处理props或$emit的传值</li><li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li></ol><h4 id="watch特性"><a href="#watch特性" class="headerlink" title="watch特性"></a>watch特性</h4><ol><li>是观察的动作</li><li>应用：监听props，$emit或本组件的值执行异步操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol><h2 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h2><ul><li>使用动态属性</li><li>使用驼峰式写法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; black: isBlack, yellow: isYellow &#125;&quot;</span>&gt;</span>使用 class<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[black, yellow]&quot;</span>&gt;</span>使用 class （数组）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleData&quot;</span>&gt;</span>使用 style<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">isBlack</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">isYellow</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-attr">black</span>: <span class="hljs-string">&#x27;black&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">yellow</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>,</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-attr">styleData</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;40px&#x27;</span>, <span class="hljs-comment">// 转换为驼峰式</span></span><br><span class="language-javascript">                <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#ccc&#x27;</span> <span class="hljs-comment">// 转换为驼峰式</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.black</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#999</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.yellow</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>other<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;a&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><ul><li>v-if是false时候不会渲染dom，v-show则是display:none</li><li>频繁切换使用v-show,不会频繁渲染dom</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面性能优化</title>
    <link href="/2019/10/11/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2019/10/11/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="页面提升性能的方法有哪些？"><a href="#页面提升性能的方法有哪些？" class="headerlink" title="页面提升性能的方法有哪些？"></a>页面提升性能的方法有哪些？</h2><ol><li>资源压缩合并，减少HTTP请求</li><li>非核心代码异步加载–&gt;异步加载的方式–&gt;异步加载的区别</li><li>利用浏览器缓存–&gt;缓存的分类–&gt;缓存的原理</li><li>使用CDN</li><li>预解析DNS<span id="more"></span></li></ol><h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><h3 id="异步加载的方式"><a href="#异步加载的方式" class="headerlink" title="异步加载的方式"></a>异步加载的方式</h3><h4 id="动态脚本加载"><a href="#动态脚本加载" class="headerlink" title="动态脚本加载"></a>动态脚本加载</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;myscript.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p><p><img src="/2019/10/11/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/youhua1.png" alt="image"></p><h3 id="异步加载的区别"><a href="#异步加载的区别" class="headerlink" title="异步加载的区别"></a>异步加载的区别</h3><ol><li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li><li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li><li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li><li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li><li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li></ol><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h3><p>浏览器的缓存分类有两个：</p><ol><li>强缓存</li><li>协商缓存</li></ol><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires: Thu, 01 Dec 1994 16:00:00 GMT<br>使用的是本地时间和服务器时间做对比</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><ol><li><p>cache-control: max-age&#x3D;xxxx，public<br>客户端和代理服务器都可以缓存该资源；<br>客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求</p></li><li><p>cache-control: max-age&#x3D;xxxx，private<br>只让客户端可以缓存该资源；代理服务器不缓存<br>客户端在xxx秒内直接读取缓存,statu code:200</p></li><li><p>cache-control: max-age&#x3D;xxxx，immutable<br>客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求</p></li><li><p>cache-control: no-cache<br>跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。</p></li><li><p>cache-control: no-store<br>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</p></li></ol><p><strong>Cache-Control优先于Expires</strong></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。</p><h4 id="Last-Modified（服务器下发值）-If-Modified-Since（浏览器请求头）"><a href="#Last-Modified（服务器下发值）-If-Modified-Since（浏览器请求头）" class="headerlink" title="Last-Modified（服务器下发值） If-Modified-Since（浏览器请求头）"></a>Last-Modified（服务器下发值） If-Modified-Since（浏览器请求头）</h4><p>Last-Modified：上次修改时间<br>每次请求加上上次返回的修改时间，服务器进行对比，如果资源正确，返回304，使用缓存。</p><h4 id="Etag（Hash值）-If-None-Match"><a href="#Etag（Hash值）-If-None-Match" class="headerlink" title="Etag（Hash值） If-None-Match"></a>Etag（Hash值） If-None-Match</h4><p>每次请求加上之前返回的hash值，如果正确，则返回304，使用缓存。</p>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事件循环EventLoop</title>
    <link href="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/"/>
    <url>/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Event-Loop"><a href="#什么是Event-Loop" class="headerlink" title="什么是Event Loop"></a>什么是Event Loop</h2><p><strong>event loop是一个执行模型，在不同的地方有不同的实现。浏览器和NodeJS基于不同的技术实现了各自的Event Loop。</strong></p><ul><li>浏览器的Event Loop是在html5的规范中明确定义。</li><li>NodeJS的Event Loop是基于libuv实现的。可以参考Node的官方文档以及libuv的官方文档。</li><li>libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。 <span id="more"></span></li></ul><h2 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h2><h3 id="宏队列"><a href="#宏队列" class="headerlink" title="宏队列"></a>宏队列</h3><p><strong>宏队列，macrotask，也叫tasks。</strong></p><p>一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate (Node独有)</li><li>requestAnimationFrame (浏览器独有)</li><li>I&#x2F;O</li><li>UI rendering (浏览器独有)</li></ul><h3 id="微队列"><a href="#微队列" class="headerlink" title="微队列"></a>微队列</h3><p><strong>微队列，microtask，也叫jobs。</strong></p><p>另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</p><ul><li>process.nextTick (Node独有)</li><li>Promise</li><li>Object.observe</li><li>MutationObserver</li></ul><h2 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h2><p><img src="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/eventloop1.png" alt="image"><br>这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：</p><ol><li>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li><li>全局Script代码执行完毕后，调用栈Stack会清空；</li><li>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</li><li>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</li><li>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</li><li>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</li><li>执行完毕后，调用栈Stack为空；</li><li>重复第3-7个步骤；</li><li>重复第3-7个步骤；</li><li>…</li></ol><p><strong>可以看到，这就是浏览器的事件循环Event Loop</strong><br>这里归纳3个重点：</p><ol><li>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；</li><li>微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空；</li><li>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 正确答案</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-number">7</span><br><span class="hljs-number">5</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">5</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  <br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>    <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;);<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9</span>);<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 正确答案</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-number">10</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">9</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>**在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。<br>**<br>注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个，后面我们会讲到。</p><p>浏览器的Event Loop就说到这里，下面我们看一下NodeJS中的Event Loop，它更复杂一些，机制也不太一样。</p><h2 id="NodeJS中的Event-Loop"><a href="#NodeJS中的Event-Loop" class="headerlink" title="NodeJS中的Event Loop"></a>NodeJS中的Event Loop</h2><p>NodeJS的Event Loop中，执行宏队列的回调任务有6个阶段，如下图：</p><p><img src="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/eventloop2.png" alt="image"></p><p>各个阶段执行的任务如下：</p><ul><li><strong>timers阶段</strong>：这个阶段执行setTimeout和setInterval预定的callback</li><li><strong>I&#x2F;O callback阶段</strong>：执行除了close事件的callbacks、被timers设定的callbacks、setImmediate()设定的callbacks这些之外的callbacks</li><li><strong>idle, prepare阶段</strong>：仅node内部使用</li><li><strong>poll阶段</strong>：获取新的I&#x2F;O事件，适当的条件下node将阻塞在这里</li><li><strong>check阶段</strong>：执行setImmediate()设定的callbacks</li><li><strong>close callbacks阶段</strong>：执行socket.on(‘close’, ….)这些callbacks</li></ul><h4 id="NodeJS中宏队列主要有4个"><a href="#NodeJS中宏队列主要有4个" class="headerlink" title="NodeJS中宏队列主要有4个"></a>NodeJS中宏队列主要有4个</h4><p>由上面的介绍可以看到，回调事件主要位于4个macrotask queue中：</p><ol><li>Timers Queue</li><li>IO Callbacks Queue</li><li>Check Queue</li><li>Close Callbacks Queue</li></ol><p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中。</p><h4 id="NodeJS中微队列主要有2个："><a href="#NodeJS中微队列主要有2个：" class="headerlink" title="NodeJS中微队列主要有2个："></a>NodeJS中微队列主要有2个：</h4><ol><li>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</li><li>Other Micro Queue：放置其他microtask，比如Promise等</li></ol><p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中。</p><p>具体可以通过下图加深一下理解：</p><p><img src="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/eventloop3.png" alt="image"></p><p>大体解释一下NodeJS的Event Loop过程：</p><ol><li>执行全局Script的同步代码</li><li>执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务</li><li>开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2</li><li>Timers Queue -&gt; 步骤2 -&gt; I&#x2F;O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue ……</li><li>这就是Node的Event Loop</li></ol><h4 id="关于NodeJS的macrotask-queue和microtask-queue"><a href="#关于NodeJS的macrotask-queue和microtask-queue" class="headerlink" title="关于NodeJS的macrotask queue和microtask queue"></a>关于NodeJS的macrotask queue和microtask queue</h4><p><img src="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/eventloop4.png" alt="image"></p><p><img src="/2019/10/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/eventloop5.png" alt="image"></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// callback1</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// callback2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-comment">// callback3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>  &#125;)<br>  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// callback4</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);  <br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-comment">// callback5</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555</span>);<br>  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// callback6</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);  <br>  &#125;)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-comment">// callback7              </span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">777</span>);<br>  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-comment">// callback8</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">888</span>);   <br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>);<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// callback9</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">999</span>);  <br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;end&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 正确答案</span><br>start<br>end<br><span class="hljs-number">999</span><br><span class="hljs-number">111</span><br><span class="hljs-number">777</span><br><span class="hljs-number">444</span><br><span class="hljs-number">888</span><br><span class="hljs-number">555</span><br><span class="hljs-number">333</span><br><span class="hljs-number">666</span><br><span class="hljs-number">222</span><br></code></pre></td></tr></table></figure><h3 id="setTimeout-对比-setImmediate"><a href="#setTimeout-对比-setImmediate" class="headerlink" title="setTimeout 对比 setImmediate"></a>setTimeout 对比 setImmediate</h3><ul><li>setTimeout(fn, 0)在Timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行</li><li>setImmediate(fn)在Check阶段执行</li></ul><p>两者的执行顺序要根据当前的执行环境才能确定：</p><ul><li>如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机</li><li>如果两者都不在主模块调用，即在一个I&#x2F;O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段</li></ul><h3 id="setImmediate-对比-process-nextTick"><a href="#setImmediate-对比-process-nextTick" class="headerlink" title="setImmediate 对比 process.nextTick"></a>setImmediate 对比 process.nextTick</h3><ul><li>setImmediate(fn)的回调任务会插入到宏队列Check Queue中</li><li>process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中</li><li>process.nextTick(fn)调用深度有限制，上限是1000，而setImmedaite则没有</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>浏览器的Event Loop和NodeJS的Event Loop是不同的，实现机制也不一样，不要混为一谈。</li><li>浏览器可以理解成只有1个宏任务队列和1个微任务队列，先执行全局Script代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和Node的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环。</li><li>NodeJS可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中依次取出所有的任务放入调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈中执行。Node 在新版本中，也是每个 Macrotask 执行完后，就去执行 Microtask 了，和浏览器的模型一致。</li><li>MacroTask包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering</li><li>Microtask包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver</li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染原理与过程</title>
    <link href="/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器如何渲染网页"><a href="#浏览器如何渲染网页" class="headerlink" title="浏览器如何渲染网页"></a>浏览器如何渲染网页</h2><h3 id="什么是DOCTYPE"><a href="#什么是DOCTYPE" class="headerlink" title="什么是DOCTYPE"></a>什么是DOCTYPE</h3><p>在w3school上是这么解释的：&lt;!DOCTYPE&gt;声明不是HTML标签，指示web浏览器关于页面使用哪个HTML版本进行编写的指令；在 HTML 4.01 中，<code>&lt;!DOCTYPE&gt;</code> 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD</p><span id="more"></span><p><strong>简而言之，&lt;!DOCTYPE&gt;规定了浏览器文档使用哪种html或者xhtml规范</strong></p><h4 id="h5中使用"><a href="#h5中使用" class="headerlink" title="h5中使用"></a>h5中使用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="HTML-4-01-Strict（严格模式）"><a href="#HTML-4-01-Strict（严格模式）" class="headerlink" title="HTML 4.01 Strict（严格模式）"></a>HTML 4.01 Strict（严格模式）</h4><p>该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="HTML-4-01-Transitional（宽松模式）"><a href="#HTML-4-01-Transitional（宽松模式）" class="headerlink" title="HTML 4.01 Transitional（宽松模式）"></a>HTML 4.01 Transitional（宽松模式）</h4><p>该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> </span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="HTML-4-01-Frameset"><a href="#HTML-4-01-Frameset" class="headerlink" title="HTML 4.01 Frameset"></a>HTML 4.01 Frameset</h4><p>该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot;</span> </span><br><span class="hljs-meta"><span class="hljs-string">&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><h5 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h5><p>Document Type Definition，中文翻译为：文档类型定义。DTD可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。因为早期的版本基于SGML，所以需要套用SGML的解析规则。DTD的作用在于定义SGML文档的文档类型以便于浏览器解析。</p><h5 id="SGML"><a href="#SGML" class="headerlink" title="SGML"></a>SGML</h5><p>Standard Generalized Markup language。标准通用标记语言（以下简称“通用标言”），是一种定义电子文档结构和描述其内容的国际标准语言。</p><p>如果没有&lt;!DOCTYPE&gt;声明，那么不同的浏览器将会以自己不同的怪异的模式去解析渲染页面，这样页面在不同的浏览器上呈现出来的效果也就不一样，人们把这称之为“怪异模式”。</p><h3 id="浏览器渲染网页过程"><a href="#浏览器渲染网页过程" class="headerlink" title="浏览器渲染网页过程"></a>浏览器渲染网页过程</h3><p>要了解浏览器渲染页面的过程，首先得知道一个名词——关键渲染路径。关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。<br>用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于<strong>DOMContentLoaded</strong>和<strong>Load</strong>。</p><ul><li><strong>DOMContentLoaded</strong>事件触发时，仅当DOM加载完成，不包括样式表，图片等</li><li><strong>load</strong>事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成</li></ul><h4 id="浏览器渲染的过程主要包括以下五步"><a href="#浏览器渲染的过程主要包括以下五步" class="headerlink" title="浏览器渲染的过程主要包括以下五步"></a>浏览器渲染的过程主要包括以下五步</h4><ol><li>浏览器将获取的HTML文档解析成DOM树。</li><li>处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。</li><li>将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。</li><li>渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。</li><li>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。</li></ol><p>需要注意的是，<strong>以上五个步骤并不一定一次性顺序完成</strong>，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。<br><img src="/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/liulanqi1.webp" alt="image"></p><h3 id="浏览器渲染网页的具体流程"><a href="#浏览器渲染网页的具体流程" class="headerlink" title="浏览器渲染网页的具体流程"></a>浏览器渲染网页的具体流程</h3><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><p>当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。</p><p>需要注意以下几点：</p><ol><li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞</li><li>display:none的元素也会在DOM树中</li><li>注释也会在DOM树中</li><li>script标签会在DOM树中</li></ol><p>无论是DOM还是CSSOM，都是要经过<code>Bytes→characters→tokens→nodes→objectmodel</code>这个过程。</p><p><img src="/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/liulanqi2.webp" alt="image"><br>当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p><h4 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h4><p>浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。</p><p>在这个过程需要注意的是：</p><ol><li>CSS解析可以与DOM解析同时进行。</li><li>CSS解析与script的执行互斥 。</li><li>在Webkit内核中进行了script执行优化，只有在JS访问CSS时才会发生互斥。</li></ol><h4 id="构建渲染树（Render-Tree）"><a href="#构建渲染树（Render-Tree）" class="headerlink" title="构建渲染树（Render Tree）"></a>构建渲染树（Render Tree）</h4><p>通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。</p><p>有以下几点需要注意：</p><ol><li>Render Tree和DOM Tree不完全对应</li><li>display: none的元素不在Render Tree中</li><li>visibility: hidden的元素在Render Tree中</li></ol><p><img src="/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/liulanqi3.webp" alt="image"></p><p>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。</p><h4 id="渲染树布局-layout-of-the-render-tree"><a href="#渲染树布局-layout-of-the-render-tree" class="headerlink" title="渲染树布局(layout of the render tree)"></a>渲染树布局(layout of the render tree)</h4><p>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：</p><ol><li>float元素，absoulte元素，fixed元素会发生位置偏移。</li><li>我们常说的脱离文档流，其实就是脱离Render Tree。</li></ol><h4 id="渲染树绘制（Painting-the-render-tree）"><a href="#渲染树绘制（Painting-the-render-tree）" class="headerlink" title="渲染树绘制（Painting the render tree）"></a>渲染树绘制（Painting the render tree）</h4><p>在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p><h3 id="浏览器渲染网页的那些事儿"><a href="#浏览器渲染网页的那些事儿" class="headerlink" title="浏览器渲染网页的那些事儿"></a>浏览器渲染网页的那些事儿</h3><h4 id="浏览器主要组件结构"><a href="#浏览器主要组件结构" class="headerlink" title="浏览器主要组件结构"></a>浏览器主要组件结构</h4><p><img src="/2019/09/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%87%E7%A8%8B/liulanqi4.webp" alt="image"><br>渲染引擎主要有两个：webkit和Gecko</p><p>Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。</p><p>虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p><h4 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h4><p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性defer或者async。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。</p><p>每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，script标签的位置很重要。</p><p>JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。</p><p>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。</p><p>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在head中，仅仅是为了更快的解析CSS，保证更快的首次渲染。</p><p>需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。</p><p>当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。</p><p>例如：div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。<br>所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p><h3 id="回流和重绘（reflow和repaint）"><a href="#回流和重绘（reflow和repaint）" class="headerlink" title="回流和重绘（reflow和repaint）"></a>回流和重绘（reflow和repaint）</h3><p>我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：replaint和reflow。</p><h4 id="reflow（回流）"><a href="#reflow（回流）" class="headerlink" title="reflow（回流）"></a>reflow（回流）</h4><p>当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，大家称这个回退的过程叫<code>reflow</code>。<code>reflow</code>会从<code>html</code>这个<code>root frame</code>开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。reflow几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会<code>reflow</code>哪一部分的代码，因为他们会相互影响。</p><h4 id="repaint（重绘）"><a href="#repaint（重绘）" class="headerlink" title="repaint（重绘）"></a>repaint（重绘）</h4><p><code>repaint</code> 则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。</p><p>需要注意的是，<code>display:none会触发reflow，而visibility: hidden</code>属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以visibility:hidden只会触发repaint，因为没有发生位置变化。</p><p>另外有些情况下，比如修改了元素的样式，浏览器并不会立刻<code>reflow</code>或<code>repaint</code>一次，而是会把这样的操作积攒一批，然后做一次<code>reflow</code>，这又叫异步<code>reflow</code>或增量异步<code>reflow</code>。但是在有些情况下，比如<code>resize</code>窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行<code>reflow</code>。</p><h4 id="引起reflow"><a href="#引起reflow" class="headerlink" title="引起reflow"></a>引起reflow</h4><p>现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p><ol><li>页面第一次渲染（初始化）</li><li>DOM树变化（如：增删节点）</li><li>Render树变化（如：padding改变）</li><li>浏览器窗口resize</li><li>获取元素的某些属性</li></ol><p>浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括<code>offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、</code>调用了<code>getComputedStyle()</code>。</p><h4 id="引起repaint"><a href="#引起repaint" class="headerlink" title="引起repaint"></a>引起repaint</h4><p><code>reflow</code> 回流必定引起<code>repaint</code>重绘，重绘可以单独触发。</p><p>背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</p><h4 id="减少reflow、repaint触发次数"><a href="#减少reflow、repaint触发次数" class="headerlink" title="减少reflow、repaint触发次数"></a>减少reflow、repaint触发次数</h4><ol><li>用transform做形变和位移可以减少reflow</li><li>避免逐个修改节点样式，尽量一次性修改</li><li>使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染</li><li>可以将需要多次修改的DOM元素设置display:none，操作完再显示。（因为隐藏元素不在render树内，因此修改隐藏元素不会触发回流重绘）</li><li>避免多次读取某些属性</li><li>通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本</li></ol><h3 id="几条关于优化渲染效率的建议"><a href="#几条关于优化渲染效率的建议" class="headerlink" title="几条关于优化渲染效率的建议"></a>几条关于优化渲染效率的建议</h3><p>结合上文有以下几点可以优化渲染效率。</p><ul><li>合法地去书写HTML和CSS ，且不要忘了文档编码类型。</li><li>样式文件应当在head标签中，而脚本文件在body结束前，这样可以防止阻塞的方式。</li><li>简化并优化CSS选择器，尽量将嵌套层减少到最小。</li><li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li><li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li><li>不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</li><li>尽量用transform来做形变和位移</li><li>尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用cloneNode()方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li><li>先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li><li>position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li><li>只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。</li><li>使用window.requestAnimationFrame()、window.requestIdleCallback()这两个方法调节重新渲染。</li></ul><p><a href="https://www.jianshu.com/p/e6252dc9be32">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSRF和XSS</title>
    <link href="/2019/09/03/CSRF%E5%92%8CXSS/"/>
    <url>/2019/09/03/CSRF%E5%92%8CXSS/</url>
    
    <content type="html"><![CDATA[<h2 id="CSRF和XSS"><a href="#CSRF和XSS" class="headerlink" title="CSRF和XSS"></a>CSRF和XSS</h2><p>前端安全主要分为两种：</p><ol><li>CSRF</li><li>XSS<span id="more"></span></li></ol><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>CSRF跨站点请求伪造(Cross—Site Request Forgery)</strong></p><p><img src="/2019/09/03/CSRF%E5%92%8CXSS/csrf.png" alt="image"></p><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><h4 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><h4 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a>防御方式</h4><h5 id="token形式"><a href="#token形式" class="headerlink" title="token形式"></a>token形式</h5><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <code>http://url?csrftoken=tokenvalue</code>。 而对于 POST 请求来说，要在 form 的最后加上<code>&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</code><br>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p> 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><h5 id="Referer验证"><a href="#Referer验证" class="headerlink" title="Referer验证"></a>Referer验证</h5><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><h5 id="隐藏令牌"><a href="#隐藏令牌" class="headerlink" title="隐藏令牌"></a>隐藏令牌</h5><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>XSS跨域脚本攻击（Cross Site Scripting）</strong></p><p>跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。<br>xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><p><strong>非持久化</strong></p><p>攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p><strong>持久化</strong></p><p>代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。</p><h4 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h4><p>XSS防御的总体思路是：<strong>对输入(和URL参数)进行过滤，对输出进行编码。</strong></p><h5 id="对输入和URL参数进行过滤-白名单和黑名单"><a href="#对输入和URL参数进行过滤-白名单和黑名单" class="headerlink" title="对输入和URL参数进行过滤(白名单和黑名单)"></a>对输入和URL参数进行过滤(白名单和黑名单)</h5><h5 id="对输出进行编码"><a href="#对输出进行编码" class="headerlink" title="对输出进行编码"></a>对输出进行编码</h5><h5 id="使用HTTPOnly保护用户信息"><a href="#使用HTTPOnly保护用户信息" class="headerlink" title="使用HTTPOnly保护用户信息"></a>使用HTTPOnly保护用户信息</h5>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通信相关问题</title>
    <link href="/2019/08/22/%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2019/08/22/%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略以及限制"><a href="#同源策略以及限制" class="headerlink" title="同源策略以及限制"></a>同源策略以及限制</h2><span id="more"></span><h3 id="同源策略的含义"><a href="#同源策略的含义" class="headerlink" title="同源策略的含义"></a>同源策略的含义</h3><ol><li>协议相同</li><li>域名相同</li><li>端口相同 举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是http:&#x2F;&#x2F;，域名是<a href="http://www.example.com,端口是80(默认端口可以省略)./">www.example.com，端口是80（默认端口可以省略）。</a></li><li><code>http://www.example.com/dir2/other.html</code>  ：同源</li><li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li></ol><h3 id="同源的目的以及限制"><a href="#同源的目的以及限制" class="headerlink" title="同源的目的以及限制"></a>同源的目的以及限制</h3><p>举个例子：<br>比如一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。</p><p>在浏览器中，script，img、iframe、link等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。</p><h3 id="同源策略的作用范围"><a href="#同源策略的作用范围" class="headerlink" title="同源策略的作用范围"></a>同源策略的作用范围</h3><p>同源策略限制了客户端javascript代码的部分行为</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取。</li><li>DOM 无法获得。</li><li>AJAX 请求不能发送。</li></ol><h2 id="前后端通信方式"><a href="#前后端通信方式" class="headerlink" title="前后端通信方式"></a>前后端通信方式</h2><ol><li>ajax</li><li>Websocket</li><li>CORS</li></ol><h3 id="AJAX实现"><a href="#AJAX实现" class="headerlink" title="AJAX实现"></a>AJAX实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [json 实现ajax的json]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;<span class="hljs-type">[type]</span>&#125; options [description]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">[type]</span>&#125;         [description]</span><br><span class="hljs-comment"> */</span><br> util.<span class="hljs-property">json</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>     <span class="hljs-keyword">var</span> opt = &#123;<br>         <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>         <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>         <span class="hljs-attr">data</span>: &#123;&#125;,<br>         <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>         <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;,<br>     &#125;;<br>     util.<span class="hljs-title function_">extend</span>(opt, options);<br>     <span class="hljs-keyword">if</span> (opt.<span class="hljs-property">url</span>) &#123;<br>         <span class="hljs-keyword">var</span> xhr = <span class="hljs-title class_">XMLHttpRequest</span><br>            ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&#x27;Microsoft.XMLHTTP&#x27;</span>);<br>         <span class="hljs-keyword">var</span> data = opt.<span class="hljs-property">data</span>,<br>             url = opt.<span class="hljs-property">url</span>,<br>             type = opt.<span class="hljs-property">type</span>.<span class="hljs-title function_">toUpperCase</span>(),<br>             dataArr = [];<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> data) &#123;<br>             dataArr.<span class="hljs-title function_">push</span>(k + <span class="hljs-string">&#x27;=&#x27;</span> + data[k]);<br>         &#125;<br>         <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>             url = url + <span class="hljs-string">&#x27;?&#x27;</span> + dataArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>);<br>             xhr.<span class="hljs-title function_">open</span>(type, url.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\?$/g</span>, <span class="hljs-string">&#x27;&#x27;</span>), <span class="hljs-literal">true</span>);<br>             xhr.<span class="hljs-title function_">send</span>();<br>         &#125;<br>         <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>             xhr.<span class="hljs-title function_">open</span>(type, url, <span class="hljs-literal">true</span>);<br>             xmlhttp.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>);<br>             xhr.<span class="hljs-title function_">send</span>(dataArr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>));<br>         &#125;<br>         xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>             <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;<br>                 <span class="hljs-keyword">var</span> res;<br>                 <span class="hljs-keyword">if</span> (opt.<span class="hljs-property">success</span> &amp;&amp; opt.<span class="hljs-property">success</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>) &#123;<br>                     res = xhr.<span class="hljs-property">responseText</span>;<br>                     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res ==== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>                         res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(res);<br>                         opt.<span class="hljs-property">success</span>.<span class="hljs-title function_">call</span>(xhr, res);<br>                     &#125;<br>                 &#125;<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-keyword">if</span> (opt.<span class="hljs-property">error</span> &amp;&amp; opt.<span class="hljs-property">error</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>) &#123;<br>                     opt.<span class="hljs-property">error</span>.<span class="hljs-title function_">call</span>(xhr, res);<br>                 &#125;<br>             &#125;<br>         &#125;;<br>     &#125;<br> &#125;;<br><br></code></pre></td></tr></table></figure><p><strong>在封装ajax请求时，要注意是否兼容IE浏览器。</strong></p><h2 id="跨域通信的方式"><a href="#跨域通信的方式" class="headerlink" title="跨域通信的方式"></a>跨域通信的方式</h2><ol><li>JSONP</li><li>Hash</li><li>postMessage</li><li>WebSocket</li><li>CORS</li></ol><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * [function jsonp]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;<span class="hljs-type">[type]</span>&#125; url      [description]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;<span class="hljs-type">[type]</span>&#125; onsucess [description]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;<span class="hljs-type">[type]</span>&#125; onerror  [description]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  &#123;<span class="hljs-type">[type]</span>&#125; charset  [description]</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">[type]</span>&#125;          [description]</span><br><span class="hljs-comment"> */</span><br>util.<span class="hljs-property">jsonp</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">url, onsuccess, onerror, charset</span>) &#123;<br>    <span class="hljs-keyword">var</span> callbackName = util.<span class="hljs-title function_">getName</span>(<span class="hljs-string">&#x27;tt_player&#x27;</span>);<br>    <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (onsuccess &amp;&amp; util.<span class="hljs-title function_">isFunction</span>(onsuccess)) &#123;<br>            <span class="hljs-title function_">onsuccess</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">var</span> script = util.<span class="hljs-title function_">createScript</span>(url + <span class="hljs-string">&#x27;&amp;callback=&#x27;</span> + callbackName, charset);<br>    script.<span class="hljs-property">onload</span> = script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (!script.<span class="hljs-property">readyState</span> || <span class="hljs-regexp">/loaded|complete/</span>.<span class="hljs-title function_">test</span>(script.<span class="hljs-property">readyState</span>)) &#123;<br>            script.<span class="hljs-property">onload</span> = script.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 移除该script的 DOM 对象</span><br>            <span class="hljs-keyword">if</span> (script.<span class="hljs-property">parentNode</span>) &#123;<br>                script.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(script);<br>            &#125;<br>            <span class="hljs-comment">// 删除函数或变量</span><br>            <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;;<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (onerror &amp;&amp; util.<span class="hljs-title function_">isFunction</span>(onerror)) &#123;<br>            <span class="hljs-title function_">onerror</span>();<br>        &#125;<br>    &#125;;<br>   <span class="hljs-comment">//添加标签获取js</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script);<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>我的理解就是伪装成script标签的请求，获取内容，实现跨域请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.abc.com/?data=name&amp;callback=jsonp&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>请求时需要在后面添加callback的返回，<code>callback=jsonp</code>,这个是作为函数名返回，本地必须有个同名的函数才能使用。</p><p>该函数应该注册在window对象上。 </p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B</span><br><span class="hljs-comment">// 在A中伪代码如下：</span><br><span class="hljs-keyword">var</span> B = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>B.<span class="hljs-property">src</span> = B.<span class="hljs-property">src</span> + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-string">&#x27;data&#x27;</span>;<br><span class="hljs-comment">// 在B中的伪代码如下</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// postMessage</span><br><span class="hljs-comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span><br><span class="hljs-title class_">Bwindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;http://B.com&#x27;</span>);<br><span class="hljs-comment">// 在窗口B中监听</span><br><span class="hljs-title class_">Awindow</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">origin</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">source</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">data</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br></code></pre></td></tr></table></figure><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">     <br><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;wss://echo.websocket.org&#x27;</span>);<br><br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection open ...&#x27;</span>);<br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello WebSockets!&#x27;</span>);<br>&#125;;<br><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received Message: &#x27;</span>, evt.<span class="hljs-property">data</span>);<br>    ws.<span class="hljs-title function_">close</span>();<br>&#125;;<br><br>ws.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection closed.&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">Websocket【参考资料】</a></p><p>ws和wss，前者未加密后者加密</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// url（必选），options（可选）</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/some/url/&#x27;</span>, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>  <span class="hljs-comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>请求头中添加这个<br><code>Access-Control-Allow-Origin: http://api.bob.com</code></p><p> <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">CORS【参考资料】</a></p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js栈</title>
    <link href="/2019/08/19/js%E6%A0%88/"/>
    <url>/2019/08/19/js%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈"></a>什么是堆栈</h2><p>栈，又叫堆栈，是和列表类似的一种数据结构，但是却更高效，因为栈内的元素只能通过列表的一端访问，称为栈顶，数据只能在栈顶添加或删除，遵循 先入后出(LIFO，last-in-first-out) 的原则，普遍运用于计算机的方方面面。</p><span id="more"></span><p>对栈的操作主要有两种，一是将一个元素压入栈，push方法，另一个就是将栈顶元素出栈，pop方法。</p><p>除此之外，栈还有其他的一些属性和方法：查看当前栈顶的元素值，我们使用 peek 方法，它仅仅返回栈顶元素值，并不删除它；clear 方法用于清空当前栈内的所有元素；top属性记录当前栈顶位置；length方法返回当前栈内元素总数等；接着我们定义栈的数据类型，并利用JS中的数组去实现它。</p><p><img src="/2019/08/19/js%E6%A0%88/duizhan1.webp" alt="image"></p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义栈</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Stack</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span> = [];    <span class="hljs-comment">//初始化为空</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> = <span class="hljs-number">0</span>;           <span class="hljs-comment">//记录栈顶位置</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pop</span> = pop;         <span class="hljs-comment">//出栈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">push</span> = push;       <span class="hljs-comment">//入栈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">peek</span> = peek;       <span class="hljs-comment">//查看栈顶元素</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = length;   <span class="hljs-comment">//查看栈内元素总数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">clear</span> = clear;     <span class="hljs-comment">//清空栈</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用 dataStore 来保存栈内元素，初始化为空数组，top 属性用于记录当前栈顶位置，初始化的时候为0，<br>表示栈顶对应数组的起始位置是0，如果有元素入栈，则该属性会随之反生变化。</p><p><strong>首先我们先来实现第一个入栈方法。</strong></p><h4 id="push：向栈内压入一个新的元素"><a href="#push：向栈内压入一个新的元素" class="headerlink" title="push：向栈内压入一个新的元素"></a>push：向栈内压入一个新的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//该方法将一个新元素入栈，放到数组中 top 所对应的位置上，并将 top 的值加 1，让其指向数组的下一个空位置</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params"> element </span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span>++] = element;<br>&#125;<br></code></pre></td></tr></table></figure><p>能入栈，就得可以出栈，接着我们来看出栈方法：</p><h4 id="pop：取出栈顶元素"><a href="#pop：取出栈顶元素" class="headerlink" title="pop：取出栈顶元素"></a>pop：取出栈顶元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//该方法与入栈相反，返回栈顶元素，并将 top 的值减 1</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span>[--<span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>如何查看栈顶元素呢，peek方法！</p><h4 id="peek：查看栈顶元素"><a href="#peek：查看栈顶元素" class="headerlink" title="peek：查看栈顶元素"></a>peek：查看栈顶元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//该方法返回的是栈顶元素，即 top - 1 个位置元素</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> &gt; <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span>-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Empty&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我做了个判断，如果一个空栈调用了 peek 方法，因为栈内没有任何元素，所以我这里返回了一个 ‘Empty’;</p><p>现在，我们已经有了基本的入栈、出栈、查看栈顶元素的方法，我们不妨试一试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//初始化一个栈</span><br><span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( stack.<span class="hljs-title function_">peek</span>() );    <span class="hljs-comment">// Empty</span><br><br><span class="hljs-comment">//入栈</span><br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Apple&#x27;</span>);<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Banana&#x27;</span>);<br>stack.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Pear&#x27;</span>);<br><br><span class="hljs-comment">//查看当前栈顶元素</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( stack.<span class="hljs-title function_">peek</span>() );    <span class="hljs-comment">// Pear</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( stack.<span class="hljs-title function_">pop</span>() );     <span class="hljs-comment">// Pear    </span><br></code></pre></td></tr></table></figure><p>如果我放入了一些水果，吃掉了一个，我现在想知道我还剩多少个水果怎么办？length 方法可以实现</p><h4 id="length：返回栈内元素总数"><a href="#length：返回栈内元素总数" class="headerlink" title="length：返回栈内元素总数"></a>length：返回栈内元素总数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//该方法通过返回 top 属性的值来返回栈内总的元素个数</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">length</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们把代码恢复到出栈前的状态，也就是里面已经放了三个水果，接着我们来看看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( stack.<span class="hljs-title function_">length</span>() );      <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">//出栈</span><br>stack.<span class="hljs-title function_">pop</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( stack.<span class="hljs-title function_">length</span>() );      <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>好了，我们还剩最后一个clear方法，我们来实现一下</p><h4 id="clear：清空栈"><a href="#clear：清空栈" class="headerlink" title="clear：清空栈"></a>clear：清空栈</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//该方法实现很简单，我们将 top 值置为 0 ， dataStore 数值清空即可</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataStore</span> = [];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">top</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现数制间的相互转换"><a href="#实现数制间的相互转换" class="headerlink" title="实现数制间的相互转换"></a>实现数制间的相互转换</h2><p>我们可以利用栈将一个数字从一种数制转换成另一种数制。例如将数字 n 转换成以 b 为基数的数字，可以采用如下算法（该算法只针对基数为 2-9 的情况）：</p><ol><li>最高位为 n % b ， 直接压入栈;</li><li>使用 n &#x2F; b 来代替 n ;</li><li>重复上面的步骤，知道 n 为 0 ，并且没有余数；</li><li>以此将栈内元素弹出，直到栈空，并依次将这些元素排列，就得到了转换后的形式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//进制转换（2-9）</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mulBase</span> (<span class="hljs-params"> num , base </span>) &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();<br>    <span class="hljs-keyword">do</span>&#123;<br>        s.<span class="hljs-title function_">push</span>( num % base );<br>        num = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>( num /= base );<br>    &#125;<span class="hljs-keyword">while</span> ( num &gt; <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">var</span> converted = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-title function_">length</span>() &gt; <span class="hljs-number">0</span>)&#123;<br>        converted += s.<span class="hljs-title function_">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> converted;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">mulBase</span>( <span class="hljs-number">125</span> , <span class="hljs-number">2</span> ) );      <span class="hljs-comment">// 1111101</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">mulBase</span>( <span class="hljs-number">125</span> , <span class="hljs-number">8</span> ) );      <span class="hljs-comment">// 175</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js的面向对象</title>
    <link href="/2019/07/25/js%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/07/25/js%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><span id="more"></span><h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 类的声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// es6中的声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animals</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-comment">// 实例化类</span><br>   <span class="hljs-comment">//在没有参数时，构造函数的括号可以省略</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animals</span>());<br></code></pre></td></tr></table></figure><h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><h3 id="使用构造函数进行继承"><a href="#使用构造函数进行继承" class="headerlink" title="使用构造函数进行继承"></a>使用构造函数进行继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用构造函数进行继承（es5）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;name&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Parent1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;say&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 这种方式不会继承父类原型对象上的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// apply;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;chilid1&#x27;</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child1</span>);<br></code></pre></td></tr></table></figure><p><strong>这种方式不会继承父类原型对象上的方法</strong></p><h3 id="借助原型链实现继承"><a href="#借助原型链实现继承" class="headerlink" title="借助原型链实现继承"></a>借助原型链实现继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//借助原型链实现继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;name2&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;chilid2&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent2</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>());<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>();<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child2</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">play</span>, s2.<span class="hljs-property">play</span>);<span class="hljs-comment">//[1,2,3] [1,2,3]</span><br>s1.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-property">play</span>, s2.<span class="hljs-property">play</span>);<span class="hljs-comment">//[1,2,3,4] [1,2,3,4]</span><br></code></pre></td></tr></table></figure><p><strong>多个实例化对象，共用一个原型链，修改对象中原型链上的属性，会导致其他对象的原型链上的属性也发生变化。</strong></p><h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组合方式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;name3&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;chilid3&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>();<br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>();<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>);<br></code></pre></td></tr></table></figure><p><strong>有缺点，父类的构造函数执行了两次。</strong></p><h3 id="组合继承的优化1"><a href="#组合继承的优化1" class="headerlink" title="组合继承的优化1"></a>组合继承的优化1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent4</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;4&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child4</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent4</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;chilid4&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child4</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent4</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-keyword">var</span> s5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child4</span>();<br><span class="hljs-keyword">var</span> s6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child4</span>();<br>s5.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5.<span class="hljs-property">play</span>, s6.<span class="hljs-property">play</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Child4</span>, s5 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Parent4</span>);<span class="hljs-comment">// true true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5.<span class="hljs-property">constructor</span>);<span class="hljs-comment">// Parent4</span><br><span class="hljs-comment">// 因为子类的prototype就是父类的实例，他的constructor是从父类直接拿过来的</span><br></code></pre></td></tr></table></figure><p>父类只在子类实例化时执行一次，将父类的prototype赋给子类。</p><h3 id="组合继承的优化2"><a href="#组合继承的优化2" class="headerlink" title="组合继承的优化2"></a>组合继承的优化2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent5</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;5&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child5</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Parent5</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;chilid5&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child5</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child5</span>;<br><span class="hljs-keyword">var</span> s5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child5</span>();<br><span class="hljs-keyword">var</span> s6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child5</span>();<br>s5.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5.<span class="hljs-property">play</span>, s6.<span class="hljs-property">play</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Child5</span>, s5 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Parent5</span>); <span class="hljs-comment">// true true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s5.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// Child5</span><br></code></pre></td></tr></table></figure><h3 id="ES6的继承"><a href="#ES6的继承" class="headerlink" title="ES6的继承"></a>ES6的继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// es6继承</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">//构造函数，里面写上对象的属性</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unknown&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//方法写在后面</span><br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//父类共有的方法</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; will eat pests.&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//class继承</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props,myAttribute</span>) &#123;<span class="hljs-comment">//props是继承过来的属性，myAttribute是自己的属性</span><br>      <span class="hljs-comment">//调用实现父类的构造函数</span><br>      <span class="hljs-variable language_">super</span>(props)<span class="hljs-comment">//相当于获得父类的this指向</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = props.<span class="hljs-property">type</span> || <span class="hljs-string">&quot;Unknown&quot;</span>;<span class="hljs-comment">//父类的属性，也可写在父类中</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr</span> = myAttribute;<span class="hljs-comment">//自己的私有属性</span><br>    &#125;<br><br>    <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//自己私有的方法</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; are friendly to people.&quot;</span>);<br>    &#125;<br>    <span class="hljs-title function_">myattr</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//自己私有的方法</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span>+<span class="hljs-string">&#x27;---&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">attr</span>);<br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">//通过new实例化</span><br>  <span class="hljs-keyword">var</span> myBird = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小燕子&#x27;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Egg animal&#x27;</span><span class="hljs-comment">//卵生动物</span><br>  &#125;,<span class="hljs-string">&#x27;Bird class&#x27;</span>)<br>  myBird.<span class="hljs-title function_">eat</span>()<br>  myBird.<span class="hljs-title function_">fly</span>()<br>  myBird.<span class="hljs-title function_">myattr</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2019/07/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2019/07/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链的介绍"><a href="#原型链的介绍" class="headerlink" title="原型链的介绍"></a>原型链的介绍</h2><h3 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h3><p>js中，任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。</p><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>  原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。</p><span id="more"></span><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ol><li>字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;;<br></code></pre></td></tr></table></figure></li><li>字面量（使用了Object的构造方法）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure></li><li>构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> func = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">func</span>();<br></code></pre></td></tr></table></figure></li><li>Object.create<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> demo = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(demo);<br></code></pre></td></tr></table></figure></li></ol><h3 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><p><strong>首先，当我们声明一个function关键字的方法时，会为这个方法添加一个prototype属性，指向默认的原型对象，并且此prototype的constructor属性也指向方法对象。此二个属性会在创建对象时被对象的属性引用。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Hello</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Object &#123;&#125; -- &gt; 内部的constructor 指向Hello方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Hello</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// function Hello()&#123;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>我们如果用Hello创建一个对象h，看这个对象有什么属性。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(h.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// function Hello()&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(h)==<span class="hljs-title class_">Hello</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// true  备注：getPrototypeOf是获取_proto_</span><br></code></pre></td></tr></table></figure><p> 我们惊喜的发现，new出来的对象，它的constructor指向了方法对象，它的_proto_和prototype相等。</p><p>  即new一个对象，它的_proto_属性指向了方法的prototype属性，并且constructor指向了prototype的constructor属性。</p><h3 id="创建对象的过程-1"><a href="#创建对象的过程-1" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hehe</span>(<span class="hljs-params">name</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hehe</span>(<span class="hljs-string">&quot;笑你妹&quot;</span>);<br><span class="hljs-comment">//伪代码:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">newObj</span>(<span class="hljs-params">name</span>)&#123;<br> <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br> obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Hehe</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> obj.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Hehe</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>;<br> <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">Hehe</span>.<span class="hljs-title function_">call</span>(obj, name);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result===<span class="hljs-string">&#x27;object&#x27;</span>&amp;&amp; result!=<span class="hljs-literal">null</span> ? result : obj;  <span class="hljs-comment">//当无返回对象或默认时返回obj。</span><br>&#125;<br><span class="hljs-keyword">var</span> hh = <span class="hljs-title function_">newObj</span>(<span class="hljs-string">&quot;笑你妹&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hh);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(h);<br><span class="hljs-comment">//虽然hh!=h,但是可以看到这个hh就和h的结构一样了。</span><br><br></code></pre></td></tr></table></figure><p><strong>过程：先创建一个空对象，设置一个_proto_指向方法的原型，设置constructor，用新对象做this指向方法，返回新对象。</strong></p><h2 id="原型以及原型链关系"><a href="#原型以及原型链关系" class="headerlink" title="原型以及原型链关系"></a>原型以及原型链关系</h2><p><img src="/2019/07/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/yuanxing.png" alt="image"></p><p><img src="/2019/07/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/gouzao.png" alt="image"></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p>任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-comment">//方法才有prototype,普通对象无prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Object&#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// undifined</span><br><br><span class="hljs-comment">//任何对象都是有构造函数的,Person这种方法的构造函数是Function。</span><br><span class="hljs-comment">//备注:constructor很容易被改变，一般不用它，此处只是打印下列对象的构造函数是什么。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">constructor</span>); <span class="hljs-comment">//function Person()&#123;&#125;  </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">//function Function()&#123;&#125; </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125;.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// function Object()&#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// function Function() &#123;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([].<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//function Array()&#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p> 用function声明的都是函数，而如果直接调用的话，那么Person()就是一个普通函数，只有用函数new产生对象时，这个函数才是new出来对象的构造函数。</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。</p></blockquote><p>属性搜索原则：</p><ol><li>当访问一个对象的成员的时候，会现在自身找有没有,如果找到直接使用。</li><li>如果没有找到，则去原型链指向的对象的构造函数的prototype中找，找到直接使用，没找到就返回undifined或报错。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br>           <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-comment">//p ---&gt; Person.prototype ---&gt;Object.prototype----&gt;null</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//原型继承的基本案例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">//1.直接替换原型对象 </span><br><span class="hljs-keyword">var</span> parent = &#123;<br>sayHello : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;方式1：替换原型对象&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = parent;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">50</span>);<br>p.<span class="hljs-title function_">sayHello</span>();<br><span class="hljs-comment">//2.混入式原型继承</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;.............混入式原型继承..............&quot;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">var</span> parent2 = &#123;<br>sayHello : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;方式2：原型继承之混入式加载成员&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> parent2) &#123;<br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[k] = parent2[k];<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">50</span>);<br>p.<span class="hljs-title function_">sayHello</span>();<br></code></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><strong>instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">c; <span class="hljs-comment">// function &#123;name: &quot;demo&quot;&#125;</span><br>c <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为什么会是true呢？？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">   c; <span class="hljs-comment">// function &#123;name: &quot;demo&quot;&#125;</span><br>c <span class="hljs-keyword">instanceof</span> func; <span class="hljs-comment">// true</span><br>c.<span class="hljs-property">__proto__</span> === func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>c <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>所以，instanceof不能用来判断对象的类型！！！</strong>  </p><p>那么我们用什么来判断对象的类型呢？</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">   c.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>===func <span class="hljs-comment">// true</span><br>c.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Object</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>当我们用new运算符new一个构造函数产生一个实例时，比如说： var obj &#x3D; new Func 时，其背后的步骤是这样的：</p><ol><li>创建一个继承自 Func.prototype 的新对象；</li><li>执行构造函数 Func ，执行的时候，相应的传参会被传入，同时上下文(this)会被指定为第一步创建的新实例；</li><li>如果构造函数返回了一个“对象”,那么这个对象会取代步骤1中new出来的实例被返回。如果构造函数没有返回对象,那么new出来的结果为步骤1创建的对象。</li></ol><p><strong>注意：new Func 等同于new Func()，只能用在不传递任何参数的情况。</strong></p><h3 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//new运算符原理实现</span><br><span class="hljs-keyword">var</span> new1 = <span class="hljs-keyword">function</span>(<span class="hljs-params">fun</span>)&#123;<br>    <span class="hljs-keyword">var</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">var</span> returnObj = fun.<span class="hljs-title function_">call</span>(newObj);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> returnObj === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> returnObj<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> newObj<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中  var newObj  &#x3D; Object.create(fun.prototype)  的意思是：创建一个新对象newObj，并让<code>newObj.__proto__ </code>指向 fun，即  <code>newObj.__proto__=== fun </code>返回true。<br><strong>方法的使用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strObj = <span class="hljs-title function_">new1</span>(<span class="hljs-title class_">String</span>);<br><span class="hljs-title function_">alert</span>(strObj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>); <span class="hljs-comment">//true</span><br><span class="hljs-title function_">alert</span>(strObj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><strong>可以看到，new1函数的运行效果和new运算符是一样的。我们继续给String的原型上添加一个方法，看看new1函数得到的strObj能否继承到这个方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">defineByN</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是自定义方法&quot;</span>);<br>&#125;<br>strObj.<span class="hljs-title function_">defineByN</span>();  <span class="hljs-comment">//弹出“我是自定义方法”</span><br></code></pre></td></tr></table></figure><p>可以看到new1函数得到的strObj继承了到这个方法。</p><h2 id="问题：为什么Object-create创建的对象和其他几种不一样呢？"><a href="#问题：为什么Object-create创建的对象和其他几种不一样呢？" class="headerlink" title="问题：为什么Object.create创建的对象和其他几种不一样呢？"></a>问题：为什么Object.create创建的对象和其他几种不一样呢？</h2><p>因为使用原型链进行的创造对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">d.__proto__<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>demo<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2019/07/02/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/07/02/HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h3><ol><li>支持客户&#x2F;服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。<br>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<span id="more"></span></li></ol><h3 id="HTTP协议报文"><a href="#HTTP协议报文" class="headerlink" title="HTTP协议报文"></a>HTTP协议报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET &#x2F;data&#x2F;info.html HTTP&#x2F;1.1</p><p>方法字段就是HTTP使用的请求方法，比如常见的GET&#x2F;POST</p><p>其中HTTP协议版本有两种：HTTP1.0&#x2F;HTTP1.1 可以这样区别：</p><p>HTTP1.0对于每个连接都只能传送一个请求和响应，请求就会关闭，HTTP1.0没有Host字段;而HTTP1.1在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1必须有Host字段。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。</p><p>常见的请求头字段含义：</p><p>Accept： 浏览器可接受的MIME类型。</p><p>Accept-Charset：浏览器可接受的字符集。</p><p>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</p><p>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</p><p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</p><p>Content-Length：表示请求消息正文的长度。</p><p>Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP&#x2F;1.1请求必须包含主机头域，否则系统会以400状态码返回。</p><p>If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间。只有当所请求的内容在指定的时间后又经过修改才返回它，否则返回304“Not Modified”应答。</p><p>Referer：客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的(防盗链)。包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p><p>User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</p><p>Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。</p><p>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</p><p>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</p><p>Connection：处理完这次请求后是否断开连接还是继续保持连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</p><p>Range：Range头域可以请求实体的一个或者多个子范围。例如，</p><p>表示头500个字节：bytes&#x3D;0-499</p><p>表示第二个500字节：bytes&#x3D;500-999</p><p>表示最后500个字节：bytes&#x3D;-500</p><p>表示500字节以后的范围：bytes&#x3D;500-</p><p>第一个和最后一个字节：bytes&#x3D;0-0,-1</p><p>同时指定几个范围：bytes&#x3D;500-600,601-999</p><p>但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206(PartialContent)返回而不是以200 (OK)。</p><p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p><h5 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h5><p>它的作用是通过一个空行，告诉服务器请求头部到此为止。</p><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><p>若方法字段是GET，则此项为空，没有数据</p><p>若方法字段是POST,则通常来说此处放置的就是要提交的数据</p><p>比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user&#x3D;admin&amp;password&#x3D;123456，使用&amp;来连接各个字段。</p><p><img src="/2019/07/02/HTTP%E5%8D%8F%E8%AE%AE/qingqiuti.png" alt="image"></p><p><img src="/2019/07/02/HTTP%E5%8D%8F%E8%AE%AE/qingqiudemo.jpg" alt="image"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p>响应行一般由协议版本、状态码及其描述组成 比如 HTTP&#x2F;1.1 200 OK</p><p>其中协议版本HTTP&#x2F;1.1或者HTTP&#x2F;1.0，200就是它的状态码，OK则为它的描述。</p><p>&#x2F;&#x2F;常见状态码：</p><p>100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</p><p>200~299：表示成功接收请求并已完成整个处理过程。常用200</p><p>300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用302(意味着你请求我，我让你去找别人),307和304(我不给你这个资源，自己拿缓存)</p><p>400~499：客户端的请求有错误，常用404(意味着你请求的资源在web服务器中没有)403(服务器拒绝访问，权限不够)</p><p>500~599：服务器端出现错误，常用500</p><p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">更加详细的状态码</a></p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。</p><p>设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。</p><p>常见的响应头字段含义：</p><p>Allow：服务器支持哪些请求方法(如GET、POST等)。</p><p>Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE4、IE5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept- Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</p><p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</p><p>Content- Type：表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</p><p>Date：当前的GMT时间，例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</p><p>Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</p><p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置。</p><p>Location：这个头配合302状态码使用，用于重定向接收者到一个新URI地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</p><p>Refresh：告诉浏览器隔多久刷新一次，以秒计。</p><p>Server：服务器通过这个头告诉浏览器服务器的类型。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。Servlet一般不设置这个值，而是由Web服务器自己设置。</p><p>Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</p><p>Transfer-Encoding：告诉浏览器数据的传送格式。</p><p>WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息?在包含401(Unauthorized)状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;\”executives\”“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问。</p><p>注：设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。</p><p>setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。</p><p>HttpServletResponse还提供了许多设置</p><p>setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。</p><p>setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。</p><p>addCookie：设置一个Cookie(Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头)。</p><h5 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h5><p>它的作用是通过一个空行，告诉服务器请求头部到此为止。</p><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</p><p><img src="/2019/07/02/HTTP%E5%8D%8F%E8%AE%AE/xiangying.jpg" alt="image"></p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><ol><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获取报文首部</li></ol><h3 id="POST请求和GET请求的区别"><a href="#POST请求和GET请求的区别" class="headerlink" title="POST请求和GET请求的区别"></a>POST请求和GET请求的区别</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被收藏，而POST不可以。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><h4 id="HTTP持久连接"><a href="#HTTP持久连接" class="headerlink" title="HTTP持久连接"></a>HTTP持久连接</h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求&#x2F;应答客户和服务器都要新建一个连接，完成后立即断开连接（HTTP协议为无连接的协议。</p><p>当使用Keep-Alive模式（又称持久连接，连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p><p><strong>只有http1.1开始支持持久连接</strong></p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>在使用持久连接的情况下，某个连接上的消息传递是这样的：<br>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</p><p>管线化，则消息的传递变成这样：<br>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</p><h4 id="管线化的特点"><a href="#管线化的特点" class="headerlink" title="管线化的特点"></a>管线化的特点</h4><ol><li><p>管线化机制通过持久连接完成，仅HTTP&#x2F;1.1 支持此技术</p></li><li><p>只有GET和HEAD请求可以进行管线化，而POST则有所限制  </p></li><li><p>初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP&#x2F;1.1版本的协议  </p></li><li><p>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</p></li><li><p>HTTP &#x2F;1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可  </p></li><li><p>由于.上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如<strong>Chrome和Firefox</strong> 默认并未开启管线化支持</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>http</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Event事件常见应用</title>
    <link href="/2019/06/25/Event%E4%BA%8B%E4%BB%B6%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/"/>
    <url>/2019/06/25/Event%E4%BA%8B%E4%BB%B6%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h2><p>W3C的说法是：</p><p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>事件通常与函数结合使用，函数不会在事件发生前被执行！</p><span id="more"></span><h2 id="几种常见事件"><a href="#几种常见事件" class="headerlink" title="几种常见事件"></a>几种常见事件</h2><p><strong>event.preventDefault()</strong> :阻止默认事件  </p><p><strong>event.stopPropagation()</strong>:阻止冒泡  </p><p><strong>event.stopImmediatePropagation()</strong>:按优先级阻止执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">            <span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccf</span>; &#125;</span><br><span class="language-css">            <span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#cfc</span>; &#125;</span><br><span class="language-css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;p&#x27;</span>)</span><br><span class="language-javascript">            p.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是p元素上被绑定的第一个监听函数&quot;</span>);</span><br><span class="language-javascript">            &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            p.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是p元素上被绑定的第二个监听函数&quot;</span>);</span><br><span class="language-javascript">              event.<span class="hljs-title function_">stopImmediatePropagation</span>();</span><br><span class="language-javascript">              <span class="hljs-comment">// 执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.</span></span><br><span class="language-javascript">            &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            p.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是p元素上被绑定的第三个监听函数&quot;</span>);</span><br><span class="language-javascript">              <span class="hljs-comment">// 该监听函数排在上个函数后面，该函数不会被执行</span></span><br><span class="language-javascript">            &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是div元素,我是p元素的上层元素&quot;</span>);</span><br><span class="language-javascript">              <span class="hljs-comment">// p元素的click事件没有向上冒泡，该函数不会被执行</span></span><br><span class="language-javascript">            &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>event.currentTarget</strong>:当前绑定的事件（父级元素）</p><p><strong>event.target</strong>:绑定的事件</p><p>以上两者主要用于事件委托中。<br><strong>事件委托就是利用冒泡的原理，将事件加到 父元素 或 祖先元素上，触发执行效果。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myLinks&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goSomewhere&quot;</span>&gt;</span>Go somewhere<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sayHi&quot;</span>&gt;</span>Say hi<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>正常情况下添加点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> item1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;goSomewhere&quot;</span>);<br>    <span class="hljs-keyword">var</span> item2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    <span class="hljs-keyword">var</span> item3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;sayHi&quot;</span>);<br> <br>    item1.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;<br>    &#125;;<br>    item2.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&quot;事件委托&quot;</span>;<br>    &#125;;<br>    item3.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;;<br><br></code></pre></td></tr></table></figure><p>使用事件委托</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>     <span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span>;<br>     <span class="hljs-keyword">switch</span> (target.<span class="hljs-property">id</span>) &#123;<br>       <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;doSomething&quot;</span>:<br>         <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&quot;事件委托&quot;</span>;<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;goSomewhere&quot;</span>:<br>         location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;<br>         <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sayHi&quot;</span>: <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>   &#125;)<br></code></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> eventCus = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;custome&#x27;</span>);<br>ev.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;custome&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;自定义事件&#x27;</span>);<br>&#125;);<br>ev.<span class="hljs-title function_">dispatchEvent</span>(eve);<br></code></pre></td></tr></table></figure><p>自定义事件也可以使用<code>customEvent</code></p><p>区别在于能够传递数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createEvent</span>(<span class="hljs-params">params, eventName = <span class="hljs-string">&#x27;mock-event&#x27;</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(eventName, &#123; <span class="hljs-attr">detail</span>: params &#125;);<br>&#125;<br><br><span class="hljs-keyword">const</span> event = <span class="hljs-title function_">createEvent</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;0010&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>这里值得注意，需要把想要传递的参数包裹在一个包含detail属性的对象，否则传递的参数不会被挂载？（这里不太确定，我试过传id和params都不会生效）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mock-event&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">&#123; detail: &#123; id &#125; &#125;</span>) =&gt;</span> &#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;id&#x27;</span>,id) <span class="hljs-comment">// 会在控制台打印0010</span><br>       &#125;);<br></code></pre></td></tr></table></figure><h2 id="DOM事件流的补充"><a href="#DOM事件流的补充" class="headerlink" title="DOM事件流的补充"></a>DOM事件流的补充</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM事件流<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ev&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#ev</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css"><span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css"><span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css"><span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>目标元素<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> ev = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ev&#x27;</span>);</span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript"><span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;window捕获阶段&#x27;</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-literal">true</span></span><br><span class="language-javascript">);</span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript"><span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;doc捕获阶段&#x27;</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-literal">true</span></span><br><span class="language-javascript">);</span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript"><span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;html捕获阶段&#x27;</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-literal">true</span></span><br><span class="language-javascript">);</span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript"><span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;body捕获阶段&#x27;</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-literal">true</span></span><br><span class="language-javascript">);</span><br><span class="language-javascript">ev.<span class="hljs-title function_">addEventListener</span>(</span><br><span class="language-javascript"><span class="hljs-string">&#x27;click&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;div捕获阶段&#x27;</span>);</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-literal">true</span></span><br><span class="language-javascript">            );</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> eve=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">&#x27;test&#x27;</span>);</span><br><span class="language-javascript">            ev.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;test&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;自定义事件&#x27;</span>);</span><br><span class="language-javascript">            &#125;);</span><br><span class="language-javascript">            ev.<span class="hljs-title function_">dispatchEvent</span>(eve);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件流</title>
    <link href="/2019/06/11/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <url>/2019/06/11/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><blockquote><p>事件, 就是文档或浏览器窗口发生的一些特定的交互瞬间. JavaScript 和 HTML 之间的交互是通过事件实现的. 可以使用事件监听器来监听事件, 以便事件发生时执行相应的代码.</p></blockquote><span id="more"></span><h2 id="事件流是什么？"><a href="#事件流是什么？" class="headerlink" title="事件流是什么？"></a>事件流是什么？</h2><p>当在页面上某个元素触发特定事件时, 比如点击, 除了被点击的目标元素, 所有祖先元素都会触发该事件, 一直到 window.</p><p>那这样就出现了一个问题, 是先在目标元素上触发事件, 还是先在祖先元素上触发呢? 这就是事件流的概念.</p><p><strong>事件流是事件在目标元素和祖先元素间的触发顺序</strong></p><ul><li><strong>捕获</strong>- Capture - 事件由最顶层逐级向下传播, 直至到达目标元素.</li><li><strong>冒泡</strong> - Bubble - 顾名思义, 类似水中冒泡, 从下往上. 事件由第一个被触发的元素接收, 然后逐级向上传播.</li></ul><p>后来 w3c 采用折中的方式, 规定先捕获再冒泡平息了战火. 如此一个事件就被分成了三个阶段(是的, 不光是捕获和冒泡):</p><ol><li>捕获阶段 - The capture phase - 事件从最顶层元素 window 一直传递到目标元素的父元素.</li><li>目标阶段 - The target phase - 事件到达目标元素. 如果事件指定不冒泡. 那就会在这里中止.</li><li>冒泡阶段 - The bubble phase - 事件从目标元素父元素向上逐级传递直到最顶层元素 window. 及捕获阶段的反方向.</li></ol><p>那这里又有一个新的疑问, 既然捕获和冒泡阶段都会触发事件, 那先捕获再冒泡, 岂不是路径上的元素都会触发两次事件?</p><p>在 DOM2 中, 事件监听机制提供了一个参数来决定事件是在捕获阶段生效还是在冒泡阶段生效, 接下来简要学习下 &#x3D;&#x3D;addEventListener&#x3D;&#x3D; .</p><h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p><strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到目标元素上, 当该对象触发指定的事件时, 指定的回调函数就会被执行. 事件目标可以是一个文档上的元素或任何其他支持事件的对象 (比如 XMLHttpRequest).</p><p>它的工作原理是将实现EventListener的函数或对象添加到调用它的 EventTarget 上的指定事件类型的事件侦听器列表中.</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">target.<span class="hljs-title function_">addEventListener</span>(type, listener[, options]);<br>target.<span class="hljs-title function_">addEventListener</span>(type, listener[, useCapture]);<br>target.<span class="hljs-title function_">addEventListener</span>(type, listener[, useCapture, wantsUntrusted  ]);  <span class="hljs-comment">// Gecko/Mozilla only</span><br></code></pre></td></tr></table></figure><ul><li>type: 表示监听事件类型的字符串. 事件列表.</li><li>listener: 当所监听的事件类型触发时的回调. 会接收到一个事件通知对象.</li><li>options: 可选. 可用的选项如下:</li><li>capture: Boolean, 如果是 true, 表示 listener 会在捕获阶段触发. 默认是 false. 冒泡捕获. 所以微软牛逼.</li><li>once: Boolean, 如果是 true, 表示 listener 在添加之后最多只调用一次.</li><li>passive: Boolean，如果是, 表示 listener 永远不会调用 preventDefault(). 如果 listener 仍然调用了这个函数, 客户端将会忽略它并抛出一个控制台警告.</li><li>useCapture: 可选. Boolean, 同 options - capture</li></ul><blockquote><p>注意: 对于目标元素上的事件监听器来说, 事件会处于目标阶段, 而不是冒泡阶段或者捕获阶段. 在目标阶段的事件会触发该元素上的所有监听器, 而不在乎这个监听器到底在注册时 useCapture 是 true 还是 false.</p></blockquote><h2 id="事件监听添加与移除"><a href="#事件监听添加与移除" class="headerlink" title="事件监听添加与移除"></a>事件监听添加与移除</h2><h3 id="事件添加的三种方式"><a href="#事件添加的三种方式" class="headerlink" title="事件添加的三种方式"></a>事件添加的三种方式</h3><ol><li><p>通过HTML 属性的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;click&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>DOM0 中可以通过js脚本来给指定元素提供事件处理函数，即</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">element.onclick = <span class="hljs-keyword">function</span> <span class="hljs-title">//</span> 只会在冒泡阶段生效<br></code></pre></td></tr></table></figure></li><li><p>DOM2 中, 添加了新的事件监听API, 即<code>addEventListener</code>, 同时提供了取消监听的 <code>removeEventListener(type, handler[, options | useCapture])</code>. 显然事件处理函数注册后, 要取消监听, <code>type/hanlder/useCapture</code>的一致.</p></li></ol><p>相比第一, 第二种, <code>addEventListener</code>的方式有以下几点优势:</p><ul><li>可以为同一个事件注册多个回调函数, 依次触发. 而 DOM0 的方式则会被覆盖掉. 只能添加一种</li><li>使用 DOM0 会覆盖 HTML 的方式.</li><li>可以通过参数决定监听是在冒泡阶段生效还是在捕获阶段生效.</li><li><code>element.onclick</code> 注册的监听只会在冒泡阶段生效</li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;html&#x27;)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>) <br><br>child.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM0A&#x27;</span>) &#125; <span class="hljs-comment">// 覆盖了 HTML 的方式</span><br>child.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM0B&#x27;</span>) &#125; <span class="hljs-comment">// 覆盖了上一条 DOM0A   </span><br><br>child.<span class="hljs-title function_">addEventLisnter</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;lisnterA&#x27;</span>) &#125;)<br>child.<span class="hljs-title function_">addEventLisnter</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;lisnterB&#x27;</span>) &#125;) <span class="hljs-comment">// 不会覆盖</span><br></code></pre></td></tr></table></figure><h5 id="三种方式对应的如何移除"><a href="#三种方式对应的如何移除" class="headerlink" title="三种方式对应的如何移除:"></a>三种方式对应的如何移除:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">child.<span class="hljs-title function_">setAttributer</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-literal">false</span>)<br>child.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span><br>child.<span class="hljs-title function_">removeEventLisnter</span>(<span class="hljs-string">&#x27;设置相同的参数&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>以下代码的输出顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;html&#x27;)&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;parent&quot;</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;child&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            child.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child onclick&#x27;</span>) &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// capture 默认为 false, 冒泡</span></span><br><span class="language-javascript">            parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent event&#x27;</span>) &#125;);</span><br><span class="language-javascript">            child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child event&#x27;</span>) &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">// 捕获</span></span><br><span class="language-javascript">            parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;parent event capture&#x27;</span>) &#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);</span><br><span class="language-javascript">            child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child event capture&#x27;</span>) &#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;window&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;body&#x27;)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;parent html&#x27;)&quot;</span>&gt;</span>parent<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;child html&#x27;)&quot;</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>什么是事件流，同一个事件有几个阶段？</p></li><li><p>如何移除通过HTML属性、element.onclick等注册的事件处理函数？</p></li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>首先参考 chrome 浏览器的结果. 先来看点击 child, 输出:  </p><ol><li>parent html</li><li>parent event</li><li>parent event capture</li><li>body</li><li>html</li><li>window</li></ol><p>奇怪! 这时候不是应该先捕获, capture 在前吗? 别急, 这时候如果调换 parent event 与 parent event capture 的 addEventListener 顺序, 会发现, 输出顺序也变了:</p><ol><li>parent html</li><li><strong>parent event capture</strong></li><li><strong>parent event</strong></li><li>body</li><li>html</li><li>window</li></ol><p>其实这时候的输出顺序只和 <code>addEventListener</code> 的顺序有关. 是否开启 <code>capture</code> 无关. 因为我们是直接点击了 <code>parent</code>. 对于 <code>parent</code> 自身而言. 它在整个点击传递过程中处于目标阶段. 并不涉及捕获和冒泡. 同时我们也发现. html 设置的点击是优先于 <code>addEventListener</code> 的方式的.</p><p>我们再来看下点击 child:</p><ol><li>parent event capture</li><li>hild onclick</li><li>child event</li><li>child event capture</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>首先, child html 没有输出, 因为被 child onclick 覆盖掉了.</p><p>第二点, child onclick 的优先级也是高于 <code>addEventListener</code> 的.</p><p>再然后, 点击事件传递过程中, 首先在捕获阶段, 输出了 parent event capture. 然后到达目标阶段. 同理之前点击 parent. 如果此时调换 child event 与 child event capture 的 <code>addEventListener</code> 顺序. 输出顺序也会改变</p><p>最后, 到达冒泡阶段, 由于 html 的优先级高于 <code>addEventListener</code>. 所以被输出. (别忘了, 默认都是开启冒泡)</p><p>但是. 如果使用 Safari 浏览器, 则会发现, 点击 parent, 输出:</p><ol><li>parent event capture</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>点击 child, 输出:</p><ol><li>parent event capture</li><li>child event capture</li><li>child onclick</li><li>child event</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>会发现, 对于捕获阶段的处理不一样了. 点击目标元素时, 目标元素不仅处于目标阶段, 也处于捕获阶段的终点和冒泡阶段的起点. 所以会进行 <code>capture</code> 的判断. 所以在代码编写时这里要尤为注意.</p><p><a href="https://www.jianshu.com/p/6512139d1d9e">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM级别与DOM事件</title>
    <link href="/2019/06/01/DOM%E7%BA%A7%E5%88%AB%E4%B8%8EDOM%E4%BA%8B%E4%BB%B6/"/>
    <url>/2019/06/01/DOM%E7%BA%A7%E5%88%AB%E4%B8%8EDOM%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>事件是javascript和HTML交互基础, 任何文档或者浏览器窗口发生的交互, 都要通过绑定事件进行交互;比如鼠标点击事件、敲击键盘事件等。这样的事件行为都是前端DOM事件的组成部分，不同的DOM事件会有不同的触发条件和触发效果。</p><span id="more"></span><h2 id="DOM级别与DOM事件"><a href="#DOM级别与DOM事件" class="headerlink" title="DOM级别与DOM事件"></a>DOM级别与DOM事件</h2><p>DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM0级事件处理，DOM2级事件处理和DOM3级事件处理。</p><p>有人可能会疑惑，为什么没有DOM1级事件处理呢？因为1级DOM标准并没有定义事件相关的内容，所以没有所谓的1级DOM事件模型。</p><h3 id="HTML的事件处理程序"><a href="#HTML的事件处理程序" class="headerlink" title="HTML的事件处理程序"></a>HTML的事件处理程序</h3><p>HTML事件处理程序，也是最早的一种事件处理方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button type=<span class="hljs-string">&quot;button&quot;</span> onclick=<span class="hljs-string">&quot;showFn()&quot;</span>&gt;&lt;/button&gt;<br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showFn</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>以上的代码，我们通过直接在HTML代码里面定义了一个 onclick属性触发showfu这样的事件处理程序最大的缺点就是HTML和JS耦合太强，我们如果需要修改函数名就必须修改两个地方，优点是不需要操作DOM来完成事件的绑定。</p><h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><p>DOM0级处理事件就是将一个函数赋值给一个事件处理属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span> type=<span class="hljs-string">&quot;button&quot;</span>&gt;&lt;/button&gt;<br>   <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>   btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>以上的代码我们给button定义了一个id 通过js原生的api获取按钮<br>将一个函数赋值给了一个事件处理属性onclick 这样的方法就是DOM0级<br>处理事件的体现。我们可以通过给事件处理属性赋值null来解绑事件。</p><p><strong>DOM0级事件处理程序的缺点在于一个处理程序无法同时绑定多个处理函数，比如我还想再点击按钮事件上加上另外一个函数。</strong></p><h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><p>DOM2级事件在DOM0级时间段额基础上弥补了一个处理处理程序<br>无法同时绑定多个处理函数的缺点。允许给一个程序添加多个处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span> type=<span class="hljs-string">&quot;button&quot;</span>&gt;&lt;/button&gt;<br>   <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);    <br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">showFn</span>(<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>   &#125;    <br>   btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, showFn, <span class="hljs-literal">false</span>);<br>   <span class="hljs-comment">// btn.removeEventListener(&#x27;click&#x27;, showFn, false); 解绑事件 </span><br></code></pre></td></tr></table></figure><p>DOM2级事件定义了addEventListener 和 removeEventListener两个方法，分别用来绑定和解绑事件，方法中包含三个参数，分别是绑定的事件处理的属性名称（没有on）处理函数和是否在捕获时候执行事件处理函数如果我们还需要添加一个鼠标的移入的方法，只需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventlistener</span>(<span class="hljs-string">&#x27;mouseover&#x27;</span>,showfn,<span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>这样，点击按钮和鼠标移入时候都将触发showfn的方法。</p><p>需要注意的是IE8以下版本不支持 addEventlistener 和 removeEventListerner<br>需要使用attachEvent和detachEvent实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, showFn); <span class="hljs-comment">// 绑定事件 </span><br>btn.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, showFn); <span class="hljs-comment">// 解绑事件</span><br></code></pre></td></tr></table></figure><p>这里我们不需要传入第三个参数，因为IE8以下版本只支持冒泡型事件。</p><h3 id="DOM3级事件"><a href="#DOM3级事件" class="headerlink" title="DOM3级事件"></a>DOM3级事件</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit">DOM3级事件是在DOM2级事件的基础上添加很多事件类型。<br>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、<span class="hljs-built_in">mouseup</span><br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：<span class="hljs-built_in">mousewheel</span><br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件。<br></code></pre></td></tr></table></figure><p>转载链接:<a href="https://www.jianshu.com/p/622d994906f7">DOM级别与DOM事件</a></p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css之BFC</title>
    <link href="/2019/05/03/css%E4%B9%8BBFC/"/>
    <url>/2019/05/03/css%E4%B9%8BBFC/</url>
    
    <content type="html"><![CDATA[<h2 id="BFC定义"><a href="#BFC定义" class="headerlink" title="BFC定义"></a>BFC定义</h2><p><strong>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</strong></p><span id="more"></span><h3 id="Box：css布局的基本单位"><a href="#Box：css布局的基本单位" class="headerlink" title="Box：css布局的基本单位"></a>Box：css布局的基本单位</h3><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p><ul><li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li><li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li><li>run-in box: css3</li></ul><h3 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h3><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p><blockquote><p>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p></blockquote><h2 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h2><ol><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ol><h2 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h2><ol><li>float的值不是none。</li><li>position的值不是static或者relative。</li><li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li><li>overflow的值不是visible</li></ol><h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><ol><li>利用BFC避免margin重叠。</li><li>自适应两栏布局。</li><li>清除浮动。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></blockquote><p>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><h3 id="在无BFC时候"><a href="#在无BFC时候" class="headerlink" title="在无BFC时候"></a>在无BFC时候</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css盒子模型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> * &#123;</span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;section id=&quot;sec&quot;&gt;</span><br><span class="hljs-comment">&lt;style media=&quot;screen&quot;&gt;</span><br><span class="hljs-comment">#sec &#123;</span><br><span class="hljs-comment">background: #f00;</span><br><span class="hljs-comment">/* overflow: hidden; */</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">.child &#123;</span><br><span class="hljs-comment">height: 100px;</span><br><span class="hljs-comment">margin-top: 10px;</span><br><span class="hljs-comment">background: yellow;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&lt;/style&gt;</span><br><span class="hljs-comment">&lt;article class=&quot;child&quot;&gt;&lt;/article&gt;</span><br><span class="hljs-comment">        &lt;/section&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;margin&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#margin</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css"><span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-id">#margin</span> &gt; <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> auto <span class="hljs-number">25px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: blue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/css%E4%B9%8BBFC/wubfc.png" alt="wubfc.png"></p><h3 id="使用BFC"><a href="#使用BFC" class="headerlink" title="使用BFC"></a>使用BFC</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;margin&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#margin</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css"><span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-id">#margin</span> &gt; <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> auto <span class="hljs-number">25px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: blue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;overflow: hidden;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/05/03/css%E4%B9%8BBFC/bfc.png" alt="yasuo"></p><h3 id="不与float重叠"><a href="#不与float重叠" class="headerlink" title="不与float重叠"></a>不与float重叠</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;layout&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>&quot;<span class="hljs-attr">screen</span>&quot;&gt;</span><span class="language-css"></span><br><span class="language-css">              <span class="hljs-selector-id">#layout</span>&#123;</span><br><span class="language-css">                  <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">              &#125;</span><br><span class="language-css">              <span class="hljs-selector-id">#layout</span> <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">                  <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">                  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">                  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">                  <span class="hljs-attribute">background</span>: pink;</span><br><span class="language-css">              &#125;</span><br><span class="language-css">              <span class="hljs-selector-id">#layout</span> <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">                  <span class="hljs-attribute">height</span>: <span class="hljs-number">110px</span>;</span><br><span class="language-css">                  <span class="hljs-attribute">background</span>: blue;</span><br><span class="language-css">                  <span class="hljs-attribute">overflow</span>: auto;</span><br><span class="language-css">              &#125;</span><br><span class="language-css">          </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/05/03/css%E4%B9%8BBFC/margin.png" alt="yasuo"></p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- BFC子元素即使是float，也会参与高度计算 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">               <span class="hljs-selector-id">#float</span>&#123;</span><br><span class="language-css">                   <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">                   <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">               &#125;</span><br><span class="language-css">               <span class="hljs-selector-id">#float</span> <span class="hljs-selector-class">.float</span>&#123;</span><br><span class="language-css">                   <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">                   <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">               &#125;</span><br><span class="language-css">           </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span><br>               我是浮动元素<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2019/05/03/css%E4%B9%8BBFC/float.png" alt="yasuo"></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css盒子模型</title>
    <link href="/2019/05/01/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/05/01/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="css-盒子模型"><a href="#css-盒子模型" class="headerlink" title="css 盒子模型"></a>css 盒子模型</h2><p>css 盒子模型包含标准模型和 IE 模型</p><span id="more"></span><h3 id="标准模型"><a href="#标准模型" class="headerlink" title="标准模型"></a>标准模型</h3><p><img src="/2019/05/01/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/biaozhun.jpg" alt="biaozhun.jpg"></p><h4 id="盒子的组成"><a href="#盒子的组成" class="headerlink" title="盒子的组成"></a>盒子的组成</h4><p>一个盒子由外到内可以分成四个部分：margin（外边距）、border（边框）、padding（内边距）、content（内容）。会发现 margin、border、padding 是 CSS 属性，因此可以通过这三个属性来控制盒子的这三个部分。而 content 则是 HTML 元素的内容。</p><h4 id="盒子的大小"><a href="#盒子的大小" class="headerlink" title="盒子的大小"></a>盒子的大小</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">盒子的宽度 = width + padding-<span class="hljs-built_in">left</span> + padding-<span class="hljs-built_in">right</span> + border-<span class="hljs-built_in">left</span> + border-<span class="hljs-built_in">right</span> + margin-<span class="hljs-built_in">left</span> + margin-<span class="hljs-built_in">right</span><br><br>盒子的高度 = height + padding-<span class="hljs-built_in">top</span> + padding-<span class="hljs-built_in">bottom</span> + border-<span class="hljs-built_in">top</span> + border-<span class="hljs-built_in">bottom</span> + margin-<span class="hljs-built_in">top</span> + margin-<span class="hljs-built_in">bottom</span><br></code></pre></td></tr></table></figure><h3 id="IE-模型"><a href="#IE-模型" class="headerlink" title="IE 模型"></a>IE 模型</h3><p><img src="/2019/05/01/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/ie.jpg" alt="yasuo"></p><h3 id="用-css-如何设置两种模型"><a href="#用-css-如何设置两种模型" class="headerlink" title="用 css 如何设置两种模型"></a>用 css 如何设置两种模型</h3><p>标准模型：box-sizing:content-box<br>ie 模型：box-sizing:border-box</p><h3 id="JS-获取盒子模型的宽高"><a href="#JS-获取盒子模型的宽高" class="headerlink" title="JS 获取盒子模型的宽高"></a>JS 获取盒子模型的宽高</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dom<span class="hljs-selector-class">.style</span>.<span class="hljs-attribute">width</span>/<span class="hljs-built_in">height</span>(只能获取内嵌)<br>dom<span class="hljs-selector-class">.currentStyle</span>.<span class="hljs-attribute">width</span>/height（只有IE支持）<br>window<span class="hljs-selector-class">.getComputedStyle</span>(dom).<span class="hljs-attribute">width</span>/<span class="hljs-built_in">height</span>(火狐谷歌)<br>dom<span class="hljs-selector-class">.getBoundClientRect</span>().<span class="hljs-attribute">width</span>/height (获取展示dom的位置的方法)<br></code></pre></td></tr></table></figure><h3 id="边距重叠"><a href="#边距重叠" class="headerlink" title="边距重叠"></a>边距重叠</h3><h4 id="父子元素边距重叠"><a href="#父子元素边距重叠" class="headerlink" title="父子元素边距重叠"></a>父子元素边距重叠</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css盒子模型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> * &#123;</span><br><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sec&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#sec</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#f00</span>;</span><br><span class="language-css"><span class="hljs-comment">/* overflow: hidden; */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css"><span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css"><span class="hljs-attribute">background</span>: yellow;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>页面布局</title>
    <link href="/2019/04/19/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <url>/2019/04/19/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p>页面布局是作为前端开发的必备技能，能够让页面适应多种规格大小的屏幕，才是一个合格的开发，那么我们有多少种形式呢？  </p><span id="more"></span><p><strong>我们使用最基本的三格式布局来做这个尝试</strong></p><h3 id="float方式"><a href="#float方式" class="headerlink" title="float方式"></a>float方式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.area</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;<br>    <br>&#125;<br><br><span class="hljs-selector-class">.box-one</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.box-two</span> &#123;<br>    <span class="hljs-attribute">background</span>: blue;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.box-three</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background</span>: orange;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-one&quot;</span>&gt;</span>box1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-three&quot;</span>&gt;</span>box3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-two&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第一行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第二行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第三行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>需要注意box-two是放在最后位置的，因为float的关系，放到最后会将三号挤下去</strong></p><h3 id="使用绝对定位"><a href="#使用绝对定位" class="headerlink" title="使用绝对定位"></a>使用绝对定位</h3><p><strong>过于low，不必了解了。</strong></p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.area</span> &#123;<br>            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;<br>            <span class="hljs-attribute">display</span>: grid;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-one</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>            <span class="hljs-attribute">background</span>: red;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-two</span> &#123;<br>            <span class="hljs-attribute">background</span>: blue;<br>            <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>            <span class="hljs-attribute">text-align</span>: center;<br>            <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-three</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>            <span class="hljs-attribute">background</span>: orange;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-one&quot;</span>&gt;</span>box1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-two&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第一行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第二行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第三行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-three&quot;</span>&gt;</span>box3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.area</span> &#123;<br>            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;<br>            <span class="hljs-attribute">display</span>: grid;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>            <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">33%</span> <span class="hljs-number">34%</span> <span class="hljs-number">33%</span>;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-one</span> &#123;<br>            <span class="hljs-attribute">background</span>: red;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-two</span> &#123;<br>            <span class="hljs-attribute">background</span>: blue;<br>            <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>            <span class="hljs-attribute">text-align</span>: center;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box-three</span> &#123;<br>            <span class="hljs-attribute">background</span>: orange;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-one&quot;</span>&gt;</span>box1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-two&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第一行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第二行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第三行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-three&quot;</span>&gt;</span>box3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.area</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br><br>&#125;<br><br><span class="hljs-selector-class">.area</span> <span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">display</span>: table-cell;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.box-one</span> &#123;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.box-two</span> &#123;<br>    <span class="hljs-attribute">background</span>: blue;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.box-three</span> &#123;<br>    <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-one&quot;</span>&gt;</span>box1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-two&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面布局<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第一行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第二行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是第三行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box-three&quot;</span>&gt;</span>box3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>各方案优缺点：</p><p>1.浮动和绝对定位都脱离了文档流，浮动如果周边处理得当，兼容性就会比较好，绝对定位使用较方便。</p><p>2.flex布局是CSS3中新增，就是为了解决浮动和绝对顶对带来的不足，是一种比较完美的解决方案。</p><p>3.网格布局是最新特性，就像是栅格系统。代码量少。</p><p>4.表格布局一旦有一部分高度发生变化，如当表格中内容较多，超出设定高度后，其余部分都会发生变化，这样会不符合开发要求，用户体检也不好。</p><p>5.上述题目，当高度未知时，只有flex布局和table布局通用。</p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数的防抖和节流</title>
    <link href="/2019/04/07/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2019/04/07/%E5%87%BD%E6%95%B0%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是防抖？什么是节流？"><a href="#什么是防抖？什么是节流？" class="headerlink" title="什么是防抖？什么是节流？"></a>什么是防抖？什么是节流？</h2><h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><blockquote><p><strong>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</strong></p></blockquote><h3 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h3><blockquote><p><strong>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</strong></p></blockquote><span id="more"></span><h2 id="防抖和节流的应用场景"><a href="#防抖和节流的应用场景" class="headerlink" title="防抖和节流的应用场景"></a>防抖和节流的应用场景</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>所谓防抖，就是指触发事件后在 n 秒（或毫秒）内函数只能执行一次，如果在 n 秒（或毫秒）内又触发了事件，则会重新计算函数执行时间。</strong></p><p>比如我们进行实时的搜索功能、对用户输入框进行监测，对用户的滚动条进行监测等等。</p><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</strong></p><p>比如我们在做搜索输入时，用户连续点击多次搜索按钮，我们使用节流的方式。</p><h2 id="防抖和节流的实现"><a href="#防抖和节流的实现" class="headerlink" title="防抖和节流的实现"></a>防抖和节流的实现</h2><h3 id="防抖-1"><a href="#防抖-1" class="headerlink" title="防抖"></a>防抖</h3><p>防抖可以分为两种，一种是延时、一种是立即执行。</p><h4 id="延时版"><a href="#延时版" class="headerlink" title="延时版"></a>延时版</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func,wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br><br>        <span class="hljs-keyword">let</span> callNow = !timeout;<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            timeout = <span class="hljs-literal">null</span>;<br>        &#125;, wait)<br><br>        <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二者的区别在于，前者在延时n秒后执行，后者是立即执行，但是在n秒后才能再次执行。</strong></p><h4 id="延时版和立即执行版结合"><a href="#延时版和立即执行版结合" class="headerlink" title="延时版和立即执行版结合"></a>延时版和立即执行版结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 函数防抖</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> func 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> immediate true 表立即执行，false 表非立即执行</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func,wait,immediate</span>) &#123;<br>    <span class="hljs-keyword">let</span> timeout;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">var</span> callNow = !timeout;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>            <span class="hljs-keyword">if</span> (callNow) func.<span class="hljs-title function_">apply</span>(context, args)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个方法可以作为公用的服务实现防抖。</strong></p><h3 id="节流-1"><a href="#节流-1" class="headerlink" title="节流"></a>节流</h3><p>节流也可以分为两种，一种是时间戳版，一种是定时器版。</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (now - previous &gt; wait) &#123;<br>            func.<span class="hljs-title function_">apply</span>(context, args);<br>            previous = now;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>    <span class="hljs-keyword">let</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timeout) &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                timeout = <span class="hljs-literal">null</span>;<br>                func.<span class="hljs-title function_">apply</span>(context, args)<br>            &#125;, wait)<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</strong></p><h4 id="结合版本"><a href="#结合版本" class="headerlink" title="结合版本"></a>结合版本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@desc</span> 函数节流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> func 函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wait 延迟执行毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> type 1 表时间戳版，2 表定时器版</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait ,type</span>) &#123;<br>    <span class="hljs-keyword">if</span>(type===<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type===<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">let</span> timeout;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>;<br>        <span class="hljs-keyword">if</span>(type===<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>            <span class="hljs-keyword">if</span> (now - previous &gt; wait) &#123;<br>                func.<span class="hljs-title function_">apply</span>(context, args);<br>                previous = now;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type===<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">if</span> (!timeout) &#123;<br>                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    timeout = <span class="hljs-literal">null</span>;<br>                    func.<span class="hljs-title function_">apply</span>(context, args)<br>                &#125;, wait)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue生命周期以及nextTick应用</title>
    <link href="/2019/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8AnextTick%E5%BA%94%E7%94%A8/"/>
    <url>/2019/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8AnextTick%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h2><span id="more"></span><p><img src="/2019/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8AnextTick%E5%BA%94%E7%94%A8/shengming.webp" alt="yasuo"><br><img src="/2019/04/01/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8AnextTick%E5%BA%94%E7%94%A8/biaoge.webp" alt="yasuo"></p><ul><li><strong>beforeCreate</strong>:在实例初始化之后，数据观测 data observer(props、data、computed) 和 event&#x2F;watcher 事件配置之前被调用。</li><li><strong>created</strong>:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch&#x2F;event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li><li><strong>beforeMount</strong>:在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li><strong>mounted</strong>:el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</li><li><strong>beforeUpdate</strong>:数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li><li><strong>updated</strong>:无论是组件本身的数据变更，还是从父组件接收到的 props 或者从 vuex 里面拿到的数据有变更，都会触发虚拟 DOM 重新渲染和打补丁，并在之后调用 updated。</li><li><strong>beforeDestroy</strong>:实例销毁之前调用。在这一步，实例仍然完全可用。</li><li><strong>destroyed</strong>:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>created 阶段的 ajax 请求与 mounted 请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。</p><h2 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h2><ol><li>初始化组件时，仅执行了<code>beforeCreate/Created/beforeMount/mounted</code>四个钩子函数</li><li>当改变 data 中定义的变量（响应式变量）时，会执行<code>beforeUpdate/updated</code>钩子函数</li><li>当切换组件（当前组件未缓存）时，会执行<code>beforeDestory/destroyed</code>钩子函数</li><li>初始化和销毁时的生命钩子函数均只会执行一次，<code>beforeUpdate/updated</code>可多次执行</li></ol><h2 id="Vue-nextTick"><a href="#Vue-nextTick" class="headerlink" title="Vue.nextTick()"></a>Vue.nextTick()</h2><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote><p>获取更新后的 DOM 言外之意就是什么操作需要用到了更新后的 DOM 而不能使用之前的 DOM 或者使用更新前的 DOM 会出问题，所以就衍生出了这个获取更新后的 DOM 的 Vue 方法。</p><blockquote><p><strong>Vue.nextTick()回调函数中的执行的应该是会对 DOM 进行操作的 js 代码</strong></p></blockquote><h3 id="什么时候需要用-Vue-nextTick"><a href="#什么时候需要用-Vue-nextTick" class="headerlink" title="什么时候需要用 Vue.nextTick()?"></a>什么时候需要用 Vue.nextTick()?</h3><ul><li>你在 Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中。原因是什么呢，原因是在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。</li><li>在数据变化后要执行的某个操作，当你设置 vm.someData &#x3D; ‘new value’，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的 DOM 更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</li><li>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">mounted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br><span class="hljs-comment">// Code that will run only after the</span><br><span class="hljs-comment">// entire view has been rendered</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/46c9d777cab1">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webp在项目中的应用</title>
    <link href="/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是webp？"><a href="#什么是webp？" class="headerlink" title="什么是webp？"></a>什么是webp？</h2><p>WebP格式，谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2&#x2F;3，并能节省大量的服务器宽带资源和数据空间。</p><span id="more"></span><h2 id="为什么要用webp"><a href="#为什么要用webp" class="headerlink" title="为什么要用webp"></a>为什么要用webp</h2><ol><li>减小图片加载资源的大小、节省用户流量资源</li><li>降低服务器流量资源</li></ol><h3 id="压缩率"><a href="#压缩率" class="headerlink" title="压缩率"></a>压缩率</h3><p><img src="/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/yasuo.webp" alt="yasuo"></p><h2 id="webp兼容性情况"><a href="#webp兼容性情况" class="headerlink" title="webp兼容性情况"></a>webp兼容性情况</h2><p><img src="/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/jianrong.webp" alt="yasuo"><br>结果：谷歌全面支持、安卓浏览器从4.2开始支持。那么在页面中对于安卓用户中图片资源加载大小会有大幅度下降。</p><h2 id="webp在各大网站的使用"><a href="#webp在各大网站的使用" class="headerlink" title="webp在各大网站的使用"></a>webp在各大网站的使用</h2><p>淘宝中大量使用webp。<br><img src="/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/taobao.webp" alt="yasuo"><br>各大cdn也是支持webp图片格式输出。</p><h2 id="项目中的实践"><a href="#项目中的实践" class="headerlink" title="项目中的实践"></a>项目中的实践</h2><p><img src="/2019/03/22/webp%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/liucheng.webp" alt="yasuo"> </p><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><h4 id="webp兼容性如何检测？"><a href="#webp兼容性如何检测？" class="headerlink" title="webp兼容性如何检测？"></a>webp兼容性如何检测？</h4><ol><li>通过js浏览器端判断是否支持webp<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">check_webp_feature</span>(<span class="hljs-params">feature, callback</span>) &#123;<br>    <span class="hljs-keyword">var</span> kTestImages = &#123;<br>        <span class="hljs-attr">lossy</span>: <span class="hljs-string">&quot;UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA&quot;</span>,<br>        <span class="hljs-attr">lossless</span>: <span class="hljs-string">&quot;UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==&quot;</span>,<br>        <span class="hljs-attr">alpha</span>: <span class="hljs-string">&quot;UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==&quot;</span>,<br>        <span class="hljs-attr">animation</span>: <span class="hljs-string">&quot;UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA&quot;</span><br>    &#125;;<br>    <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> result = (img.<span class="hljs-property">width</span> &gt; <span class="hljs-number">0</span>) &amp;&amp; (img.<span class="hljs-property">height</span> &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-title function_">callback</span>(feature, result);<br>    &#125;;<br>    img.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">callback</span>(feature, <span class="hljs-literal">false</span>);<br>    &#125;;<br>    img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;data:image/webp;base64,&quot;</span> + kTestImages[feature];<br>&#125;<br></code></pre></td></tr></table></figure></li><li>浏览器向服务端发起请求的时候accept 会带上image&#x2F;webp 信息，在服务端判断是否支持webp。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">map $http_accept $webp_suffix &#123;<br>        <span class="hljs-keyword">default</span>   <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-string">&quot;~*webp&quot;</span>  <span class="hljs-string">&quot;.webp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过nginx中map方法，查找是否有webp字段，如果有设置$webp_suffix 为.webp值。通过该值就可以来判断是否支持webp。如果支持写入cookie，前端通过检测cookie做判断，是否加载webp图片。</p><p>nginx 中设置cookie代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">location / &#123;<br>  <span class="hljs-keyword">if</span> ($webp_suffix ~* webp) &#123;<br>    add_header Set-Cookie <span class="hljs-string">&#x27;webpAvaile=true; path= /; expires=3153600&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在开发中使用"><a href="#在开发中使用" class="headerlink" title="在开发中使用"></a>在开发中使用</h3><h4 id="sass中使用"><a href="#sass中使用" class="headerlink" title="sass中使用"></a>sass中使用</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> webpbg(<span class="hljs-variable">$url</span>) &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-variable">$url</span>);<br>    <span class="hljs-keyword">@at-root</span> .webpa &amp; &#123;<br>        <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-variable">$url</span>+<span class="hljs-string">&#x27;.webp&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>scss文件使用  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@include</span> webpbg(<span class="hljs-string">&#x27;../image/header.jpg&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="html中使用"><a href="#html中使用" class="headerlink" title="html中使用"></a>html中使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;images/banner.jpg.webp&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;headImg&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/banner.jpg&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="生成webp资源"><a href="#生成webp资源" class="headerlink" title="生成webp资源"></a>生成webp资源</h4><p>使用webpack的loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> imagemin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;imagemin&#x27;</span>);<br><span class="hljs-keyword">var</span> imageminWebp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;imagemin-webp&#x27;</span>);<br><span class="hljs-keyword">var</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);<br> <br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">content</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cacheable</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cacheable</span>();<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">emitFile</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;emitFile is required from module system&quot;</span>);<br>    <span class="hljs-keyword">var</span> callback = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();<br>    <span class="hljs-keyword">var</span> options = loaderUtils.<span class="hljs-title function_">getOptions</span>(<span class="hljs-variable language_">this</span>);<br> <br>    <span class="hljs-comment">// 写入原文件</span><br>    <span class="hljs-keyword">var</span> url = loaderUtils.<span class="hljs-title function_">interpolateName</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">name</span> || <span class="hljs-string">&quot;[hash].[ext]&quot;</span>, &#123;<br>        <span class="hljs-attr">content</span>: content,<br>        <span class="hljs-attr">regExp</span>: options.<span class="hljs-property">regExp</span><br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitFile</span>(url, content);<br> <br>    <span class="hljs-comment">// 如果源文件比较小，则没必要转换为webp格式的图片，直接使用callback传递给下一个loader处理</span><br>    <span class="hljs-keyword">var</span> limit;<br>    <span class="hljs-keyword">if</span> (options.<span class="hljs-property">limit</span>) &#123;<br>        limit = <span class="hljs-built_in">parseInt</span>(options.<span class="hljs-property">limit</span>, <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (limit &lt;= <span class="hljs-number">0</span> || content.<span class="hljs-property">length</span> &lt; limit) &#123;<br>        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">buffer</span>: content, url &#125;)<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 根据options内容生成webpOptions</span><br>    <span class="hljs-keyword">var</span> webpOptions = &#123;<br>        <span class="hljs-attr">preset</span>: options.<span class="hljs-property">preset</span> || <span class="hljs-string">&#x27;default&#x27;</span>,<br>        <span class="hljs-attr">quality</span>: options.<span class="hljs-property">quality</span> || <span class="hljs-number">75</span>,<br>        <span class="hljs-attr">alphaQuality</span>: options.<span class="hljs-property">alphaQuality</span> || <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">method</span>: options.<span class="hljs-property">method</span> || <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">sns</span>: options.<span class="hljs-property">sns</span> || <span class="hljs-number">80</span>,<br>        <span class="hljs-attr">autoFilter</span>: options.<span class="hljs-property">autoFilter</span> || <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">sharpness</span>: options.<span class="hljs-property">sharpness</span> || <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">lossless</span>: options.<span class="hljs-property">lossless</span> || <span class="hljs-literal">false</span>,<br>    &#125;;<br>    <span class="hljs-keyword">if</span> (options.<span class="hljs-property">size</span>) &#123;<br>        webpOptions.<span class="hljs-property">size</span> = options.<span class="hljs-property">size</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (options.<span class="hljs-property">filter</span>) &#123;<br>        webpOptions.<span class="hljs-property">filter</span> = options.<span class="hljs-property">filter</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 生成的webp图片的名称为原图片的名称后面追加.webp,</span><br>    <span class="hljs-comment">// 例如：xxx.jpg.webp, 方便在css预处理器中的使用</span><br>    <span class="hljs-keyword">var</span> webpUrl = url + <span class="hljs-string">&#x27;.webp&#x27;</span>;<br>    <span class="hljs-comment">// 原图片异步转换为webp的图片</span><br>    imagemin.<span class="hljs-title function_">buffer</span>(content, &#123; <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">imageminWebp</span>(webpOptions)] &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 写入webp图片并调用callback</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">emitFile</span>(webpUrl, file);<br>        <span class="hljs-comment">// 传递给svg-placrholder-loader，继续处理成placeholder</span><br>        <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">buffer</span>: content, url, webpUrl &#125;);<br> <br>        <span class="hljs-comment">/* 如果要单独使用的话，可以使用该注释部分的代码</span><br><span class="hljs-comment">        const exportJson = &#x27;module.exports = &#123; &#x27; +</span><br><span class="hljs-comment">            &#x27;&quot;originSrc&quot;: __webpack_public_path__ + &quot;&#x27; + url +</span><br><span class="hljs-comment">            &#x27;&quot; , &quot;webpSrc&quot;: __webpack_public_path__ + &quot;&#x27; + webpUrl +</span><br><span class="hljs-comment">            &#x27;&quot;&#x27; +</span><br><span class="hljs-comment">            &#x27; &#125;;&#x27;;</span><br><span class="hljs-comment">        callback(null, exportJson);   </span><br><span class="hljs-comment">        */</span>  <br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">callback</span>(err);<br>    &#125;);<br> <br>&#125;;<br> <br><span class="hljs-comment">// 要求webpack传入原始的buffer，方便处理图片</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">raw</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>nginx生成<br>实现过程，对支持webp的请求设置cookies。利用nginx检测图片请求是否存在，如果不存在通过lua调用imageMagic创建webp图片并返回。需要注意的是nginx需要安装lua支持的模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">user  root; # nginx 用户权限 执行lua创建图片命令需要读写权限<br># ...<br>http &#123;<br>    include       mime.types;<br>    server &#123;<br>        listen       <span class="hljs-number">80</span>;<br>        server_name  webp.leewr.com;<br>        root         /home/leewr/mono/app/<span class="hljs-keyword">public</span>/december;<br>        location / &#123;<br>            <span class="hljs-keyword">if</span> ($webp_suffix ~* webp) &#123;<br>                add_header Set-Cookie <span class="hljs-string">&#x27;webpAvaile=true; path= /;&#x27;</span>;<br>            &#125;<br>        &#125;<br>        location ~* ^(.+\.(jpg|png|jpeg|gif))(.webp)$ &#123; # 正则匹配图片 paht/name.jpg.webp 格式的图片请求<br>            <span class="hljs-keyword">if</span> (!-f $request_filename) &#123; # 如果图片不存在<br>                access_log /usr/local/nginx/logs/december.log main; # 设置日志文件<br>                set $request_filepath /home/leewr/mono/app/<span class="hljs-keyword">public</span>/december/$<span class="hljs-number">1</span>; # 图片真实路径变量<br>                set $ext $<span class="hljs-number">3</span>; # 设置图片扩展名$ext变量<br>                content_by_lua_file lua/webp.lua; # 调用nginx/lua目录下的webp.lua文件<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面看lua, lua 中代码非常简单。定义command命令，调用系统os.execute(command)执行convert图片转换命令。convert是ImageMagic的命令。.. lua 中字符串连接。ngx.var.ext是nginx中定义的变量。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">local</span> command<br>command = <span class="hljs-string">&quot;convert &quot;</span> ..ngx.var.request_filepath.. <span class="hljs-string">&quot; &quot;</span> ..ngx.var.request_filepath..ngx.var.ext<br>os.execute(command)<br>ngx.exec(ngx.var.request_uri)<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/73ca9e8b986a">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>meta标签使用总结</title>
    <link href="/2019/03/02/meta%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2019/03/02/meta%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Meta对象"><a href="#Meta对象" class="headerlink" title="Meta对象"></a>Meta对象</h2><p>Meta 对象代表 HTML 的 一个 <meta> 元素。</p><meta> 元素可提供有关某个 HTML 元素的元信息 (meta-information)，比如描述、针对搜索引擎的关键词以及刷新频率。<span id="more"></span>## meta对象的属性<table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>content</td><td>设置或返回 <meta> 元素的 content 属性的值。</td></tr><tr><td>httpEquiv</td><td>把 content 属性连接到一个 HTTP 头部。</td></tr><tr><td>name</td><td>把 content 属性连接到某个名称。</td></tr><tr><td>scheme</td><td>设置或返回用于解释 content 属性的值的格式。</td></tr></tbody></table><p>常用的包括 http-equiv搭配content和name搭配content两种。</p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><h3 id="name可用参数有这些："><a href="#name可用参数有这些：" class="headerlink" title="name可用参数有这些："></a><strong>name可用参数有这些：</strong></h3><h3 id="keywords-关键字"><a href="#keywords-关键字" class="headerlink" title="keywords(关键字)"></a>keywords(关键字)</h3><p>说明：用于告诉搜索引擎，你网页的关键字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;前端,js,css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="description-网站内容的描述"><a href="#description-网站内容的描述" class="headerlink" title="description(网站内容的描述)"></a>description(网站内容的描述)</h3><p>说明：用于告诉搜索引擎，你网站的主要内容  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;一个前端网站&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="viewport-移动端的窗口"><a href="#viewport-移动端的窗口" class="headerlink" title="viewport(移动端的窗口)"></a>viewport(移动端的窗口)</h3><p>说明：在用bootstrap,AmazeUI等框架时候都有用过viewport。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="robots-定义搜索引擎爬虫的索引方式"><a href="#robots-定义搜索引擎爬虫的索引方式" class="headerlink" title="robots(定义搜索引擎爬虫的索引方式)"></a>robots(定义搜索引擎爬虫的索引方式)</h3><p>说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。content的参数有all,none,index,noindex,follow,nofollow。默认是all。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>具体参数如下：</p><ol><li>none : 搜索引擎将忽略此网页，等价于noindex，nofollow。</li><li>noindex : 搜索引擎不索引此网页。</li><li>nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。</li><li>all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。</li><li>index : 搜索引擎索引此网页。</li><li>follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。</li></ol><h3 id="author-作者"><a href="#author-作者" class="headerlink" title="author(作者)"></a>author(作者)</h3><p>说明：用于标注网页作者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="generator-网页制作软件"><a href="#generator-网页制作软件" class="headerlink" title="generator(网页制作软件)"></a>generator(网页制作软件)</h3><p>说明：用于标明网页是什么软件做的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generator&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Sublime Text3&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="copyright-版权"><a href="#copyright-版权" class="headerlink" title="copyright(版权)"></a>copyright(版权)</h3><p>说明：用于标注版权信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;copyright&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="revisit-after-搜索引擎爬虫重访时间"><a href="#revisit-after-搜索引擎爬虫重访时间" class="headerlink" title="revisit-after(搜索引擎爬虫重访时间)"></a>revisit-after(搜索引擎爬虫重访时间)</h3><p>说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;revisit-after&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;7 days&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><h3 id="renderer-双核浏览器渲染方式"><a href="#renderer-双核浏览器渲染方式" class="headerlink" title="renderer(双核浏览器渲染方式)"></a>renderer(双核浏览器渲染方式)</h3><p>说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;renderer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;webkit&quot;</span>&gt;</span> //默认webkit内核<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;renderer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie-comp&quot;</span>&gt;</span> //默认IE兼容模式<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;renderer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie-stand&quot;</span>&gt;</span> //默认IE标准模式<br></code></pre></td></tr></table></figure><h2 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h2><h3 id="content-Type-设定网页字符集-推荐使用HTML5的方式"><a href="#content-Type-设定网页字符集-推荐使用HTML5的方式" class="headerlink" title="content-Type(设定网页字符集)(推荐使用HTML5的方式)"></a>content-Type(设定网页字符集)(推荐使用HTML5的方式)</h3><p>说明：用于设定网页字符集，便于浏览器解析与渲染页面举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span>  //旧的HTML，不推荐<br><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8<br></code></pre></td></tr></table></figure><h3 id="X-UA-Compatible-浏览器采取何种版本渲染当前页面"><a href="#X-UA-Compatible-浏览器采取何种版本渲染当前页面" class="headerlink" title="X-UA-Compatible(浏览器采取何种版本渲染当前页面)"></a>X-UA-Compatible(浏览器采取何种版本渲染当前页面)</h3><p>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span> //指定IE和Chrome使用最新版本渲染当前页面<br></code></pre></td></tr></table></figure><h3 id="cache-control-指定请求和响应遵循的缓存机制"><a href="#cache-control-指定请求和响应遵循的缓存机制" class="headerlink" title="cache-control(指定请求和响应遵循的缓存机制)"></a>cache-control(指定请求和响应遵循的缓存机制)</h3><p>说明：指导浏览器如何缓存某个响应以及缓存多长时间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;cache-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-cache&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>共有以下几种用法：</p><ol><li><p>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p></li><li><p>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</p></li><li><p>public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</p></li><li><p>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</p></li><li><p>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age&#x3D;60表示响应可以再缓存和重用 60 秒。<br>用法2.(禁止百度自动转码)<br>说明：用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。举例：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Cache-Control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-siteapp&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="expires-网页到期时间"><a href="#expires-网页到期时间" class="headerlink" title="expires(网页到期时间)"></a>expires(网页到期时间)</h3><p>说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;expires&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Sunday 26 October 2016 01:00 GMT&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="refresh-自动刷新并指向某页面"><a href="#refresh-自动刷新并指向某页面" class="headerlink" title="refresh(自动刷新并指向某页面)"></a>refresh(自动刷新并指向某页面)</h3><p>说明：网页将在设定的时间内，自动刷新并调向设定的网址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;2；URL=http://www.baidu.com/&quot;</span>&gt;</span> //意思是2秒后跳转向baidu<br></code></pre></td></tr></table></figure><h3 id="Set-Cookie-cookie设定"><a href="#Set-Cookie-cookie设定" class="headerlink" title="Set-Cookie(cookie设定)"></a>Set-Cookie(cookie设定)</h3><p>说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;set-cookie&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;runoobcookie=myContent;expires=Fri, 30 Dec 2015 12:00:00 GMT; path=http://www.runoob.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>html</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化——DNS预解析</title>
    <link href="/2019/02/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94DNS%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2019/02/21/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94DNS%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是DNS预解析？"><a href="#什么是DNS预解析？" class="headerlink" title="什么是DNS预解析？"></a>什么是DNS预解析？</h2><p>我们在进行前端性能优化时，涉及到DNS方面的优化一般有两点： 一个是减少DNS的请求次数，另一个就是进行DNS预解析 。</p><p>DNS 实现域名到IP的映射。通过域名访问站点，每次请求都要做DNS解析。目前每次DNS解析，通常在200ms以下。针对DNS解析耗时问题，一些浏览器通过DNS Prefetch 来提高访问的流畅性。  </p><p><strong>DNS Prefetch</strong> 是一种DNS 预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</p><h4 id="DNS-Prefetch，即DNS预解析。"><a href="#DNS-Prefetch，即DNS预解析。" class="headerlink" title="DNS Prefetch，即DNS预解析。"></a><strong>DNS Prefetch，即DNS预解析。</strong></h4><span id="more"></span><h2 id="为什么使用DNS预解析？"><a href="#为什么使用DNS预解析？" class="headerlink" title="为什么使用DNS预解析？"></a>为什么使用DNS预解析？</h2><p>DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS预解析 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。</p><h4 id="DNS解析的运行顺序"><a href="#DNS解析的运行顺序" class="headerlink" title="DNS解析的运行顺序"></a>DNS解析的运行顺序</h4><p>浏览器对网站第一次的域名DNS解析查找流程依次为：<br><strong>浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索</strong>  </p><h2 id="支持DNS-Prefetch的浏览器"><a href="#支持DNS-Prefetch的浏览器" class="headerlink" title="支持DNS Prefetch的浏览器"></a>支持DNS Prefetch的浏览器</h2><ul><li>Chrome</li><li>IE:9+</li><li>Firefox:3.5+</li><li>Safari:5+</li><li>Edge</li></ul><h2 id="如何在网站中使用DNS预解析"><a href="#如何在网站中使用DNS预解析" class="headerlink" title="如何在网站中使用DNS预解析"></a>如何在网站中使用DNS预解析</h2><p>因为浏览器的html解析是顺序的，所以DNS Prefetch 应该尽量的放在网页的前面，推荐放在 <meta charset="UTF-8"> 后面：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;x-dns-prefetch-control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;on&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--打开和关闭DNS预预解析--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//www.baidu.com&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--解析的DNS的地址--&gt;</span><br></code></pre></td></tr></table></figure><p>注：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。</p>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>promise.all和promise.race</title>
    <link href="/2019/02/17/promose-all%E5%92%8Cpromise-race/"/>
    <url>/2019/02/17/promose-all%E5%92%8Cpromise-race/</url>
    
    <content type="html"><![CDATA[<h2 id="Promise-all和Promise-race的功能"><a href="#Promise-all和Promise-race的功能" class="headerlink" title="Promise.all和Promise.race的功能"></a>Promise.all和Promise.race的功能</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p><strong>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</strong></p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p1完成&#x27;</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p2完成&#x27;</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promse</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;p3失败&#x27;</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)               <span class="hljs-comment">//[&#x27;p1完成&#x27;, &#x27;p2完成&#x27;]</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p3,p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)      <span class="hljs-comment">// 失败了，打出 &#x27;&#x27;p3失败&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p><strong>Promise.race可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是第一个返回的resolve，而失败的时候则返回最先被reject失败状态的值。（换句话说就是返回最快的那个）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;failed&#x27;</span>)<br>  &#125;, <span class="hljs-number">500</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)  <span class="hljs-comment">// 打开的是 &#x27;failed&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h2><h3 id="Promise-all-1"><a href="#Promise-all-1" class="headerlink" title="Promise.all"></a>Promise.all</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> resultList = [];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-title function_">next</span>();<br>        next = <span class="hljs-function">() =&gt;</span> &#123;<br>            arr[i].<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (!rej) &#123;<br>                    resultList.<span class="hljs-title function_">push</span>(res);<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(rej);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i == arr.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(resultList);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">next</span>();<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Promise-race-1"><a href="#Promise-race-1" class="headerlink" title="Promise.race"></a>Promise.race</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> resultList = [];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-title function_">next</span>();<br>        next = <span class="hljs-function">() =&gt;</span> &#123;<br>            arr[i].<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (!rej) &#123;<br>                    resultList.<span class="hljs-title function_">push</span>(res);<br>                    i++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(rej);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i == arr.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(resultList);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">next</span>();<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Promise-all的问题"><a href="#Promise-all的问题" class="headerlink" title="Promise.all的问题"></a>Promise.all的问题</h2><p><strong>在上面的代码中，Promise.all使用的是循环调用的方式，也就算是链式调用（Promise链），事实上Promise.all是并发，同时进行所有的promise方法。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(arr.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>            arr[i].<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (!rej) &#123;<br>                    resultList[i] = (res);<br>                    <span class="hljs-keyword">if</span> (temp == arr.<span class="hljs-property">length</span>) &#123;<br>                        <span class="hljs-title function_">resolve</span>(resultList);<br>                    &#125;<br>                    temp++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(rej);<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise原理和实现</title>
    <link href="/2019/02/05/promise%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/02/05/promise%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p><span id="more"></span><h3 id="Promise规范"><a href="#Promise规范" class="headerlink" title="Promise规范"></a>Promise规范</h3><ul><li>ES6中使用<a href="https://juejin.im/post/5c4b0423e51d4525211c0fbc">Promise&#x2F;A+</a>规范。</li><li>Promise的标准理解<ul><li>promise对象有三种状态<strong>pending</strong>、<strong>fulfilled</strong>和<strong>rejected</strong>。</li><li>promise对象的状态必须有并且只有上述三种当中的一种。</li><li>状态的改变只能是从pending到fulfilled或者pending到rejected。</li><li>then方法返回一个promise。then 方法可以被同一个 promise 调用多次。<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">promise.then(<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h3><ol><li>构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">resolver</span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>原型链<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>静态方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="Promise基本结构"><a href="#Promise基本结构" class="headerlink" title="Promise基本结构"></a>Promise基本结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;FULFILLED&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">a</span>=&gt;</span> <span class="hljs-title function_">alert</span>(a));<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-title function_">alert</span>(a+<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h3 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h3><p>构造函数用法总结：</p><ol><li>构造函数接收一个<strong>executor</strong>立即执行函数</li><li><strong>executor</strong>立即执行函数接收一个<strong>resolve</strong>函数</li><li><strong>promise</strong>对象的<strong>then</strong>方法绑定状态变为<strong>fulfilled</strong>时的回调</li><li><strong>resolve</strong>函数被调用时会触发<strong>then</strong>方法中的回调</li></ol><h4 id="构造函数的初步实现"><a href="#构造函数的初步实现" class="headerlink" title="构造函数的初步实现"></a>构造函数的初步实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">//promise当前的状态</span><br>    self.<span class="hljs-property">data</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">//promise的值</span><br>    self.<span class="hljs-property">onResolvedCallback</span> = [];<br>    <span class="hljs-comment">//promise状态变为resolve时的回调函数集，可能有多个</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>       <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>           self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>           self.<span class="hljs-property">data</span> = value;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-property">length</span>; i++) &#123;<br>               self.<span class="hljs-property">onResolvedCallback</span>[i](value);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-title function_">executor</span>(resolve);<br>&#125;;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-title function_">push</span>(resolve);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="添加reject结果"><a href="#添加reject结果" class="headerlink" title="添加reject结果"></a>添加reject结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">//promise当前的状态</span><br>    self.<span class="hljs-property">data</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">//promise的值</span><br>    self.<span class="hljs-property">onResolvedCallback</span> = [];<br>    <span class="hljs-comment">//promise状态变为resolve时的回调函数集，可能有多个</span><br>    self.<span class="hljs-property">onRejectedCallback</span> = [];<br>    <span class="hljs-comment">//promise状态变为reject时的回调函数集，可能有多个</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>       <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>           self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>           self.<span class="hljs-property">data</span> = value;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-property">length</span>; i++) &#123;<br>               self.<span class="hljs-property">onResolvedCallback</span>[i](value);<br>           &#125;<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>            self.<span class="hljs-property">data</span> = reason;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">onRejectedCallback</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                self.<span class="hljs-property">onRejectedCallback</span>[i](reason);<br>            &#125;<br>        &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-title function_">executor</span>(resolve, reject);<br>   &#125; <span class="hljs-keyword">catch</span> (e)&#123;<br>       <span class="hljs-title function_">reject</span>(e);<br>   &#125;<br>&#125;;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolve, onReject</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-title function_">push</span>(onResolve);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallback</span>.<span class="hljs-title function_">push</span>(onReject);<br>&#125;;<br></code></pre></td></tr></table></figure><p>小结：</p><ol><li><strong>executor</strong>函数作为实参在创建<strong>Promise</strong>对象时传入<strong>Promise</strong>构造函数。</li><li><strong>resolve</strong>和<strong>reject</strong>函数作为实参传入<strong>executor</strong>函数。</li><li><strong>value</strong>作为实参传入<strong>resolve</strong>和<strong>reject</strong>函数。</li></ol><h4 id="如果executor自执行函数中的resolve函数立即触发时，发现Promise失效"><a href="#如果executor自执行函数中的resolve函数立即触发时，发现Promise失效" class="headerlink" title="如果executor自执行函数中的resolve函数立即触发时，发现Promise失效"></a>如果executor自执行函数中的resolve函数立即触发时，发现Promise失效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> <span class="hljs-title function_">alert</span>(a));<br><br></code></pre></td></tr></table></figure><p>将promise的resolve和reject异步执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span>;<br>            self.<span class="hljs-property">data</span> = value;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                self.<span class="hljs-property">onResolvedCallback</span>[i](value);<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>            self.<span class="hljs-property">data</span> = reason;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">onRejectedCallback</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                self.<span class="hljs-property">onRejectedCallback</span>[i](reason);<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(onFulfilled, onRejected)<br></code></pre></td></tr></table></figure><ol><li><strong>then</strong>方法返回一个新的<strong>promise</strong>对象。</li><li><strong>executor</strong>自执行函数中的<strong>resolve</strong>参数调用时执行<strong>then</strong>方法的第一个回调函数<strong>onResolved</strong>。</li><li><strong>executor</strong>自执行函数中的<strong>reject</strong>参数调用时执行<strong>then</strong>方法的第二个回调函数<strong>onRejected</strong>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> promise2;<br>    onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&#x27;function&#x27;</span> <br>                ? onResolved <br>                : <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<span class="hljs-keyword">return</span> value&#125;;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> <br>                ? onRejected <br>                : <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<span class="hljs-keyword">throw</span> reason&#125;;<br>    <span class="hljs-comment">//promise对象当前状态为resolved</span><br>    <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//调用onResolve回调函数</span><br>                <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">data</span>);<br>                <span class="hljs-comment">//如果onResolve回调函数返回值为一个promise对象</span><br>                <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span>  <span class="hljs-title class_">Promise</span>) &#123;<br>                    <span class="hljs-comment">//将它的结果作为promise2的结果</span><br>                    x.<span class="hljs-title function_">then</span>(resolve, reject);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(x);<span class="hljs-comment">//执行promise2的onResolve回调</span><br>           &#125;        <br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                <span class="hljs-title function_">reject</span>(e); <span class="hljs-comment">//执行promise2的onReject回调</span><br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">//promise对象当前状态为rejected</span><br>    <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">data</span>);<br>                <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                    x.<span class="hljs-title function_">then</span>(resolve, reject)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(x)<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                <span class="hljs-title function_">reject</span>(e)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">//promise对象当前状态为pending</span><br>    <span class="hljs-comment">//此时并不能确定调用onResolved还是onRejected，需要等当前Promise状态确定。</span><br>    <span class="hljs-comment">//所以需要将callBack放入promise1的回调数组中</span><br>    <span class="hljs-keyword">if</span>(self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>            self.<span class="hljs-property">onResolvedCallback</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">data</span>);<br>                    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                        x.<span class="hljs-title function_">then</span>(resolve, reject);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(x);<br>          &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e);<br>                &#125;<br>            &#125;)<br>            self.<span class="hljs-property">onRejectedCallback</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">data</span>);<br>                    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                        x.<span class="hljs-title function_">then</span>(resolve, reject)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(x);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                    <span class="hljs-title function_">reject</span>(e)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Promise</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">resolver</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> resolver !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <span class="hljs-comment">//resolver必须是函数</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Promise resolver &#x27;</span> + resolver + <span class="hljs-string">&#x27; is not a function&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(resolver)<br><br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//保存this</span><br>        self.<span class="hljs-property">callbacks</span> = [] <span class="hljs-comment">//保存onResolve和onReject函数集合</span><br>        self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span> <span class="hljs-comment">//当前状态</span><br><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//异步调用</span><br>                <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span> <span class="hljs-comment">//修改状态</span><br>                self.<span class="hljs-property">data</span> = value<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                    self.<span class="hljs-property">callbacks</span>[i].<span class="hljs-title function_">onResolved</span>(value)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">//异步调用</span><br>                <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                self.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span> <span class="hljs-comment">//修改状态</span><br>                self.<span class="hljs-property">data</span> = reason<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; self.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span>; i++) &#123;<br>                    self.<span class="hljs-property">callbacks</span>[i].<span class="hljs-title function_">onRejected</span>(reason)<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-title function_">resolver</span>(resolve, reject) <span class="hljs-comment">//执行resolver函数</span><br>        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>            <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">promise, x, resolve, reject</span>) &#123;<br>        <span class="hljs-keyword">var</span> then<br>        <span class="hljs-keyword">var</span> thenCalledOrThrow = <span class="hljs-literal">false</span><br><br>        <span class="hljs-keyword">if</span> (promise === x) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise!&#x27;</span>))<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span>) &amp;&amp; ((<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>))) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                then = x.<span class="hljs-property">then</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>                    then.<span class="hljs-title function_">call</span>(x, <span class="hljs-keyword">function</span> <span class="hljs-title function_">rs</span>(<span class="hljs-params">y</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span><br>                        thenCalledOrThrow = <span class="hljs-literal">true</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolvePromise</span>(promise, y, resolve, reject)<br>                    &#125;, <span class="hljs-keyword">function</span> <span class="hljs-title function_">rj</span>(<span class="hljs-params">r</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span><br>                        thenCalledOrThrow = <span class="hljs-literal">true</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(r)<br>                    &#125;)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(x)<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                <span class="hljs-keyword">if</span> (thenCalledOrThrow) <span class="hljs-keyword">return</span><br>                thenCalledOrThrow = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(x)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>        <span class="hljs-comment">//健壮性处理，处理点击穿透</span><br>        onResolved = <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&#x27;function&#x27;</span> ? onResolved : <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123;<span class="hljs-keyword">return</span> v&#125;<br>        onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>)&#123;<span class="hljs-keyword">throw</span> r&#125;<br>        <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span><br>        <span class="hljs-keyword">var</span> promise2<br><br>        <span class="hljs-comment">//promise状态为resolved</span><br>        <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;resolved&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//调用then方法的onResolved回调</span><br>                        <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onResolved</span>(self.<span class="hljs-property">data</span>)<br>                        <span class="hljs-comment">//根据x的值修改promise2的状态</span><br>                        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        <span class="hljs-comment">//promise2状态变为rejected</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e)<br>                    &#125;<br>                &#125;)<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">//promise状态为rejected</span><br>        <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//调用then方法的onReject回调</span><br>                        <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(self.<span class="hljs-property">data</span>)<br>                        <span class="hljs-comment">//根据x的值修改promise2的状态</span><br>                        <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>                    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                        <span class="hljs-comment">//promise2状态变为rejected</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e)<br>                    &#125;<br>                &#125;)<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-comment">//promise状态为pending</span><br>        <span class="hljs-comment">//需要等待promise的状态改变</span><br>        <span class="hljs-keyword">if</span> (self.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>                self.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;<br>                    <span class="hljs-attr">onResolved</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//调用then方法的onResolved回调</span><br>                            <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onResolved</span>(value)<br>                            <span class="hljs-comment">//根据x的值修改promise2的状态</span><br>                            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>                        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                            <span class="hljs-comment">//promise2状态变为rejected</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e)<br>                        &#125;<br>                    &#125;,<br>                    <span class="hljs-attr">onRejected</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//调用then方法的onResolved回调</span><br>                            <span class="hljs-keyword">var</span> x = <span class="hljs-title function_">onRejected</span>(reason)<br>                            <span class="hljs-comment">//根据x的值修改promise2的状态</span><br>                            <span class="hljs-title function_">resolvePromise</span>(promise2, x, resolve, reject)<br>                        &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>                            <span class="hljs-comment">//promise2状态变为rejected</span><br>                            <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e)<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取当前Promise传递的值</span><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span><br>    &#125;<br><br>    <span class="hljs-comment">//由then方法实现catch方法</span><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected)<br>    &#125;<br><br>    <span class="hljs-comment">//finally方法</span><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>(fn)<br>            <span class="hljs-keyword">return</span> v<br>        &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>)&#123;<br>            <span class="hljs-built_in">setTimeout</span>(fn)<br>            <span class="hljs-keyword">throw</span> r<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">spread</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn, onRejected</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">values</span>) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, values)<br>        &#125;, onRejected)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">inject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn, onRejected</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) &#123;<br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, fn.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\((.*?)\)/</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)&#123;<br>                <span class="hljs-keyword">return</span> v[key];<br>            &#125;))<br>        &#125;, onRejected)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">delay</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">duration</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(value)<br>                &#125;, duration)<br>            &#125;)<br>        &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-title function_">reject</span>(reason)<br>                &#125;, duration)<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-keyword">var</span> resolvedCounter = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">var</span> promiseNum = promises.<span class="hljs-property">length</span><br>            <span class="hljs-keyword">var</span> resolvedValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseNum)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>                (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>                    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>                        resolvedCounter++<br>                        resolvedValues[i] = value<br>                        <span class="hljs-keyword">if</span> (resolvedCounter == promiseNum) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(resolvedValues)<br>                        &#125;<br>                    &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason)<br>                    &#125;)<br>                &#125;)(i)<br>            &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>                <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(value)<br>                &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(reason)<br>                &#125;)<br>            &#125;<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-title function_">resolvePromise</span>(promise, value, resolve, reject)<br>        &#125;)<br>        <span class="hljs-keyword">return</span> promise<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>            <span class="hljs-title function_">reject</span>(reason)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">fcall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>)&#123;<br>        <span class="hljs-comment">// 虽然fn可以接收到上一层then里传来的参数，但是其实是undefined，所以跟没有是一样的，因为resolve没参数啊</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(fn)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">done</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">stop</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-property">defer</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> dfd = &#123;&#125;<br>        dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>            dfd.<span class="hljs-property">resolve</span> = resolve<br>            dfd.<span class="hljs-property">reject</span> = reject<br>        &#125;)<br>        <span class="hljs-keyword">return</span> dfd<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// CommonJS compliance</span><br>        <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Promise</span><br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span><br>&#125;)()<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/43de678e918a">Promise实现原理</a><br><a href="https://www.jianshu.com/p/b4f0425b22a1">Promise原理与实现</a></p>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初次使用hexo</title>
    <link href="/2019/01/14/%E5%88%9D%E5%B0%9Dhexo/"/>
    <url>/2019/01/14/%E5%88%9D%E5%B0%9Dhexo/</url>
    
    <content type="html"><![CDATA[<p>偶然间发现了hexo这个博客搭建工具，于是决定将使用多年的云笔记的内容搬迁至这个博客上，分享我的搬迁经历以及踩过的坑吧~。</p><span id="more"></span><h2 id="我们开始吧"><a href="#我们开始吧" class="headerlink" title="我们开始吧"></a>我们开始吧</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>在github新建仓库，如果想要部署在github上，要仓库名为 &#x3D;&#x3D;<user-name>.github.io&#x3D;&#x3D; 而不是user-name ，其中 &#x3D;&#x3D;<user-name>&#x3D;&#x3D; 是你 &#x3D;&#x3D;github&#x3D;&#x3D; 的昵称，要是问为什么，都是眼泪的教训。</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">npm install hexo<br></code></pre></td></tr></table></figure><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>初始化命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>大功告成，访问 &#x3D;&#x3D;localhost:4000&#x3D;&#x3D; 我们就能看到建的博客的效果了！</p><h3 id="将Hexo部署到GitHub-Pages上"><a href="#将Hexo部署到GitHub-Pages上" class="headerlink" title="将Hexo部署到GitHub Pages上"></a>将Hexo部署到GitHub Pages上</h3><ol><li>将<a href="https://github.com/marketplace/travis-ci">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/">手动前往</a>。</li><li>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens">新建 Personal Access Token</a> ，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 GH_TOKEN，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的 Hexo 站点文件夹中新建一个 &#x3D;&#x3D;.travis.yml&#x3D;&#x3D; 文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-number">10</span> <span class="hljs-comment"># use nodejs v10 LTS</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span> <span class="hljs-comment"># build master branch only</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># generate static files</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br></code></pre></td></tr></table></figure><ol start="7"><li><p>将.travis.yml 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 gh-pages 分支下</p></li><li><p>在GitHub中前往你的repository 的设置页面，修改 GitHub Pages 的部署分支为 gh-pages。</p></li><li><p>完成以上步骤，我们就能在<user-name>.github.io上看到自己建设的博客了。</p></li></ol><h3 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h3><p>请参考<a href="https://hexo.io/zh-cn/docs">hexo文档</a>。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
